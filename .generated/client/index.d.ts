/**
 * Client
 **/

import * as runtime from "./runtime/client.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model Student
 *
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>;
/**
 * Model Core
 *
 */
export type Core = $Result.DefaultSelection<Prisma.$CorePayload>;
/**
 * Model Faculty
 *
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>;
/**
 * Model Event
 *
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>;
/**
 * Model Links
 *
 */
export type Links = $Result.DefaultSelection<Prisma.$LinksPayload>;
/**
 * Model Team
 *
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>;
/**
 * Model Winners
 *
 */
export type Winners = $Result.DefaultSelection<Prisma.$WinnersPayload>;
/**
 * Model Placement
 *
 */
export type Placement = $Result.DefaultSelection<Prisma.$PlacementPayload>;
/**
 * Model Company
 *
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>;
/**
 * Model Offer
 *
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>;
/**
 * Model Year
 *
 */
export type Year = $Result.DefaultSelection<Prisma.$YearPayload>;
/**
 * Model Patents
 *
 */
export type Patents = $Result.DefaultSelection<Prisma.$PatentsPayload>;
/**
 * Model Publication
 *
 */
export type Publication = $Result.DefaultSelection<Prisma.$PublicationPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
    USER: "USER";
    ADMIN: "ADMIN";
  };

  export type Role = (typeof Role)[keyof typeof Role];

  export const EventType: {
    SOLO: "SOLO";
    TEAM: "TEAM";
  };

  export type EventType = (typeof EventType)[keyof typeof EventType];

  export const EventCategory: {
    PREVIOUS: "PREVIOUS";
    UPCOMING: "UPCOMING";
    CURRENT: "CURRENT";
  };

  export type EventCategory =
    (typeof EventCategory)[keyof typeof EventCategory];

  export const WinnerType: {
    FIRST: "FIRST";
    SECOND: "SECOND";
    THIRD: "THIRD";
    PARTICIPATION: "PARTICIPATION";
  };

  export type WinnerType = (typeof WinnerType)[keyof typeof WinnerType];
}

export type Role = $Enums.Role;

export const Role: typeof $Enums.Role;

export type EventType = $Enums.EventType;

export const EventType: typeof $Enums.EventType;

export type EventCategory = $Enums.EventCategory;

export const EventCategory: typeof $Enums.EventCategory;

export type WinnerType = $Enums.WinnerType;

export const WinnerType: typeof $Enums.WinnerType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Students
   * const students = await prisma.student.findMany()
   * ```
   */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.core`: Exposes CRUD operations for the **Core** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Cores
   * const cores = await prisma.core.findMany()
   * ```
   */
  get core(): Prisma.CoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Faculties
   * const faculties = await prisma.faculty.findMany()
   * ```
   */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Events
   * const events = await prisma.event.findMany()
   * ```
   */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.links`: Exposes CRUD operations for the **Links** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Links
   * const links = await prisma.links.findMany()
   * ```
   */
  get links(): Prisma.LinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.winners`: Exposes CRUD operations for the **Winners** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Winners
   * const winners = await prisma.winners.findMany()
   * ```
   */
  get winners(): Prisma.WinnersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placement`: Exposes CRUD operations for the **Placement** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Placements
   * const placements = await prisma.placement.findMany()
   * ```
   */
  get placement(): Prisma.PlacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Offers
   * const offers = await prisma.offer.findMany()
   * ```
   */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.year`: Exposes CRUD operations for the **Year** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Years
   * const years = await prisma.year.findMany()
   * ```
   */
  get year(): Prisma.YearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patents`: Exposes CRUD operations for the **Patents** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Patents
   * const patents = await prisma.patents.findMany()
   * ```
   */
  get patents(): Prisma.PatentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Publications
   * const publications = await prisma.publication.findMany()
   * ```
   */
  get publication(): Prisma.PublicationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Account: "Account";
    Session: "Session";
    Student: "Student";
    Core: "Core";
    Faculty: "Faculty";
    Event: "Event";
    Links: "Links";
    Team: "Team";
    Winners: "Winners";
    Placement: "Placement";
    Company: "Company";
    Offer: "Offer";
    Year: "Year";
    Patents: "Patents";
    Publication: "Publication";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "account"
        | "session"
        | "student"
        | "core"
        | "faculty"
        | "event"
        | "links"
        | "team"
        | "winners"
        | "placement"
        | "company"
        | "offer"
        | "year"
        | "patents"
        | "publication";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>;
        fields: Prisma.StudentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[];
          };
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[];
          };
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[];
          };
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>;
          };
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStudent>;
          };
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StudentGroupByOutputType>[];
          };
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>;
            result: $Utils.Optional<StudentCountAggregateOutputType> | number;
          };
        };
      };
      Core: {
        payload: Prisma.$CorePayload<ExtArgs>;
        fields: Prisma.CoreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CoreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CoreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          findFirst: {
            args: Prisma.CoreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CoreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          findMany: {
            args: Prisma.CoreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>[];
          };
          create: {
            args: Prisma.CoreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          createMany: {
            args: Prisma.CoreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CoreCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>[];
          };
          delete: {
            args: Prisma.CoreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          update: {
            args: Prisma.CoreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          deleteMany: {
            args: Prisma.CoreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CoreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CoreUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>[];
          };
          upsert: {
            args: Prisma.CoreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CorePayload>;
          };
          aggregate: {
            args: Prisma.CoreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCore>;
          };
          groupBy: {
            args: Prisma.CoreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CoreGroupByOutputType>[];
          };
          count: {
            args: Prisma.CoreCountArgs<ExtArgs>;
            result: $Utils.Optional<CoreCountAggregateOutputType> | number;
          };
        };
      };
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>;
        fields: Prisma.FacultyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
          };
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FacultyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
          };
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FacultyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
          };
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
          };
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFaculty>;
          };
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FacultyGroupByOutputType>[];
          };
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>;
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number;
          };
        };
      };
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>;
        fields: Prisma.EventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[];
          };
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[];
          };
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[];
          };
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEvent>;
          };
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventGroupByOutputType>[];
          };
          count: {
            args: Prisma.EventCountArgs<ExtArgs>;
            result: $Utils.Optional<EventCountAggregateOutputType> | number;
          };
        };
      };
      Links: {
        payload: Prisma.$LinksPayload<ExtArgs>;
        fields: Prisma.LinksFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LinksFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LinksFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          findFirst: {
            args: Prisma.LinksFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LinksFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          findMany: {
            args: Prisma.LinksFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>[];
          };
          create: {
            args: Prisma.LinksCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          createMany: {
            args: Prisma.LinksCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LinksCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>[];
          };
          delete: {
            args: Prisma.LinksDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          update: {
            args: Prisma.LinksUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          deleteMany: {
            args: Prisma.LinksDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LinksUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LinksUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>[];
          };
          upsert: {
            args: Prisma.LinksUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LinksPayload>;
          };
          aggregate: {
            args: Prisma.LinksAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLinks>;
          };
          groupBy: {
            args: Prisma.LinksGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LinksGroupByOutputType>[];
          };
          count: {
            args: Prisma.LinksCountArgs<ExtArgs>;
            result: $Utils.Optional<LinksCountAggregateOutputType> | number;
          };
        };
      };
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>;
        fields: Prisma.TeamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeam>;
          };
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>;
            result: $Utils.Optional<TeamCountAggregateOutputType> | number;
          };
        };
      };
      Winners: {
        payload: Prisma.$WinnersPayload<ExtArgs>;
        fields: Prisma.WinnersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WinnersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WinnersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          findFirst: {
            args: Prisma.WinnersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WinnersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          findMany: {
            args: Prisma.WinnersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>[];
          };
          create: {
            args: Prisma.WinnersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          createMany: {
            args: Prisma.WinnersCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WinnersCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>[];
          };
          delete: {
            args: Prisma.WinnersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          update: {
            args: Prisma.WinnersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          deleteMany: {
            args: Prisma.WinnersDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WinnersUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WinnersUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>[];
          };
          upsert: {
            args: Prisma.WinnersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WinnersPayload>;
          };
          aggregate: {
            args: Prisma.WinnersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWinners>;
          };
          groupBy: {
            args: Prisma.WinnersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WinnersGroupByOutputType>[];
          };
          count: {
            args: Prisma.WinnersCountArgs<ExtArgs>;
            result: $Utils.Optional<WinnersCountAggregateOutputType> | number;
          };
        };
      };
      Placement: {
        payload: Prisma.$PlacementPayload<ExtArgs>;
        fields: Prisma.PlacementFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PlacementFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PlacementFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          findFirst: {
            args: Prisma.PlacementFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PlacementFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          findMany: {
            args: Prisma.PlacementFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[];
          };
          create: {
            args: Prisma.PlacementCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          createMany: {
            args: Prisma.PlacementCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PlacementCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[];
          };
          delete: {
            args: Prisma.PlacementDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          update: {
            args: Prisma.PlacementUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          deleteMany: {
            args: Prisma.PlacementDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PlacementUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PlacementUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[];
          };
          upsert: {
            args: Prisma.PlacementUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>;
          };
          aggregate: {
            args: Prisma.PlacementAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePlacement>;
          };
          groupBy: {
            args: Prisma.PlacementGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PlacementGroupByOutputType>[];
          };
          count: {
            args: Prisma.PlacementCountArgs<ExtArgs>;
            result: $Utils.Optional<PlacementCountAggregateOutputType> | number;
          };
        };
      };
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>;
        fields: Prisma.CompanyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
          };
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
          };
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCompany>;
          };
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CompanyGroupByOutputType>[];
          };
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>;
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number;
          };
        };
      };
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>;
        fields: Prisma.OfferFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[];
          };
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[];
          };
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[];
          };
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>;
          };
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOffer>;
          };
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OfferGroupByOutputType>[];
          };
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>;
            result: $Utils.Optional<OfferCountAggregateOutputType> | number;
          };
        };
      };
      Year: {
        payload: Prisma.$YearPayload<ExtArgs>;
        fields: Prisma.YearFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.YearFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.YearFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          findFirst: {
            args: Prisma.YearFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.YearFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          findMany: {
            args: Prisma.YearFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>[];
          };
          create: {
            args: Prisma.YearCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          createMany: {
            args: Prisma.YearCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.YearCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>[];
          };
          delete: {
            args: Prisma.YearDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          update: {
            args: Prisma.YearUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          deleteMany: {
            args: Prisma.YearDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.YearUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.YearUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>[];
          };
          upsert: {
            args: Prisma.YearUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$YearPayload>;
          };
          aggregate: {
            args: Prisma.YearAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateYear>;
          };
          groupBy: {
            args: Prisma.YearGroupByArgs<ExtArgs>;
            result: $Utils.Optional<YearGroupByOutputType>[];
          };
          count: {
            args: Prisma.YearCountArgs<ExtArgs>;
            result: $Utils.Optional<YearCountAggregateOutputType> | number;
          };
        };
      };
      Patents: {
        payload: Prisma.$PatentsPayload<ExtArgs>;
        fields: Prisma.PatentsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PatentsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PatentsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          findFirst: {
            args: Prisma.PatentsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PatentsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          findMany: {
            args: Prisma.PatentsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[];
          };
          create: {
            args: Prisma.PatentsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          createMany: {
            args: Prisma.PatentsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PatentsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[];
          };
          delete: {
            args: Prisma.PatentsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          update: {
            args: Prisma.PatentsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          deleteMany: {
            args: Prisma.PatentsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PatentsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PatentsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>[];
          };
          upsert: {
            args: Prisma.PatentsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PatentsPayload>;
          };
          aggregate: {
            args: Prisma.PatentsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePatents>;
          };
          groupBy: {
            args: Prisma.PatentsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PatentsGroupByOutputType>[];
          };
          count: {
            args: Prisma.PatentsCountArgs<ExtArgs>;
            result: $Utils.Optional<PatentsCountAggregateOutputType> | number;
          };
        };
      };
      Publication: {
        payload: Prisma.$PublicationPayload<ExtArgs>;
        fields: Prisma.PublicationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PublicationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PublicationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          findFirst: {
            args: Prisma.PublicationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PublicationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          findMany: {
            args: Prisma.PublicationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[];
          };
          create: {
            args: Prisma.PublicationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          createMany: {
            args: Prisma.PublicationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PublicationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[];
          };
          delete: {
            args: Prisma.PublicationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          update: {
            args: Prisma.PublicationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          deleteMany: {
            args: Prisma.PublicationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PublicationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PublicationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[];
          };
          upsert: {
            args: Prisma.PublicationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>;
          };
          aggregate: {
            args: Prisma.PublicationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePublication>;
          };
          groupBy: {
            args: Prisma.PublicationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PublicationGroupByOutputType>[];
          };
          count: {
            args: Prisma.PublicationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PublicationCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    account?: AccountOmit;
    session?: SessionOmit;
    student?: StudentOmit;
    core?: CoreOmit;
    faculty?: FacultyOmit;
    event?: EventOmit;
    links?: LinksOmit;
    team?: TeamOmit;
    winners?: WinnersOmit;
    placement?: PlacementOmit;
    company?: CompanyOmit;
    offer?: OfferOmit;
    year?: YearOmit;
    patents?: PatentsOmit;
    publication?: PublicationOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T["level"] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number;
    Core: number;
    sessions: number;
    organizers: number;
    Team: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    Core?: boolean | UserCountOutputTypeCountCoreArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    organizers?: boolean | UserCountOutputTypeCountOrganizersArgs;
    Team?: boolean | UserCountOutputTypeCountTeamArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoreArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CoreWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
  };

  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    patents: number;
  };

  export type StudentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    patents?: boolean | StudentCountOutputTypeCountPatentsArgs;
  };

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPatentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PatentsWhereInput;
  };

  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    patents: number;
    publications: number;
  };

  export type FacultyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    patents?: boolean | FacultyCountOutputTypeCountPatentsArgs;
    publications?: boolean | FacultyCountOutputTypeCountPublicationsArgs;
  };

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountPatentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PatentsWhereInput;
  };

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountPublicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PublicationWhereInput;
  };

  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    participants: number;
    winners: number;
    organizers: number;
  };

  export type EventCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    participants?: boolean | EventCountOutputTypeCountParticipantsArgs;
    winners?: boolean | EventCountOutputTypeCountWinnersArgs;
    organizers?: boolean | EventCountOutputTypeCountOrganizersArgs;
  };

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountParticipantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountWinnersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WinnersWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountOrganizersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    user: number;
  };

  export type TeamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | TeamCountOutputTypeCountUserArgs;
  };

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * Count Type PlacementCountOutputType
   */

  export type PlacementCountOutputType = {
    offers: number;
  };

  export type PlacementCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    offers?: boolean | PlacementCountOutputTypeCountOffersArgs;
  };

  // Custom InputTypes
  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PlacementCountOutputType
     */
    select?: PlacementCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeCountOffersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OfferWhereInput;
  };

  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    offers: number;
  };

  export type CompanyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    offers?: boolean | CompanyCountOutputTypeCountOffersArgs;
  };

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOffersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OfferWhereInput;
  };

  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    placements: number;
  };

  export type OfferCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    placements?: boolean | OfferCountOutputTypeCountPlacementsArgs;
  };

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountPlacementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PlacementWhereInput;
  };

  /**
   * Count Type YearCountOutputType
   */

  export type YearCountOutputType = {
    placements: number;
  };

  export type YearCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    placements?: boolean | YearCountOutputTypeCountPlacementsArgs;
  };

  // Custom InputTypes
  /**
   * YearCountOutputType without action
   */
  export type YearCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the YearCountOutputType
     */
    select?: YearCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * YearCountOutputType without action
   */
  export type YearCountOutputTypeCountPlacementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PlacementWhereInput;
  };

  /**
   * Count Type PatentsCountOutputType
   */

  export type PatentsCountOutputType = {
    faculty: number;
    student: number;
  };

  export type PatentsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    faculty?: boolean | PatentsCountOutputTypeCountFacultyArgs;
    student?: boolean | PatentsCountOutputTypeCountStudentArgs;
  };

  // Custom InputTypes
  /**
   * PatentsCountOutputType without action
   */
  export type PatentsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PatentsCountOutputType
     */
    select?: PatentsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PatentsCountOutputType without action
   */
  export type PatentsCountOutputTypeCountFacultyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacultyWhereInput;
  };

  /**
   * PatentsCountOutputType without action
   */
  export type PatentsCountOutputTypeCountStudentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StudentWhereInput;
  };

  /**
   * Count Type PublicationCountOutputType
   */

  export type PublicationCountOutputType = {
    faculty: number;
  };

  export type PublicationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    faculty?: boolean | PublicationCountOutputTypeCountFacultyArgs;
  };

  // Custom InputTypes
  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PublicationCountOutputType
     */
    select?: PublicationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountFacultyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacultyWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    bio: string | null;
    phone: string | null;
    username: string | null;
    usn: string | null;
    lightTheme: string | null;
    darkTheme: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    displayName: string | null;
    college: string | null;
    role: $Enums.Role | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    bio: string | null;
    phone: string | null;
    username: string | null;
    usn: string | null;
    lightTheme: string | null;
    darkTheme: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    displayName: string | null;
    college: string | null;
    role: $Enums.Role | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    bio: number;
    phone: number;
    username: number;
    usn: number;
    lightTheme: number;
    darkTheme: number;
    createdAt: number;
    updatedAt: number;
    displayName: number;
    college: number;
    role: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    bio?: true;
    phone?: true;
    username?: true;
    usn?: true;
    lightTheme?: true;
    darkTheme?: true;
    createdAt?: true;
    updatedAt?: true;
    displayName?: true;
    college?: true;
    role?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    bio?: true;
    phone?: true;
    username?: true;
    usn?: true;
    lightTheme?: true;
    darkTheme?: true;
    createdAt?: true;
    updatedAt?: true;
    displayName?: true;
    college?: true;
    role?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    bio?: true;
    phone?: true;
    username?: true;
    usn?: true;
    lightTheme?: true;
    darkTheme?: true;
    createdAt?: true;
    updatedAt?: true;
    displayName?: true;
    college?: true;
    role?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string;
    emailVerified: Date | null;
    image: string | null;
    bio: string | null;
    phone: string | null;
    username: string | null;
    usn: string | null;
    lightTheme: string | null;
    darkTheme: string | null;
    createdAt: Date;
    updatedAt: Date;
    displayName: string | null;
    college: string | null;
    role: $Enums.Role;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      bio?: boolean;
      phone?: boolean;
      username?: boolean;
      usn?: boolean;
      lightTheme?: boolean;
      darkTheme?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      displayName?: boolean;
      college?: boolean;
      role?: boolean;
      accounts?: boolean | User$accountsArgs<ExtArgs>;
      Core?: boolean | User$CoreArgs<ExtArgs>;
      links?: boolean | User$linksArgs<ExtArgs>;
      sessions?: boolean | User$sessionsArgs<ExtArgs>;
      Student?: boolean | User$StudentArgs<ExtArgs>;
      organizers?: boolean | User$organizersArgs<ExtArgs>;
      Team?: boolean | User$TeamArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      bio?: boolean;
      phone?: boolean;
      username?: boolean;
      usn?: boolean;
      lightTheme?: boolean;
      darkTheme?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      displayName?: boolean;
      college?: boolean;
      role?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      bio?: boolean;
      phone?: boolean;
      username?: boolean;
      usn?: boolean;
      lightTheme?: boolean;
      darkTheme?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      displayName?: boolean;
      college?: boolean;
      role?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    bio?: boolean;
    phone?: boolean;
    username?: boolean;
    usn?: boolean;
    lightTheme?: boolean;
    darkTheme?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    displayName?: boolean;
    college?: boolean;
    role?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "emailVerified"
    | "image"
    | "bio"
    | "phone"
    | "username"
    | "usn"
    | "lightTheme"
    | "darkTheme"
    | "createdAt"
    | "updatedAt"
    | "displayName"
    | "college"
    | "role",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    Core?: boolean | User$CoreArgs<ExtArgs>;
    links?: boolean | User$linksArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    Student?: boolean | User$StudentArgs<ExtArgs>;
    organizers?: boolean | User$organizersArgs<ExtArgs>;
    Team?: boolean | User$TeamArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      Core: Prisma.$CorePayload<ExtArgs>[];
      links: Prisma.$LinksPayload<ExtArgs> | null;
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      Student: Prisma.$StudentPayload<ExtArgs> | null;
      organizers: Prisma.$EventPayload<ExtArgs>[];
      Team: Prisma.$TeamPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string;
        emailVerified: Date | null;
        image: string | null;
        bio: string | null;
        phone: string | null;
        username: string | null;
        usn: string | null;
        lightTheme: string | null;
        darkTheme: string | null;
        createdAt: Date;
        updatedAt: Date;
        displayName: string | null;
        college: string | null;
        role: $Enums.Role;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AccountPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Core<T extends User$CoreArgs<ExtArgs> = {}>(
      args?: Subset<T, User$CoreArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CorePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    links<T extends User$linksArgs<ExtArgs> = {}>(
      args?: Subset<T, User$linksArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Student<T extends User$StudentArgs<ExtArgs> = {}>(
      args?: Subset<T, User$StudentArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organizers<T extends User$organizersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$organizersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Team<T extends User$TeamArgs<ExtArgs> = {}>(
      args?: Subset<T, User$TeamArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly emailVerified: FieldRef<"User", "DateTime">;
    readonly image: FieldRef<"User", "String">;
    readonly bio: FieldRef<"User", "String">;
    readonly phone: FieldRef<"User", "String">;
    readonly username: FieldRef<"User", "String">;
    readonly usn: FieldRef<"User", "String">;
    readonly lightTheme: FieldRef<"User", "String">;
    readonly darkTheme: FieldRef<"User", "String">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly displayName: FieldRef<"User", "String">;
    readonly college: FieldRef<"User", "String">;
    readonly role: FieldRef<"User", "Role">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.Core
   */
  export type User$CoreArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    where?: CoreWhereInput;
    orderBy?: CoreOrderByWithRelationInput | CoreOrderByWithRelationInput[];
    cursor?: CoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CoreScalarFieldEnum | CoreScalarFieldEnum[];
  };

  /**
   * User.links
   */
  export type User$linksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    where?: LinksWhereInput;
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.Student
   */
  export type User$StudentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    where?: StudentWhereInput;
  };

  /**
   * User.organizers
   */
  export type User$organizersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    where?: EventWhereInput;
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    cursor?: EventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * User.Team
   */
  export type User$TeamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    cursor?: TeamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AccountMaxAggregateOutputType = {
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AccountCountAggregateOutputType = {
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AccountMaxAggregateInputType = {
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AccountCountAggregateInputType = {
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithAggregationInput
      | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AccountGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AccountGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>;
        }
      >
    >;

  export type AccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectScalar = {
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "userId"
    | "type"
    | "provider"
    | "providerAccountId"
    | "refresh_token"
    | "access_token"
    | "expires_at"
    | "token_type"
    | "scope"
    | "id_token"
    | "session_state"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["account"]
  >;
  export type AccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Account";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        type: string;
        provider: string;
        providerAccountId: string;
        refresh_token: string | null;
        access_token: string | null;
        expires_at: number | null;
        token_type: string | null;
        scope: string | null;
        id_token: string | null;
        session_state: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["account"]
    >;
    composites: {};
  };

  type AccountGetPayload<
    S extends boolean | null | undefined | AccountDefaultArgs,
  > = $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AccountFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Account"];
      meta: { name: "Account" };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>,
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs["orderBy"] }
        : { orderBy?: AccountGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", "String">;
    readonly type: FieldRef<"Account", "String">;
    readonly provider: FieldRef<"Account", "String">;
    readonly providerAccountId: FieldRef<"Account", "String">;
    readonly refresh_token: FieldRef<"Account", "String">;
    readonly access_token: FieldRef<"Account", "String">;
    readonly expires_at: FieldRef<"Account", "Int">;
    readonly token_type: FieldRef<"Account", "String">;
    readonly scope: FieldRef<"Account", "String">;
    readonly id_token: FieldRef<"Account", "String">;
    readonly session_state: FieldRef<"Account", "String">;
    readonly createdAt: FieldRef<"Account", "DateTime">;
    readonly updatedAt: FieldRef<"Account", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    sessionToken: number;
    userId: number;
    expires: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    sessionToken?: true;
    userId?: true;
    expires?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SessionMaxAggregateInputType = {
    sessionToken?: true;
    userId?: true;
    expires?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SessionCountAggregateInputType = {
    sessionToken?: true;
    userId?: true;
    expires?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    sessionToken: string;
    userId: string;
    expires: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        sessionToken: string;
        userId: string;
        expires: Date;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.findMany({ select: { sessionToken: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionToken: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionToken: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly sessionToken: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
    readonly expires: FieldRef<"Session", "DateTime">;
    readonly createdAt: FieldRef<"Session", "DateTime">;
    readonly updatedAt: FieldRef<"Session", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null;
    _min: StudentMinAggregateOutputType | null;
    _max: StudentMaxAggregateOutputType | null;
  };

  export type StudentMinAggregateOutputType = {
    id: string | null;
    image: string | null;
    userId: string | null;
  };

  export type StudentMaxAggregateOutputType = {
    id: string | null;
    image: string | null;
    userId: string | null;
  };

  export type StudentCountAggregateOutputType = {
    id: number;
    image: number;
    userId: number;
    _all: number;
  };

  export type StudentMinAggregateInputType = {
    id?: true;
    image?: true;
    userId?: true;
  };

  export type StudentMaxAggregateInputType = {
    id?: true;
    image?: true;
    userId?: true;
  };

  export type StudentCountAggregateInputType = {
    id?: true;
    image?: true;
    userId?: true;
    _all?: true;
  };

  export type StudentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Students to fetch.
     */
    orderBy?:
      | StudentOrderByWithRelationInput
      | StudentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Students from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Students.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Students
     **/
    _count?: true | StudentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StudentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StudentMaxAggregateInputType;
  };

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
    [P in keyof T & keyof AggregateStudent]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>;
  };

  export type StudentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StudentWhereInput;
    orderBy?:
      | StudentOrderByWithAggregationInput
      | StudentOrderByWithAggregationInput[];
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum;
    having?: StudentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StudentCountAggregateInputType | true;
    _min?: StudentMinAggregateInputType;
    _max?: StudentMaxAggregateInputType;
  };

  export type StudentGroupByOutputType = {
    id: string;
    image: string;
    userId: string;
    _count: StudentCountAggregateOutputType | null;
    _min: StudentMinAggregateOutputType | null;
    _max: StudentMaxAggregateOutputType | null;
  };

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StudentGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof StudentGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>;
        }
      >
    >;

  export type StudentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      image?: boolean;
      userId?: boolean;
      placement?: boolean | Student$placementArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      patents?: boolean | Student$patentsArgs<ExtArgs>;
      _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["student"]
  >;

  export type StudentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      image?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["student"]
  >;

  export type StudentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      image?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["student"]
  >;

  export type StudentSelectScalar = {
    id?: boolean;
    image?: boolean;
    userId?: boolean;
  };

  export type StudentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "image" | "userId",
    ExtArgs["result"]["student"]
  >;
  export type StudentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    placement?: boolean | Student$placementArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    patents?: boolean | Student$patentsArgs<ExtArgs>;
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type StudentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type StudentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $StudentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Student";
    objects: {
      placement: Prisma.$PlacementPayload<ExtArgs> | null;
      user: Prisma.$UserPayload<ExtArgs>;
      patents: Prisma.$PatentsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        image: string;
        userId: string;
      },
      ExtArgs["result"]["student"]
    >;
    composites: {};
  };

  type StudentGetPayload<
    S extends boolean | null | undefined | StudentDefaultArgs,
  > = $Result.GetResult<Prisma.$StudentPayload, S>;

  type StudentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<StudentFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: StudentCountAggregateInputType | true;
  };

  export interface StudentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Student"];
      meta: { name: "Student" };
    };
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(
      args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(
      args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     *
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     *
     */
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StudentCreateManyArgs>(
      args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     *
     */
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      $Result.GetResult<
        Prisma.$StudentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
     **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StudentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StudentAggregateArgs>(
      args: Subset<T, StudentAggregateArgs>,
    ): Prisma.PrismaPromise<GetStudentAggregateType<T>>;

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs["orderBy"] }
        : { orderBy?: StudentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetStudentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Student model
     */
    readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    placement<T extends Student$placementArgs<ExtArgs> = {}>(
      args?: Subset<T, Student$placementArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    patents<T extends Student$patentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Student$patentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PatentsPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", "String">;
    readonly image: FieldRef<"Student", "String">;
    readonly userId: FieldRef<"Student", "String">;
  }

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput;
  };

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput;
  };

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Students to fetch.
     */
    orderBy?:
      | StudentOrderByWithRelationInput
      | StudentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Students from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Students.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[];
  };

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Students to fetch.
     */
    orderBy?:
      | StudentOrderByWithRelationInput
      | StudentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Students from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Students.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[];
  };

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Students to fetch.
     */
    orderBy?:
      | StudentOrderByWithRelationInput
      | StudentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Students from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Students.
     */
    skip?: number;
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[];
  };

  /**
   * Student create
   */
  export type StudentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>;
  };

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Student update
   */
  export type StudentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>;
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput;
  };

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>;
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput;
    /**
     * Limit how many Students to update.
     */
    limit?: number;
  };

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>;
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput;
    /**
     * Limit how many Students to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput;
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>;
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>;
  };

  /**
   * Student delete
   */
  export type StudentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput;
  };

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput;
    /**
     * Limit how many Students to delete.
     */
    limit?: number;
  };

  /**
   * Student.placement
   */
  export type Student$placementArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    where?: PlacementWhereInput;
  };

  /**
   * Student.patents
   */
  export type Student$patentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    where?: PatentsWhereInput;
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    cursor?: PatentsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[];
  };

  /**
   * Student without action
   */
  export type StudentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
  };

  /**
   * Model Core
   */

  export type AggregateCore = {
    _count: CoreCountAggregateOutputType | null;
    _avg: CoreAvgAggregateOutputType | null;
    _sum: CoreSumAggregateOutputType | null;
    _min: CoreMinAggregateOutputType | null;
    _max: CoreMaxAggregateOutputType | null;
  };

  export type CoreAvgAggregateOutputType = {
    order: number | null;
  };

  export type CoreSumAggregateOutputType = {
    order: number | null;
  };

  export type CoreMinAggregateOutputType = {
    id: string | null;
    year: string | null;
    userId: string | null;
    image: string | null;
    order: number | null;
    post: string | null;
    quote: string | null;
  };

  export type CoreMaxAggregateOutputType = {
    id: string | null;
    year: string | null;
    userId: string | null;
    image: string | null;
    order: number | null;
    post: string | null;
    quote: string | null;
  };

  export type CoreCountAggregateOutputType = {
    id: number;
    year: number;
    userId: number;
    image: number;
    order: number;
    post: number;
    quote: number;
    _all: number;
  };

  export type CoreAvgAggregateInputType = {
    order?: true;
  };

  export type CoreSumAggregateInputType = {
    order?: true;
  };

  export type CoreMinAggregateInputType = {
    id?: true;
    year?: true;
    userId?: true;
    image?: true;
    order?: true;
    post?: true;
    quote?: true;
  };

  export type CoreMaxAggregateInputType = {
    id?: true;
    year?: true;
    userId?: true;
    image?: true;
    order?: true;
    post?: true;
    quote?: true;
  };

  export type CoreCountAggregateInputType = {
    id?: true;
    year?: true;
    userId?: true;
    image?: true;
    order?: true;
    post?: true;
    quote?: true;
    _all?: true;
  };

  export type CoreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Core to aggregate.
     */
    where?: CoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cores to fetch.
     */
    orderBy?: CoreOrderByWithRelationInput | CoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Cores
     **/
    _count?: true | CoreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CoreAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CoreSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CoreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CoreMaxAggregateInputType;
  };

  export type GetCoreAggregateType<T extends CoreAggregateArgs> = {
    [P in keyof T & keyof AggregateCore]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCore[P]>
      : GetScalarType<T[P], AggregateCore[P]>;
  };

  export type CoreGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CoreWhereInput;
    orderBy?:
      | CoreOrderByWithAggregationInput
      | CoreOrderByWithAggregationInput[];
    by: CoreScalarFieldEnum[] | CoreScalarFieldEnum;
    having?: CoreScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CoreCountAggregateInputType | true;
    _avg?: CoreAvgAggregateInputType;
    _sum?: CoreSumAggregateInputType;
    _min?: CoreMinAggregateInputType;
    _max?: CoreMaxAggregateInputType;
  };

  export type CoreGroupByOutputType = {
    id: string;
    year: string;
    userId: string;
    image: string;
    order: number;
    post: string;
    quote: string | null;
    _count: CoreCountAggregateOutputType | null;
    _avg: CoreAvgAggregateOutputType | null;
    _sum: CoreSumAggregateOutputType | null;
    _min: CoreMinAggregateOutputType | null;
    _max: CoreMaxAggregateOutputType | null;
  };

  type GetCoreGroupByPayload<T extends CoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoreGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof CoreGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CoreGroupByOutputType[P]>
          : GetScalarType<T[P], CoreGroupByOutputType[P]>;
      }
    >
  >;

  export type CoreSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      userId?: boolean;
      image?: boolean;
      order?: boolean;
      post?: boolean;
      quote?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["core"]
  >;

  export type CoreSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      userId?: boolean;
      image?: boolean;
      order?: boolean;
      post?: boolean;
      quote?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["core"]
  >;

  export type CoreSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      userId?: boolean;
      image?: boolean;
      order?: boolean;
      post?: boolean;
      quote?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["core"]
  >;

  export type CoreSelectScalar = {
    id?: boolean;
    year?: boolean;
    userId?: boolean;
    image?: boolean;
    order?: boolean;
    post?: boolean;
    quote?: boolean;
  };

  export type CoreOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "year" | "userId" | "image" | "order" | "post" | "quote",
    ExtArgs["result"]["core"]
  >;
  export type CoreInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type CoreIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type CoreIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CorePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Core";
    objects: {
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        year: string;
        userId: string;
        image: string;
        order: number;
        post: string;
        quote: string | null;
      },
      ExtArgs["result"]["core"]
    >;
    composites: {};
  };

  type CoreGetPayload<S extends boolean | null | undefined | CoreDefaultArgs> =
    $Result.GetResult<Prisma.$CorePayload, S>;

  type CoreCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CoreFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CoreCountAggregateInputType | true;
  };

  export interface CoreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Core"];
      meta: { name: "Core" };
    };
    /**
     * Find zero or one Core that matches the filter.
     * @param {CoreFindUniqueArgs} args - Arguments to find a Core
     * @example
     * // Get one Core
     * const core = await prisma.core.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoreFindUniqueArgs>(
      args: SelectSubset<T, CoreFindUniqueArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Core that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoreFindUniqueOrThrowArgs} args - Arguments to find a Core
     * @example
     * // Get one Core
     * const core = await prisma.core.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CoreFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Core that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreFindFirstArgs} args - Arguments to find a Core
     * @example
     * // Get one Core
     * const core = await prisma.core.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoreFindFirstArgs>(
      args?: SelectSubset<T, CoreFindFirstArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Core that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreFindFirstOrThrowArgs} args - Arguments to find a Core
     * @example
     * // Get one Core
     * const core = await prisma.core.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CoreFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Cores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cores
     * const cores = await prisma.core.findMany()
     *
     * // Get first 10 Cores
     * const cores = await prisma.core.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const coreWithIdOnly = await prisma.core.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CoreFindManyArgs>(
      args?: SelectSubset<T, CoreFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Core.
     * @param {CoreCreateArgs} args - Arguments to create a Core.
     * @example
     * // Create one Core
     * const Core = await prisma.core.create({
     *   data: {
     *     // ... data to create a Core
     *   }
     * })
     *
     */
    create<T extends CoreCreateArgs>(
      args: SelectSubset<T, CoreCreateArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Cores.
     * @param {CoreCreateManyArgs} args - Arguments to create many Cores.
     * @example
     * // Create many Cores
     * const core = await prisma.core.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CoreCreateManyArgs>(
      args?: SelectSubset<T, CoreCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Cores and returns the data saved in the database.
     * @param {CoreCreateManyAndReturnArgs} args - Arguments to create many Cores.
     * @example
     * // Create many Cores
     * const core = await prisma.core.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Cores and only return the `id`
     * const coreWithIdOnly = await prisma.core.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CoreCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CoreCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Core.
     * @param {CoreDeleteArgs} args - Arguments to delete one Core.
     * @example
     * // Delete one Core
     * const Core = await prisma.core.delete({
     *   where: {
     *     // ... filter to delete one Core
     *   }
     * })
     *
     */
    delete<T extends CoreDeleteArgs>(
      args: SelectSubset<T, CoreDeleteArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Core.
     * @param {CoreUpdateArgs} args - Arguments to update one Core.
     * @example
     * // Update one Core
     * const core = await prisma.core.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CoreUpdateArgs>(
      args: SelectSubset<T, CoreUpdateArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Cores.
     * @param {CoreDeleteManyArgs} args - Arguments to filter Cores to delete.
     * @example
     * // Delete a few Cores
     * const { count } = await prisma.core.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CoreDeleteManyArgs>(
      args?: SelectSubset<T, CoreDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cores
     * const core = await prisma.core.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CoreUpdateManyArgs>(
      args: SelectSubset<T, CoreUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Cores and returns the data updated in the database.
     * @param {CoreUpdateManyAndReturnArgs} args - Arguments to update many Cores.
     * @example
     * // Update many Cores
     * const core = await prisma.core.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Cores and only return the `id`
     * const coreWithIdOnly = await prisma.core.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CoreUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CoreUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Core.
     * @param {CoreUpsertArgs} args - Arguments to update or create a Core.
     * @example
     * // Update or create a Core
     * const core = await prisma.core.upsert({
     *   create: {
     *     // ... data to create a Core
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Core we want to update
     *   }
     * })
     */
    upsert<T extends CoreUpsertArgs>(
      args: SelectSubset<T, CoreUpsertArgs<ExtArgs>>,
    ): Prisma__CoreClient<
      $Result.GetResult<
        Prisma.$CorePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreCountArgs} args - Arguments to filter Cores to count.
     * @example
     * // Count the number of Cores
     * const count = await prisma.core.count({
     *   where: {
     *     // ... the filter for the Cores we want to count
     *   }
     * })
     **/
    count<T extends CoreCountArgs>(
      args?: Subset<T, CoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CoreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Core.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CoreAggregateArgs>(
      args: Subset<T, CoreAggregateArgs>,
    ): Prisma.PrismaPromise<GetCoreAggregateType<T>>;

    /**
     * Group by Core.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoreGroupByArgs["orderBy"] }
        : { orderBy?: CoreGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CoreGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCoreGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Core model
     */
    readonly fields: CoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Core.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Core model
   */
  interface CoreFieldRefs {
    readonly id: FieldRef<"Core", "String">;
    readonly year: FieldRef<"Core", "String">;
    readonly userId: FieldRef<"Core", "String">;
    readonly image: FieldRef<"Core", "String">;
    readonly order: FieldRef<"Core", "Int">;
    readonly post: FieldRef<"Core", "String">;
    readonly quote: FieldRef<"Core", "String">;
  }

  // Custom InputTypes
  /**
   * Core findUnique
   */
  export type CoreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter, which Core to fetch.
     */
    where: CoreWhereUniqueInput;
  };

  /**
   * Core findUniqueOrThrow
   */
  export type CoreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter, which Core to fetch.
     */
    where: CoreWhereUniqueInput;
  };

  /**
   * Core findFirst
   */
  export type CoreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter, which Core to fetch.
     */
    where?: CoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cores to fetch.
     */
    orderBy?: CoreOrderByWithRelationInput | CoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Cores.
     */
    cursor?: CoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Cores.
     */
    distinct?: CoreScalarFieldEnum | CoreScalarFieldEnum[];
  };

  /**
   * Core findFirstOrThrow
   */
  export type CoreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter, which Core to fetch.
     */
    where?: CoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cores to fetch.
     */
    orderBy?: CoreOrderByWithRelationInput | CoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Cores.
     */
    cursor?: CoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Cores.
     */
    distinct?: CoreScalarFieldEnum | CoreScalarFieldEnum[];
  };

  /**
   * Core findMany
   */
  export type CoreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter, which Cores to fetch.
     */
    where?: CoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cores to fetch.
     */
    orderBy?: CoreOrderByWithRelationInput | CoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Cores.
     */
    cursor?: CoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cores.
     */
    skip?: number;
    distinct?: CoreScalarFieldEnum | CoreScalarFieldEnum[];
  };

  /**
   * Core create
   */
  export type CoreCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * The data needed to create a Core.
     */
    data: XOR<CoreCreateInput, CoreUncheckedCreateInput>;
  };

  /**
   * Core createMany
   */
  export type CoreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Cores.
     */
    data: CoreCreateManyInput | CoreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Core createManyAndReturn
   */
  export type CoreCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * The data used to create many Cores.
     */
    data: CoreCreateManyInput | CoreCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Core update
   */
  export type CoreUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * The data needed to update a Core.
     */
    data: XOR<CoreUpdateInput, CoreUncheckedUpdateInput>;
    /**
     * Choose, which Core to update.
     */
    where: CoreWhereUniqueInput;
  };

  /**
   * Core updateMany
   */
  export type CoreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Cores.
     */
    data: XOR<CoreUpdateManyMutationInput, CoreUncheckedUpdateManyInput>;
    /**
     * Filter which Cores to update
     */
    where?: CoreWhereInput;
    /**
     * Limit how many Cores to update.
     */
    limit?: number;
  };

  /**
   * Core updateManyAndReturn
   */
  export type CoreUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * The data used to update Cores.
     */
    data: XOR<CoreUpdateManyMutationInput, CoreUncheckedUpdateManyInput>;
    /**
     * Filter which Cores to update
     */
    where?: CoreWhereInput;
    /**
     * Limit how many Cores to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Core upsert
   */
  export type CoreUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * The filter to search for the Core to update in case it exists.
     */
    where: CoreWhereUniqueInput;
    /**
     * In case the Core found by the `where` argument doesn't exist, create a new Core with this data.
     */
    create: XOR<CoreCreateInput, CoreUncheckedCreateInput>;
    /**
     * In case the Core was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoreUpdateInput, CoreUncheckedUpdateInput>;
  };

  /**
   * Core delete
   */
  export type CoreDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
    /**
     * Filter which Core to delete.
     */
    where: CoreWhereUniqueInput;
  };

  /**
   * Core deleteMany
   */
  export type CoreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Cores to delete
     */
    where?: CoreWhereInput;
    /**
     * Limit how many Cores to delete.
     */
    limit?: number;
  };

  /**
   * Core without action
   */
  export type CoreDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Core
     */
    select?: CoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Core
     */
    omit?: CoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoreInclude<ExtArgs> | null;
  };

  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null;
    _avg: FacultyAvgAggregateOutputType | null;
    _sum: FacultySumAggregateOutputType | null;
    _min: FacultyMinAggregateOutputType | null;
    _max: FacultyMaxAggregateOutputType | null;
  };

  export type FacultyAvgAggregateOutputType = {
    order: number | null;
  };

  export type FacultySumAggregateOutputType = {
    order: number | null;
  };

  export type FacultyMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    designation: string | null;
    image: string | null;
    order: number | null;
    published: boolean | null;
    designation2: string | null;
  };

  export type FacultyMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    designation: string | null;
    image: string | null;
    order: number | null;
    published: boolean | null;
    designation2: string | null;
  };

  export type FacultyCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    designation: number;
    image: number;
    about: number;
    order: number;
    published: number;
    designation2: number;
    _all: number;
  };

  export type FacultyAvgAggregateInputType = {
    order?: true;
  };

  export type FacultySumAggregateInputType = {
    order?: true;
  };

  export type FacultyMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    designation?: true;
    image?: true;
    order?: true;
    published?: true;
    designation2?: true;
  };

  export type FacultyMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    designation?: true;
    image?: true;
    order?: true;
    published?: true;
    designation2?: true;
  };

  export type FacultyCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    designation?: true;
    image?: true;
    about?: true;
    order?: true;
    published?: true;
    designation2?: true;
    _all?: true;
  };

  export type FacultyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Faculties to fetch.
     */
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Faculties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Faculties
     **/
    _count?: true | FacultyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FacultyAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FacultySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FacultyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FacultyMaxAggregateInputType;
  };

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
    [P in keyof T & keyof AggregateFaculty]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>;
  };

  export type FacultyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacultyWhereInput;
    orderBy?:
      | FacultyOrderByWithAggregationInput
      | FacultyOrderByWithAggregationInput[];
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum;
    having?: FacultyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FacultyCountAggregateInputType | true;
    _avg?: FacultyAvgAggregateInputType;
    _sum?: FacultySumAggregateInputType;
    _min?: FacultyMinAggregateInputType;
    _max?: FacultyMaxAggregateInputType;
  };

  export type FacultyGroupByOutputType = {
    id: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about: string[];
    order: number;
    published: boolean;
    designation2: string | null;
    _count: FacultyCountAggregateOutputType | null;
    _avg: FacultyAvgAggregateOutputType | null;
    _sum: FacultySumAggregateOutputType | null;
    _min: FacultyMinAggregateOutputType | null;
    _max: FacultyMaxAggregateOutputType | null;
  };

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FacultyGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof FacultyGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>;
        }
      >
    >;

  export type FacultySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      designation?: boolean;
      image?: boolean;
      about?: boolean;
      order?: boolean;
      published?: boolean;
      designation2?: boolean;
      patents?: boolean | Faculty$patentsArgs<ExtArgs>;
      publications?: boolean | Faculty$publicationsArgs<ExtArgs>;
      _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["faculty"]
  >;

  export type FacultySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      designation?: boolean;
      image?: boolean;
      about?: boolean;
      order?: boolean;
      published?: boolean;
      designation2?: boolean;
    },
    ExtArgs["result"]["faculty"]
  >;

  export type FacultySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      designation?: boolean;
      image?: boolean;
      about?: boolean;
      order?: boolean;
      published?: boolean;
      designation2?: boolean;
    },
    ExtArgs["result"]["faculty"]
  >;

  export type FacultySelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    designation?: boolean;
    image?: boolean;
    about?: boolean;
    order?: boolean;
    published?: boolean;
    designation2?: boolean;
  };

  export type FacultyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "designation"
    | "image"
    | "about"
    | "order"
    | "published"
    | "designation2",
    ExtArgs["result"]["faculty"]
  >;
  export type FacultyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    patents?: boolean | Faculty$patentsArgs<ExtArgs>;
    publications?: boolean | Faculty$publicationsArgs<ExtArgs>;
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type FacultyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type FacultyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $FacultyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Faculty";
    objects: {
      patents: Prisma.$PatentsPayload<ExtArgs>[];
      publications: Prisma.$PublicationPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        email: string;
        designation: string;
        image: string;
        about: string[];
        order: number;
        published: boolean;
        designation2: string | null;
      },
      ExtArgs["result"]["faculty"]
    >;
    composites: {};
  };

  type FacultyGetPayload<
    S extends boolean | null | undefined | FacultyDefaultArgs,
  > = $Result.GetResult<Prisma.$FacultyPayload, S>;

  type FacultyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FacultyFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: FacultyCountAggregateInputType | true;
  };

  export interface FacultyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Faculty"];
      meta: { name: "Faculty" };
    };
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(
      args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(
      args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     *
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FacultyFindManyArgs>(
      args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     *
     */
    create<T extends FacultyCreateArgs>(
      args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FacultyCreateManyArgs>(
      args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Faculties and returns the data saved in the database.
     * @param {FacultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FacultyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FacultyCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     *
     */
    delete<T extends FacultyDeleteArgs>(
      args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FacultyUpdateArgs>(
      args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FacultyDeleteManyArgs>(
      args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FacultyUpdateManyArgs>(
      args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faculties and returns the data updated in the database.
     * @param {FacultyUpdateManyAndReturnArgs} args - Arguments to update many Faculties.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FacultyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FacultyUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(
      args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>,
    ): Prisma__FacultyClient<
      $Result.GetResult<
        Prisma.$FacultyPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
     **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FacultyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FacultyAggregateArgs>(
      args: Subset<T, FacultyAggregateArgs>,
    ): Prisma.PrismaPromise<GetFacultyAggregateType<T>>;

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs["orderBy"] }
        : { orderBy?: FacultyGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFacultyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Faculty model
     */
    readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    patents<T extends Faculty$patentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Faculty$patentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PatentsPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    publications<T extends Faculty$publicationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Faculty$publicationsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PublicationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", "String">;
    readonly name: FieldRef<"Faculty", "String">;
    readonly email: FieldRef<"Faculty", "String">;
    readonly designation: FieldRef<"Faculty", "String">;
    readonly image: FieldRef<"Faculty", "String">;
    readonly about: FieldRef<"Faculty", "String[]">;
    readonly order: FieldRef<"Faculty", "Int">;
    readonly published: FieldRef<"Faculty", "Boolean">;
    readonly designation2: FieldRef<"Faculty", "String">;
  }

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput;
  };

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput;
  };

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Faculties to fetch.
     */
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Faculties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
  };

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Faculties to fetch.
     */
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Faculties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
  };

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Faculties to fetch.
     */
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Faculties.
     */
    skip?: number;
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
  };

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>;
  };

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Faculty createManyAndReturn
   */
  export type FacultyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>;
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput;
  };

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>;
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput;
    /**
     * Limit how many Faculties to update.
     */
    limit?: number;
  };

  /**
   * Faculty updateManyAndReturn
   */
  export type FacultyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>;
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput;
    /**
     * Limit how many Faculties to update.
     */
    limit?: number;
  };

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput;
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>;
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>;
  };

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput;
  };

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput;
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number;
  };

  /**
   * Faculty.patents
   */
  export type Faculty$patentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    where?: PatentsWhereInput;
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    cursor?: PatentsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[];
  };

  /**
   * Faculty.publications
   */
  export type Faculty$publicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    where?: PublicationWhereInput;
    orderBy?:
      | PublicationOrderByWithRelationInput
      | PublicationOrderByWithRelationInput[];
    cursor?: PublicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[];
  };

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
  };

  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  export type EventAvgAggregateOutputType = {
    maxTeamSize: number | null;
    minTeamSize: number | null;
    maxTeams: number | null;
  };

  export type EventSumAggregateOutputType = {
    maxTeamSize: number | null;
    minTeamSize: number | null;
    maxTeams: number | null;
  };

  export type EventMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    image: string | null;
    date: Date | null;
    time: string | null;
    reportLink: string | null;
    venue: string | null;
    published: boolean | null;
    type: $Enums.EventType | null;
    category: $Enums.EventCategory | null;
    maxTeamSize: number | null;
    minTeamSize: number | null;
    brief: string | null;
    entryFee: string | null;
    qr: string | null;
    registrationsAvailable: boolean | null;
    endDate: Date | null;
    maxTeams: number | null;
    notification: string | null;
  };

  export type EventMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    image: string | null;
    date: Date | null;
    time: string | null;
    reportLink: string | null;
    venue: string | null;
    published: boolean | null;
    type: $Enums.EventType | null;
    category: $Enums.EventCategory | null;
    maxTeamSize: number | null;
    minTeamSize: number | null;
    brief: string | null;
    entryFee: string | null;
    qr: string | null;
    registrationsAvailable: boolean | null;
    endDate: Date | null;
    maxTeams: number | null;
    notification: string | null;
  };

  export type EventCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    image: number;
    date: number;
    time: number;
    reportLink: number;
    venue: number;
    guests: number;
    published: number;
    type: number;
    category: number;
    maxTeamSize: number;
    minTeamSize: number;
    brief: number;
    entryFee: number;
    qr: number;
    registrationsAvailable: number;
    endDate: number;
    maxTeams: number;
    notification: number;
    _all: number;
  };

  export type EventAvgAggregateInputType = {
    maxTeamSize?: true;
    minTeamSize?: true;
    maxTeams?: true;
  };

  export type EventSumAggregateInputType = {
    maxTeamSize?: true;
    minTeamSize?: true;
    maxTeams?: true;
  };

  export type EventMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    image?: true;
    date?: true;
    time?: true;
    reportLink?: true;
    venue?: true;
    published?: true;
    type?: true;
    category?: true;
    maxTeamSize?: true;
    minTeamSize?: true;
    brief?: true;
    entryFee?: true;
    qr?: true;
    registrationsAvailable?: true;
    endDate?: true;
    maxTeams?: true;
    notification?: true;
  };

  export type EventMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    image?: true;
    date?: true;
    time?: true;
    reportLink?: true;
    venue?: true;
    published?: true;
    type?: true;
    category?: true;
    maxTeamSize?: true;
    minTeamSize?: true;
    brief?: true;
    entryFee?: true;
    qr?: true;
    registrationsAvailable?: true;
    endDate?: true;
    maxTeams?: true;
    notification?: true;
  };

  export type EventCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    image?: true;
    date?: true;
    time?: true;
    reportLink?: true;
    venue?: true;
    guests?: true;
    published?: true;
    type?: true;
    category?: true;
    maxTeamSize?: true;
    minTeamSize?: true;
    brief?: true;
    entryFee?: true;
    qr?: true;
    registrationsAvailable?: true;
    endDate?: true;
    maxTeams?: true;
    notification?: true;
    _all?: true;
  };

  export type EventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Events
     **/
    _count?: true | EventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EventAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EventSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventMaxAggregateInputType;
  };

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
    [P in keyof T & keyof AggregateEvent]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>;
  };

  export type EventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventWhereInput;
    orderBy?:
      | EventOrderByWithAggregationInput
      | EventOrderByWithAggregationInput[];
    by: EventScalarFieldEnum[] | EventScalarFieldEnum;
    having?: EventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EventCountAggregateInputType | true;
    _avg?: EventAvgAggregateInputType;
    _sum?: EventSumAggregateInputType;
    _min?: EventMinAggregateInputType;
    _max?: EventMaxAggregateInputType;
  };

  export type EventGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    image: string;
    date: Date;
    time: string | null;
    reportLink: string | null;
    venue: string | null;
    guests: string[];
    published: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize: number;
    minTeamSize: number;
    brief: string | null;
    entryFee: string | null;
    qr: string | null;
    registrationsAvailable: boolean;
    endDate: Date | null;
    maxTeams: number | null;
    notification: string | null;
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  type GetEventGroupByPayload<T extends EventGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EventGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof EventGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>;
        }
      >
    >;

  export type EventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      image?: boolean;
      date?: boolean;
      time?: boolean;
      reportLink?: boolean;
      venue?: boolean;
      guests?: boolean;
      published?: boolean;
      type?: boolean;
      category?: boolean;
      maxTeamSize?: boolean;
      minTeamSize?: boolean;
      brief?: boolean;
      entryFee?: boolean;
      qr?: boolean;
      registrationsAvailable?: boolean;
      endDate?: boolean;
      maxTeams?: boolean;
      notification?: boolean;
      participants?: boolean | Event$participantsArgs<ExtArgs>;
      winners?: boolean | Event$winnersArgs<ExtArgs>;
      organizers?: boolean | Event$organizersArgs<ExtArgs>;
      _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["event"]
  >;

  export type EventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      image?: boolean;
      date?: boolean;
      time?: boolean;
      reportLink?: boolean;
      venue?: boolean;
      guests?: boolean;
      published?: boolean;
      type?: boolean;
      category?: boolean;
      maxTeamSize?: boolean;
      minTeamSize?: boolean;
      brief?: boolean;
      entryFee?: boolean;
      qr?: boolean;
      registrationsAvailable?: boolean;
      endDate?: boolean;
      maxTeams?: boolean;
      notification?: boolean;
    },
    ExtArgs["result"]["event"]
  >;

  export type EventSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      image?: boolean;
      date?: boolean;
      time?: boolean;
      reportLink?: boolean;
      venue?: boolean;
      guests?: boolean;
      published?: boolean;
      type?: boolean;
      category?: boolean;
      maxTeamSize?: boolean;
      minTeamSize?: boolean;
      brief?: boolean;
      entryFee?: boolean;
      qr?: boolean;
      registrationsAvailable?: boolean;
      endDate?: boolean;
      maxTeams?: boolean;
      notification?: boolean;
    },
    ExtArgs["result"]["event"]
  >;

  export type EventSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    image?: boolean;
    date?: boolean;
    time?: boolean;
    reportLink?: boolean;
    venue?: boolean;
    guests?: boolean;
    published?: boolean;
    type?: boolean;
    category?: boolean;
    maxTeamSize?: boolean;
    minTeamSize?: boolean;
    brief?: boolean;
    entryFee?: boolean;
    qr?: boolean;
    registrationsAvailable?: boolean;
    endDate?: boolean;
    maxTeams?: boolean;
    notification?: boolean;
  };

  export type EventOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "title"
    | "description"
    | "image"
    | "date"
    | "time"
    | "reportLink"
    | "venue"
    | "guests"
    | "published"
    | "type"
    | "category"
    | "maxTeamSize"
    | "minTeamSize"
    | "brief"
    | "entryFee"
    | "qr"
    | "registrationsAvailable"
    | "endDate"
    | "maxTeams"
    | "notification",
    ExtArgs["result"]["event"]
  >;
  export type EventInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    participants?: boolean | Event$participantsArgs<ExtArgs>;
    winners?: boolean | Event$winnersArgs<ExtArgs>;
    organizers?: boolean | Event$organizersArgs<ExtArgs>;
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type EventIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type EventIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $EventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Event";
    objects: {
      participants: Prisma.$TeamPayload<ExtArgs>[];
      winners: Prisma.$WinnersPayload<ExtArgs>[];
      organizers: Prisma.$UserPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string | null;
        image: string;
        date: Date;
        time: string | null;
        reportLink: string | null;
        venue: string | null;
        guests: string[];
        published: boolean;
        type: $Enums.EventType;
        category: $Enums.EventCategory;
        maxTeamSize: number;
        minTeamSize: number;
        brief: string | null;
        entryFee: string | null;
        qr: string | null;
        registrationsAvailable: boolean;
        endDate: Date | null;
        maxTeams: number | null;
        notification: string | null;
      },
      ExtArgs["result"]["event"]
    >;
    composites: {};
  };

  type EventGetPayload<
    S extends boolean | null | undefined | EventDefaultArgs,
  > = $Result.GetResult<Prisma.$EventPayload, S>;

  type EventCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<EventFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: EventCountAggregateInputType | true;
  };

  export interface EventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Event"];
      meta: { name: "Event" };
    };
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(
      args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(
      args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     *
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     *
     */
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     *
     */
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(
      args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
     **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventAggregateArgs>(
      args: Subset<T, EventAggregateArgs>,
    ): Prisma.PrismaPromise<GetEventAggregateType<T>>;

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs["orderBy"] }
        : { orderBy?: EventGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Event model
     */
    readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    participants<T extends Event$participantsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$participantsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    winners<T extends Event$winnersArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$winnersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WinnersPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    organizers<T extends Event$organizersArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$organizersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", "String">;
    readonly title: FieldRef<"Event", "String">;
    readonly description: FieldRef<"Event", "String">;
    readonly image: FieldRef<"Event", "String">;
    readonly date: FieldRef<"Event", "DateTime">;
    readonly time: FieldRef<"Event", "String">;
    readonly reportLink: FieldRef<"Event", "String">;
    readonly venue: FieldRef<"Event", "String">;
    readonly guests: FieldRef<"Event", "String[]">;
    readonly published: FieldRef<"Event", "Boolean">;
    readonly type: FieldRef<"Event", "EventType">;
    readonly category: FieldRef<"Event", "EventCategory">;
    readonly maxTeamSize: FieldRef<"Event", "Int">;
    readonly minTeamSize: FieldRef<"Event", "Int">;
    readonly brief: FieldRef<"Event", "String">;
    readonly entryFee: FieldRef<"Event", "String">;
    readonly qr: FieldRef<"Event", "String">;
    readonly registrationsAvailable: FieldRef<"Event", "Boolean">;
    readonly endDate: FieldRef<"Event", "DateTime">;
    readonly maxTeams: FieldRef<"Event", "Int">;
    readonly notification: FieldRef<"Event", "String">;
  }

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findMany
   */
  export type EventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event create
   */
  export type EventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>;
  };

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Event update
   */
  export type EventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>;
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to update.
     */
    limit?: number;
  };

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>;
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to update.
     */
    limit?: number;
  };

  /**
   * Event upsert
   */
  export type EventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput;
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>;
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
  };

  /**
   * Event delete
   */
  export type EventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to delete.
     */
    limit?: number;
  };

  /**
   * Event.participants
   */
  export type Event$participantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    cursor?: TeamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Event.winners
   */
  export type Event$winnersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    where?: WinnersWhereInput;
    orderBy?:
      | WinnersOrderByWithRelationInput
      | WinnersOrderByWithRelationInput[];
    cursor?: WinnersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WinnersScalarFieldEnum | WinnersScalarFieldEnum[];
  };

  /**
   * Event.organizers
   */
  export type Event$organizersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * Event without action
   */
  export type EventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
  };

  /**
   * Model Links
   */

  export type AggregateLinks = {
    _count: LinksCountAggregateOutputType | null;
    _min: LinksMinAggregateOutputType | null;
    _max: LinksMaxAggregateOutputType | null;
  };

  export type LinksMinAggregateOutputType = {
    id: string | null;
    instagram: string | null;
    linkedin: string | null;
    github: string | null;
    userId: string | null;
    twitter: string | null;
  };

  export type LinksMaxAggregateOutputType = {
    id: string | null;
    instagram: string | null;
    linkedin: string | null;
    github: string | null;
    userId: string | null;
    twitter: string | null;
  };

  export type LinksCountAggregateOutputType = {
    id: number;
    instagram: number;
    linkedin: number;
    github: number;
    userId: number;
    twitter: number;
    order: number;
    custom: number;
    _all: number;
  };

  export type LinksMinAggregateInputType = {
    id?: true;
    instagram?: true;
    linkedin?: true;
    github?: true;
    userId?: true;
    twitter?: true;
  };

  export type LinksMaxAggregateInputType = {
    id?: true;
    instagram?: true;
    linkedin?: true;
    github?: true;
    userId?: true;
    twitter?: true;
  };

  export type LinksCountAggregateInputType = {
    id?: true;
    instagram?: true;
    linkedin?: true;
    github?: true;
    userId?: true;
    twitter?: true;
    order?: true;
    custom?: true;
    _all?: true;
  };

  export type LinksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Links to aggregate.
     */
    where?: LinksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Links to fetch.
     */
    orderBy?: LinksOrderByWithRelationInput | LinksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LinksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Links from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Links.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Links
     **/
    _count?: true | LinksCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LinksMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LinksMaxAggregateInputType;
  };

  export type GetLinksAggregateType<T extends LinksAggregateArgs> = {
    [P in keyof T & keyof AggregateLinks]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinks[P]>
      : GetScalarType<T[P], AggregateLinks[P]>;
  };

  export type LinksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LinksWhereInput;
    orderBy?:
      | LinksOrderByWithAggregationInput
      | LinksOrderByWithAggregationInput[];
    by: LinksScalarFieldEnum[] | LinksScalarFieldEnum;
    having?: LinksScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LinksCountAggregateInputType | true;
    _min?: LinksMinAggregateInputType;
    _max?: LinksMaxAggregateInputType;
  };

  export type LinksGroupByOutputType = {
    id: string;
    instagram: string | null;
    linkedin: string | null;
    github: string | null;
    userId: string;
    twitter: string | null;
    order: string[];
    custom: JsonValue | null;
    _count: LinksCountAggregateOutputType | null;
    _min: LinksMinAggregateOutputType | null;
    _max: LinksMaxAggregateOutputType | null;
  };

  type GetLinksGroupByPayload<T extends LinksGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LinksGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof LinksGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinksGroupByOutputType[P]>
            : GetScalarType<T[P], LinksGroupByOutputType[P]>;
        }
      >
    >;

  export type LinksSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      instagram?: boolean;
      linkedin?: boolean;
      github?: boolean;
      userId?: boolean;
      twitter?: boolean;
      order?: boolean;
      custom?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["links"]
  >;

  export type LinksSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      instagram?: boolean;
      linkedin?: boolean;
      github?: boolean;
      userId?: boolean;
      twitter?: boolean;
      order?: boolean;
      custom?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["links"]
  >;

  export type LinksSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      instagram?: boolean;
      linkedin?: boolean;
      github?: boolean;
      userId?: boolean;
      twitter?: boolean;
      order?: boolean;
      custom?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["links"]
  >;

  export type LinksSelectScalar = {
    id?: boolean;
    instagram?: boolean;
    linkedin?: boolean;
    github?: boolean;
    userId?: boolean;
    twitter?: boolean;
    order?: boolean;
    custom?: boolean;
  };

  export type LinksOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "instagram"
    | "linkedin"
    | "github"
    | "userId"
    | "twitter"
    | "order"
    | "custom",
    ExtArgs["result"]["links"]
  >;
  export type LinksInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type LinksIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type LinksIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $LinksPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Links";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        instagram: string | null;
        linkedin: string | null;
        github: string | null;
        userId: string;
        twitter: string | null;
        order: string[];
        custom: Prisma.JsonValue | null;
      },
      ExtArgs["result"]["links"]
    >;
    composites: {};
  };

  type LinksGetPayload<
    S extends boolean | null | undefined | LinksDefaultArgs,
  > = $Result.GetResult<Prisma.$LinksPayload, S>;

  type LinksCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<LinksFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: LinksCountAggregateInputType | true;
  };

  export interface LinksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Links"];
      meta: { name: "Links" };
    };
    /**
     * Find zero or one Links that matches the filter.
     * @param {LinksFindUniqueArgs} args - Arguments to find a Links
     * @example
     * // Get one Links
     * const links = await prisma.links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinksFindUniqueArgs>(
      args: SelectSubset<T, LinksFindUniqueArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Links that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinksFindUniqueOrThrowArgs} args - Arguments to find a Links
     * @example
     * // Get one Links
     * const links = await prisma.links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LinksFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksFindFirstArgs} args - Arguments to find a Links
     * @example
     * // Get one Links
     * const links = await prisma.links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinksFindFirstArgs>(
      args?: SelectSubset<T, LinksFindFirstArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksFindFirstOrThrowArgs} args - Arguments to find a Links
     * @example
     * // Get one Links
     * const links = await prisma.links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LinksFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Links
     * const links = await prisma.links.findMany()
     *
     * // Get first 10 Links
     * const links = await prisma.links.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const linksWithIdOnly = await prisma.links.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LinksFindManyArgs>(
      args?: SelectSubset<T, LinksFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Links.
     * @param {LinksCreateArgs} args - Arguments to create a Links.
     * @example
     * // Create one Links
     * const Links = await prisma.links.create({
     *   data: {
     *     // ... data to create a Links
     *   }
     * })
     *
     */
    create<T extends LinksCreateArgs>(
      args: SelectSubset<T, LinksCreateArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Links.
     * @param {LinksCreateManyArgs} args - Arguments to create many Links.
     * @example
     * // Create many Links
     * const links = await prisma.links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LinksCreateManyArgs>(
      args?: SelectSubset<T, LinksCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Links and returns the data saved in the database.
     * @param {LinksCreateManyAndReturnArgs} args - Arguments to create many Links.
     * @example
     * // Create many Links
     * const links = await prisma.links.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Links and only return the `id`
     * const linksWithIdOnly = await prisma.links.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LinksCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LinksCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Links.
     * @param {LinksDeleteArgs} args - Arguments to delete one Links.
     * @example
     * // Delete one Links
     * const Links = await prisma.links.delete({
     *   where: {
     *     // ... filter to delete one Links
     *   }
     * })
     *
     */
    delete<T extends LinksDeleteArgs>(
      args: SelectSubset<T, LinksDeleteArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Links.
     * @param {LinksUpdateArgs} args - Arguments to update one Links.
     * @example
     * // Update one Links
     * const links = await prisma.links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LinksUpdateArgs>(
      args: SelectSubset<T, LinksUpdateArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Links.
     * @param {LinksDeleteManyArgs} args - Arguments to filter Links to delete.
     * @example
     * // Delete a few Links
     * const { count } = await prisma.links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LinksDeleteManyArgs>(
      args?: SelectSubset<T, LinksDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Links
     * const links = await prisma.links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LinksUpdateManyArgs>(
      args: SelectSubset<T, LinksUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Links and returns the data updated in the database.
     * @param {LinksUpdateManyAndReturnArgs} args - Arguments to update many Links.
     * @example
     * // Update many Links
     * const links = await prisma.links.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Links and only return the `id`
     * const linksWithIdOnly = await prisma.links.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LinksUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LinksUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Links.
     * @param {LinksUpsertArgs} args - Arguments to update or create a Links.
     * @example
     * // Update or create a Links
     * const links = await prisma.links.upsert({
     *   create: {
     *     // ... data to create a Links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Links we want to update
     *   }
     * })
     */
    upsert<T extends LinksUpsertArgs>(
      args: SelectSubset<T, LinksUpsertArgs<ExtArgs>>,
    ): Prisma__LinksClient<
      $Result.GetResult<
        Prisma.$LinksPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksCountArgs} args - Arguments to filter Links to count.
     * @example
     * // Count the number of Links
     * const count = await prisma.links.count({
     *   where: {
     *     // ... the filter for the Links we want to count
     *   }
     * })
     **/
    count<T extends LinksCountArgs>(
      args?: Subset<T, LinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LinksCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LinksAggregateArgs>(
      args: Subset<T, LinksAggregateArgs>,
    ): Prisma.PrismaPromise<GetLinksAggregateType<T>>;

    /**
     * Group by Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinksGroupByArgs["orderBy"] }
        : { orderBy?: LinksGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LinksGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLinksGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Links model
     */
    readonly fields: LinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Links model
   */
  interface LinksFieldRefs {
    readonly id: FieldRef<"Links", "String">;
    readonly instagram: FieldRef<"Links", "String">;
    readonly linkedin: FieldRef<"Links", "String">;
    readonly github: FieldRef<"Links", "String">;
    readonly userId: FieldRef<"Links", "String">;
    readonly twitter: FieldRef<"Links", "String">;
    readonly order: FieldRef<"Links", "String[]">;
    readonly custom: FieldRef<"Links", "Json">;
  }

  // Custom InputTypes
  /**
   * Links findUnique
   */
  export type LinksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter, which Links to fetch.
     */
    where: LinksWhereUniqueInput;
  };

  /**
   * Links findUniqueOrThrow
   */
  export type LinksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter, which Links to fetch.
     */
    where: LinksWhereUniqueInput;
  };

  /**
   * Links findFirst
   */
  export type LinksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter, which Links to fetch.
     */
    where?: LinksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Links to fetch.
     */
    orderBy?: LinksOrderByWithRelationInput | LinksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Links.
     */
    cursor?: LinksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Links from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Links.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Links.
     */
    distinct?: LinksScalarFieldEnum | LinksScalarFieldEnum[];
  };

  /**
   * Links findFirstOrThrow
   */
  export type LinksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter, which Links to fetch.
     */
    where?: LinksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Links to fetch.
     */
    orderBy?: LinksOrderByWithRelationInput | LinksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Links.
     */
    cursor?: LinksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Links from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Links.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Links.
     */
    distinct?: LinksScalarFieldEnum | LinksScalarFieldEnum[];
  };

  /**
   * Links findMany
   */
  export type LinksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter, which Links to fetch.
     */
    where?: LinksWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Links to fetch.
     */
    orderBy?: LinksOrderByWithRelationInput | LinksOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Links.
     */
    cursor?: LinksWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Links from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Links.
     */
    skip?: number;
    distinct?: LinksScalarFieldEnum | LinksScalarFieldEnum[];
  };

  /**
   * Links create
   */
  export type LinksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * The data needed to create a Links.
     */
    data: XOR<LinksCreateInput, LinksUncheckedCreateInput>;
  };

  /**
   * Links createMany
   */
  export type LinksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Links.
     */
    data: LinksCreateManyInput | LinksCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Links createManyAndReturn
   */
  export type LinksCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * The data used to create many Links.
     */
    data: LinksCreateManyInput | LinksCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Links update
   */
  export type LinksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * The data needed to update a Links.
     */
    data: XOR<LinksUpdateInput, LinksUncheckedUpdateInput>;
    /**
     * Choose, which Links to update.
     */
    where: LinksWhereUniqueInput;
  };

  /**
   * Links updateMany
   */
  export type LinksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Links.
     */
    data: XOR<LinksUpdateManyMutationInput, LinksUncheckedUpdateManyInput>;
    /**
     * Filter which Links to update
     */
    where?: LinksWhereInput;
    /**
     * Limit how many Links to update.
     */
    limit?: number;
  };

  /**
   * Links updateManyAndReturn
   */
  export type LinksUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * The data used to update Links.
     */
    data: XOR<LinksUpdateManyMutationInput, LinksUncheckedUpdateManyInput>;
    /**
     * Filter which Links to update
     */
    where?: LinksWhereInput;
    /**
     * Limit how many Links to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Links upsert
   */
  export type LinksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * The filter to search for the Links to update in case it exists.
     */
    where: LinksWhereUniqueInput;
    /**
     * In case the Links found by the `where` argument doesn't exist, create a new Links with this data.
     */
    create: XOR<LinksCreateInput, LinksUncheckedCreateInput>;
    /**
     * In case the Links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinksUpdateInput, LinksUncheckedUpdateInput>;
  };

  /**
   * Links delete
   */
  export type LinksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
    /**
     * Filter which Links to delete.
     */
    where: LinksWhereUniqueInput;
  };

  /**
   * Links deleteMany
   */
  export type LinksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Links to delete
     */
    where?: LinksWhereInput;
    /**
     * Limit how many Links to delete.
     */
    limit?: number;
  };

  /**
   * Links without action
   */
  export type LinksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Links
     */
    select?: LinksSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Links
     */
    omit?: LinksOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInclude<ExtArgs> | null;
  };

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  export type TeamMinAggregateOutputType = {
    id: string | null;
    attended: boolean | null;
    eventId: string | null;
    name: string | null;
    leaderId: string | null;
    transactionId: string | null;
    isConfirmed: boolean | null;
  };

  export type TeamMaxAggregateOutputType = {
    id: string | null;
    attended: boolean | null;
    eventId: string | null;
    name: string | null;
    leaderId: string | null;
    transactionId: string | null;
    isConfirmed: boolean | null;
  };

  export type TeamCountAggregateOutputType = {
    id: number;
    attended: number;
    eventId: number;
    name: number;
    leaderId: number;
    transactionId: number;
    isConfirmed: number;
    _all: number;
  };

  export type TeamMinAggregateInputType = {
    id?: true;
    attended?: true;
    eventId?: true;
    name?: true;
    leaderId?: true;
    transactionId?: true;
    isConfirmed?: true;
  };

  export type TeamMaxAggregateInputType = {
    id?: true;
    attended?: true;
    eventId?: true;
    name?: true;
    leaderId?: true;
    transactionId?: true;
    isConfirmed?: true;
  };

  export type TeamCountAggregateInputType = {
    id?: true;
    attended?: true;
    eventId?: true;
    name?: true;
    leaderId?: true;
    transactionId?: true;
    isConfirmed?: true;
    _all?: true;
  };

  export type TeamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Teams
     **/
    _count?: true | TeamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMaxAggregateInputType;
  };

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
    [P in keyof T & keyof AggregateTeam]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>;
  };

  export type TeamGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
    orderBy?:
      | TeamOrderByWithAggregationInput
      | TeamOrderByWithAggregationInput[];
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum;
    having?: TeamScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamCountAggregateInputType | true;
    _min?: TeamMinAggregateInputType;
    _max?: TeamMaxAggregateInputType;
  };

  export type TeamGroupByOutputType = {
    id: string;
    attended: boolean;
    eventId: string;
    name: string | null;
    leaderId: string | null;
    transactionId: string | null;
    isConfirmed: boolean;
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TeamGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
          : GetScalarType<T[P], TeamGroupByOutputType[P]>;
      }
    >
  >;

  export type TeamSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      attended?: boolean;
      eventId?: boolean;
      name?: boolean;
      leaderId?: boolean;
      transactionId?: boolean;
      isConfirmed?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      winner?: boolean | Team$winnerArgs<ExtArgs>;
      user?: boolean | Team$userArgs<ExtArgs>;
      _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["team"]
  >;

  export type TeamSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      attended?: boolean;
      eventId?: boolean;
      name?: boolean;
      leaderId?: boolean;
      transactionId?: boolean;
      isConfirmed?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["team"]
  >;

  export type TeamSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      attended?: boolean;
      eventId?: boolean;
      name?: boolean;
      leaderId?: boolean;
      transactionId?: boolean;
      isConfirmed?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["team"]
  >;

  export type TeamSelectScalar = {
    id?: boolean;
    attended?: boolean;
    eventId?: boolean;
    name?: boolean;
    leaderId?: boolean;
    transactionId?: boolean;
    isConfirmed?: boolean;
  };

  export type TeamOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "attended"
    | "eventId"
    | "name"
    | "leaderId"
    | "transactionId"
    | "isConfirmed",
    ExtArgs["result"]["team"]
  >;
  export type TeamInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    winner?: boolean | Team$winnerArgs<ExtArgs>;
    user?: boolean | Team$userArgs<ExtArgs>;
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TeamIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
  };
  export type TeamIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
  };

  export type $TeamPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Team";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      winner: Prisma.$WinnersPayload<ExtArgs> | null;
      user: Prisma.$UserPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        attended: boolean;
        eventId: string;
        name: string | null;
        leaderId: string | null;
        transactionId: string | null;
        isConfirmed: boolean;
      },
      ExtArgs["result"]["team"]
    >;
    composites: {};
  };

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> =
    $Result.GetResult<Prisma.$TeamPayload, S>;

  type TeamCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TeamFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TeamCountAggregateInputType | true;
  };

  export interface TeamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Team"];
      meta: { name: "Team" };
    };
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(
      args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(
      args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     *
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     *
     */
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamCreateManyArgs>(
      args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     *
     */
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
     **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamAggregateArgs>(
      args: Subset<T, TeamAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamAggregateType<T>>;

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs["orderBy"] }
        : { orderBy?: TeamGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTeamGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Team model
     */
    readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    winner<T extends Team$winnerArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$winnerArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends Team$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$userArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", "String">;
    readonly attended: FieldRef<"Team", "Boolean">;
    readonly eventId: FieldRef<"Team", "String">;
    readonly name: FieldRef<"Team", "String">;
    readonly leaderId: FieldRef<"Team", "String">;
    readonly transactionId: FieldRef<"Team", "String">;
    readonly isConfirmed: FieldRef<"Team", "Boolean">;
  }

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team create
   */
  export type TeamCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
  };

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Team update
   */
  export type TeamUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput;
    /**
     * Limit how many Teams to update.
     */
    limit?: number;
  };

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput;
    /**
     * Limit how many Teams to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput;
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
  };

  /**
   * Team delete
   */
  export type TeamDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput;
    /**
     * Limit how many Teams to delete.
     */
    limit?: number;
  };

  /**
   * Team.winner
   */
  export type Team$winnerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    where?: WinnersWhereInput;
  };

  /**
   * Team.user
   */
  export type Team$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * Team without action
   */
  export type TeamDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
  };

  /**
   * Model Winners
   */

  export type AggregateWinners = {
    _count: WinnersCountAggregateOutputType | null;
    _min: WinnersMinAggregateOutputType | null;
    _max: WinnersMaxAggregateOutputType | null;
  };

  export type WinnersMinAggregateOutputType = {
    id: string | null;
    teamId: string | null;
    eventId: string | null;
    position: $Enums.WinnerType | null;
  };

  export type WinnersMaxAggregateOutputType = {
    id: string | null;
    teamId: string | null;
    eventId: string | null;
    position: $Enums.WinnerType | null;
  };

  export type WinnersCountAggregateOutputType = {
    id: number;
    teamId: number;
    eventId: number;
    position: number;
    _all: number;
  };

  export type WinnersMinAggregateInputType = {
    id?: true;
    teamId?: true;
    eventId?: true;
    position?: true;
  };

  export type WinnersMaxAggregateInputType = {
    id?: true;
    teamId?: true;
    eventId?: true;
    position?: true;
  };

  export type WinnersCountAggregateInputType = {
    id?: true;
    teamId?: true;
    eventId?: true;
    position?: true;
    _all?: true;
  };

  export type WinnersAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Winners to aggregate.
     */
    where?: WinnersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Winners to fetch.
     */
    orderBy?:
      | WinnersOrderByWithRelationInput
      | WinnersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WinnersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Winners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Winners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Winners
     **/
    _count?: true | WinnersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WinnersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WinnersMaxAggregateInputType;
  };

  export type GetWinnersAggregateType<T extends WinnersAggregateArgs> = {
    [P in keyof T & keyof AggregateWinners]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinners[P]>
      : GetScalarType<T[P], AggregateWinners[P]>;
  };

  export type WinnersGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WinnersWhereInput;
    orderBy?:
      | WinnersOrderByWithAggregationInput
      | WinnersOrderByWithAggregationInput[];
    by: WinnersScalarFieldEnum[] | WinnersScalarFieldEnum;
    having?: WinnersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WinnersCountAggregateInputType | true;
    _min?: WinnersMinAggregateInputType;
    _max?: WinnersMaxAggregateInputType;
  };

  export type WinnersGroupByOutputType = {
    id: string;
    teamId: string;
    eventId: string;
    position: $Enums.WinnerType;
    _count: WinnersCountAggregateOutputType | null;
    _min: WinnersMinAggregateOutputType | null;
    _max: WinnersMaxAggregateOutputType | null;
  };

  type GetWinnersGroupByPayload<T extends WinnersGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WinnersGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof WinnersGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WinnersGroupByOutputType[P]>
            : GetScalarType<T[P], WinnersGroupByOutputType[P]>;
        }
      >
    >;

  export type WinnersSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      teamId?: boolean;
      eventId?: boolean;
      position?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["winners"]
  >;

  export type WinnersSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      teamId?: boolean;
      eventId?: boolean;
      position?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["winners"]
  >;

  export type WinnersSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      teamId?: boolean;
      eventId?: boolean;
      position?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["winners"]
  >;

  export type WinnersSelectScalar = {
    id?: boolean;
    teamId?: boolean;
    eventId?: boolean;
    position?: boolean;
  };

  export type WinnersOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "teamId" | "eventId" | "position",
    ExtArgs["result"]["winners"]
  >;
  export type WinnersInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
  };
  export type WinnersIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
  };
  export type WinnersIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
  };

  export type $WinnersPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Winners";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        teamId: string;
        eventId: string;
        position: $Enums.WinnerType;
      },
      ExtArgs["result"]["winners"]
    >;
    composites: {};
  };

  type WinnersGetPayload<
    S extends boolean | null | undefined | WinnersDefaultArgs,
  > = $Result.GetResult<Prisma.$WinnersPayload, S>;

  type WinnersCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<WinnersFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: WinnersCountAggregateInputType | true;
  };

  export interface WinnersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Winners"];
      meta: { name: "Winners" };
    };
    /**
     * Find zero or one Winners that matches the filter.
     * @param {WinnersFindUniqueArgs} args - Arguments to find a Winners
     * @example
     * // Get one Winners
     * const winners = await prisma.winners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WinnersFindUniqueArgs>(
      args: SelectSubset<T, WinnersFindUniqueArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Winners that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WinnersFindUniqueOrThrowArgs} args - Arguments to find a Winners
     * @example
     * // Get one Winners
     * const winners = await prisma.winners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WinnersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WinnersFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Winners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersFindFirstArgs} args - Arguments to find a Winners
     * @example
     * // Get one Winners
     * const winners = await prisma.winners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WinnersFindFirstArgs>(
      args?: SelectSubset<T, WinnersFindFirstArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Winners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersFindFirstOrThrowArgs} args - Arguments to find a Winners
     * @example
     * // Get one Winners
     * const winners = await prisma.winners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WinnersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WinnersFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Winners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Winners
     * const winners = await prisma.winners.findMany()
     *
     * // Get first 10 Winners
     * const winners = await prisma.winners.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const winnersWithIdOnly = await prisma.winners.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WinnersFindManyArgs>(
      args?: SelectSubset<T, WinnersFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Winners.
     * @param {WinnersCreateArgs} args - Arguments to create a Winners.
     * @example
     * // Create one Winners
     * const Winners = await prisma.winners.create({
     *   data: {
     *     // ... data to create a Winners
     *   }
     * })
     *
     */
    create<T extends WinnersCreateArgs>(
      args: SelectSubset<T, WinnersCreateArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Winners.
     * @param {WinnersCreateManyArgs} args - Arguments to create many Winners.
     * @example
     * // Create many Winners
     * const winners = await prisma.winners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WinnersCreateManyArgs>(
      args?: SelectSubset<T, WinnersCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Winners and returns the data saved in the database.
     * @param {WinnersCreateManyAndReturnArgs} args - Arguments to create many Winners.
     * @example
     * // Create many Winners
     * const winners = await prisma.winners.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Winners and only return the `id`
     * const winnersWithIdOnly = await prisma.winners.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WinnersCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WinnersCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Winners.
     * @param {WinnersDeleteArgs} args - Arguments to delete one Winners.
     * @example
     * // Delete one Winners
     * const Winners = await prisma.winners.delete({
     *   where: {
     *     // ... filter to delete one Winners
     *   }
     * })
     *
     */
    delete<T extends WinnersDeleteArgs>(
      args: SelectSubset<T, WinnersDeleteArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Winners.
     * @param {WinnersUpdateArgs} args - Arguments to update one Winners.
     * @example
     * // Update one Winners
     * const winners = await prisma.winners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WinnersUpdateArgs>(
      args: SelectSubset<T, WinnersUpdateArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Winners.
     * @param {WinnersDeleteManyArgs} args - Arguments to filter Winners to delete.
     * @example
     * // Delete a few Winners
     * const { count } = await prisma.winners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WinnersDeleteManyArgs>(
      args?: SelectSubset<T, WinnersDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Winners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Winners
     * const winners = await prisma.winners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WinnersUpdateManyArgs>(
      args: SelectSubset<T, WinnersUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Winners and returns the data updated in the database.
     * @param {WinnersUpdateManyAndReturnArgs} args - Arguments to update many Winners.
     * @example
     * // Update many Winners
     * const winners = await prisma.winners.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Winners and only return the `id`
     * const winnersWithIdOnly = await prisma.winners.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WinnersUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WinnersUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Winners.
     * @param {WinnersUpsertArgs} args - Arguments to update or create a Winners.
     * @example
     * // Update or create a Winners
     * const winners = await prisma.winners.upsert({
     *   create: {
     *     // ... data to create a Winners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winners we want to update
     *   }
     * })
     */
    upsert<T extends WinnersUpsertArgs>(
      args: SelectSubset<T, WinnersUpsertArgs<ExtArgs>>,
    ): Prisma__WinnersClient<
      $Result.GetResult<
        Prisma.$WinnersPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Winners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersCountArgs} args - Arguments to filter Winners to count.
     * @example
     * // Count the number of Winners
     * const count = await prisma.winners.count({
     *   where: {
     *     // ... the filter for the Winners we want to count
     *   }
     * })
     **/
    count<T extends WinnersCountArgs>(
      args?: Subset<T, WinnersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], WinnersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Winners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WinnersAggregateArgs>(
      args: Subset<T, WinnersAggregateArgs>,
    ): Prisma.PrismaPromise<GetWinnersAggregateType<T>>;

    /**
     * Group by Winners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WinnersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WinnersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WinnersGroupByArgs["orderBy"] }
        : { orderBy?: WinnersGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WinnersGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetWinnersGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Winners model
     */
    readonly fields: WinnersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Winners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WinnersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Winners model
   */
  interface WinnersFieldRefs {
    readonly id: FieldRef<"Winners", "String">;
    readonly teamId: FieldRef<"Winners", "String">;
    readonly eventId: FieldRef<"Winners", "String">;
    readonly position: FieldRef<"Winners", "WinnerType">;
  }

  // Custom InputTypes
  /**
   * Winners findUnique
   */
  export type WinnersFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter, which Winners to fetch.
     */
    where: WinnersWhereUniqueInput;
  };

  /**
   * Winners findUniqueOrThrow
   */
  export type WinnersFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter, which Winners to fetch.
     */
    where: WinnersWhereUniqueInput;
  };

  /**
   * Winners findFirst
   */
  export type WinnersFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter, which Winners to fetch.
     */
    where?: WinnersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Winners to fetch.
     */
    orderBy?:
      | WinnersOrderByWithRelationInput
      | WinnersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Winners.
     */
    cursor?: WinnersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Winners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Winners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Winners.
     */
    distinct?: WinnersScalarFieldEnum | WinnersScalarFieldEnum[];
  };

  /**
   * Winners findFirstOrThrow
   */
  export type WinnersFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter, which Winners to fetch.
     */
    where?: WinnersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Winners to fetch.
     */
    orderBy?:
      | WinnersOrderByWithRelationInput
      | WinnersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Winners.
     */
    cursor?: WinnersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Winners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Winners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Winners.
     */
    distinct?: WinnersScalarFieldEnum | WinnersScalarFieldEnum[];
  };

  /**
   * Winners findMany
   */
  export type WinnersFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter, which Winners to fetch.
     */
    where?: WinnersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Winners to fetch.
     */
    orderBy?:
      | WinnersOrderByWithRelationInput
      | WinnersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Winners.
     */
    cursor?: WinnersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Winners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Winners.
     */
    skip?: number;
    distinct?: WinnersScalarFieldEnum | WinnersScalarFieldEnum[];
  };

  /**
   * Winners create
   */
  export type WinnersCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * The data needed to create a Winners.
     */
    data: XOR<WinnersCreateInput, WinnersUncheckedCreateInput>;
  };

  /**
   * Winners createMany
   */
  export type WinnersCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Winners.
     */
    data: WinnersCreateManyInput | WinnersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Winners createManyAndReturn
   */
  export type WinnersCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * The data used to create many Winners.
     */
    data: WinnersCreateManyInput | WinnersCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Winners update
   */
  export type WinnersUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * The data needed to update a Winners.
     */
    data: XOR<WinnersUpdateInput, WinnersUncheckedUpdateInput>;
    /**
     * Choose, which Winners to update.
     */
    where: WinnersWhereUniqueInput;
  };

  /**
   * Winners updateMany
   */
  export type WinnersUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Winners.
     */
    data: XOR<WinnersUpdateManyMutationInput, WinnersUncheckedUpdateManyInput>;
    /**
     * Filter which Winners to update
     */
    where?: WinnersWhereInput;
    /**
     * Limit how many Winners to update.
     */
    limit?: number;
  };

  /**
   * Winners updateManyAndReturn
   */
  export type WinnersUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * The data used to update Winners.
     */
    data: XOR<WinnersUpdateManyMutationInput, WinnersUncheckedUpdateManyInput>;
    /**
     * Filter which Winners to update
     */
    where?: WinnersWhereInput;
    /**
     * Limit how many Winners to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Winners upsert
   */
  export type WinnersUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * The filter to search for the Winners to update in case it exists.
     */
    where: WinnersWhereUniqueInput;
    /**
     * In case the Winners found by the `where` argument doesn't exist, create a new Winners with this data.
     */
    create: XOR<WinnersCreateInput, WinnersUncheckedCreateInput>;
    /**
     * In case the Winners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WinnersUpdateInput, WinnersUncheckedUpdateInput>;
  };

  /**
   * Winners delete
   */
  export type WinnersDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
    /**
     * Filter which Winners to delete.
     */
    where: WinnersWhereUniqueInput;
  };

  /**
   * Winners deleteMany
   */
  export type WinnersDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Winners to delete
     */
    where?: WinnersWhereInput;
    /**
     * Limit how many Winners to delete.
     */
    limit?: number;
  };

  /**
   * Winners without action
   */
  export type WinnersDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Winners
     */
    select?: WinnersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Winners
     */
    omit?: WinnersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WinnersInclude<ExtArgs> | null;
  };

  /**
   * Model Placement
   */

  export type AggregatePlacement = {
    _count: PlacementCountAggregateOutputType | null;
    _min: PlacementMinAggregateOutputType | null;
    _max: PlacementMaxAggregateOutputType | null;
  };

  export type PlacementMinAggregateOutputType = {
    id: string | null;
    yearId: string | null;
    studentId: string | null;
  };

  export type PlacementMaxAggregateOutputType = {
    id: string | null;
    yearId: string | null;
    studentId: string | null;
  };

  export type PlacementCountAggregateOutputType = {
    id: number;
    yearId: number;
    studentId: number;
    _all: number;
  };

  export type PlacementMinAggregateInputType = {
    id?: true;
    yearId?: true;
    studentId?: true;
  };

  export type PlacementMaxAggregateInputType = {
    id?: true;
    yearId?: true;
    studentId?: true;
  };

  export type PlacementCountAggregateInputType = {
    id?: true;
    yearId?: true;
    studentId?: true;
    _all?: true;
  };

  export type PlacementAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Placement to aggregate.
     */
    where?: PlacementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Placements to fetch.
     */
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PlacementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Placements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Placements
     **/
    _count?: true | PlacementCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PlacementMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PlacementMaxAggregateInputType;
  };

  export type GetPlacementAggregateType<T extends PlacementAggregateArgs> = {
    [P in keyof T & keyof AggregatePlacement]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacement[P]>
      : GetScalarType<T[P], AggregatePlacement[P]>;
  };

  export type PlacementGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PlacementWhereInput;
    orderBy?:
      | PlacementOrderByWithAggregationInput
      | PlacementOrderByWithAggregationInput[];
    by: PlacementScalarFieldEnum[] | PlacementScalarFieldEnum;
    having?: PlacementScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PlacementCountAggregateInputType | true;
    _min?: PlacementMinAggregateInputType;
    _max?: PlacementMaxAggregateInputType;
  };

  export type PlacementGroupByOutputType = {
    id: string;
    yearId: string;
    studentId: string;
    _count: PlacementCountAggregateOutputType | null;
    _min: PlacementMinAggregateOutputType | null;
    _max: PlacementMaxAggregateOutputType | null;
  };

  type GetPlacementGroupByPayload<T extends PlacementGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PlacementGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof PlacementGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementGroupByOutputType[P]>;
        }
      >
    >;

  export type PlacementSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      yearId?: boolean;
      studentId?: boolean;
      student?: boolean | StudentDefaultArgs<ExtArgs>;
      year?: boolean | YearDefaultArgs<ExtArgs>;
      offers?: boolean | Placement$offersArgs<ExtArgs>;
      _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["placement"]
  >;

  export type PlacementSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      yearId?: boolean;
      studentId?: boolean;
      student?: boolean | StudentDefaultArgs<ExtArgs>;
      year?: boolean | YearDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["placement"]
  >;

  export type PlacementSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      yearId?: boolean;
      studentId?: boolean;
      student?: boolean | StudentDefaultArgs<ExtArgs>;
      year?: boolean | YearDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["placement"]
  >;

  export type PlacementSelectScalar = {
    id?: boolean;
    yearId?: boolean;
    studentId?: boolean;
  };

  export type PlacementOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "yearId" | "studentId",
    ExtArgs["result"]["placement"]
  >;
  export type PlacementInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    student?: boolean | StudentDefaultArgs<ExtArgs>;
    year?: boolean | YearDefaultArgs<ExtArgs>;
    offers?: boolean | Placement$offersArgs<ExtArgs>;
    _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PlacementIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    student?: boolean | StudentDefaultArgs<ExtArgs>;
    year?: boolean | YearDefaultArgs<ExtArgs>;
  };
  export type PlacementIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    student?: boolean | StudentDefaultArgs<ExtArgs>;
    year?: boolean | YearDefaultArgs<ExtArgs>;
  };

  export type $PlacementPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Placement";
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>;
      year: Prisma.$YearPayload<ExtArgs>;
      offers: Prisma.$OfferPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        yearId: string;
        studentId: string;
      },
      ExtArgs["result"]["placement"]
    >;
    composites: {};
  };

  type PlacementGetPayload<
    S extends boolean | null | undefined | PlacementDefaultArgs,
  > = $Result.GetResult<Prisma.$PlacementPayload, S>;

  type PlacementCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PlacementFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PlacementCountAggregateInputType | true;
  };

  export interface PlacementDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Placement"];
      meta: { name: "Placement" };
    };
    /**
     * Find zero or one Placement that matches the filter.
     * @param {PlacementFindUniqueArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlacementFindUniqueArgs>(
      args: SelectSubset<T, PlacementFindUniqueArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Placement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlacementFindUniqueOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlacementFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PlacementFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Placement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlacementFindFirstArgs>(
      args?: SelectSubset<T, PlacementFindFirstArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Placement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlacementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlacementFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Placements
     * const placements = await prisma.placement.findMany()
     *
     * // Get first 10 Placements
     * const placements = await prisma.placement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const placementWithIdOnly = await prisma.placement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PlacementFindManyArgs>(
      args?: SelectSubset<T, PlacementFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Placement.
     * @param {PlacementCreateArgs} args - Arguments to create a Placement.
     * @example
     * // Create one Placement
     * const Placement = await prisma.placement.create({
     *   data: {
     *     // ... data to create a Placement
     *   }
     * })
     *
     */
    create<T extends PlacementCreateArgs>(
      args: SelectSubset<T, PlacementCreateArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Placements.
     * @param {PlacementCreateManyArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PlacementCreateManyArgs>(
      args?: SelectSubset<T, PlacementCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Placements and returns the data saved in the database.
     * @param {PlacementCreateManyAndReturnArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Placements and only return the `id`
     * const placementWithIdOnly = await prisma.placement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PlacementCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PlacementCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Placement.
     * @param {PlacementDeleteArgs} args - Arguments to delete one Placement.
     * @example
     * // Delete one Placement
     * const Placement = await prisma.placement.delete({
     *   where: {
     *     // ... filter to delete one Placement
     *   }
     * })
     *
     */
    delete<T extends PlacementDeleteArgs>(
      args: SelectSubset<T, PlacementDeleteArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Placement.
     * @param {PlacementUpdateArgs} args - Arguments to update one Placement.
     * @example
     * // Update one Placement
     * const placement = await prisma.placement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PlacementUpdateArgs>(
      args: SelectSubset<T, PlacementUpdateArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Placements.
     * @param {PlacementDeleteManyArgs} args - Arguments to filter Placements to delete.
     * @example
     * // Delete a few Placements
     * const { count } = await prisma.placement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PlacementDeleteManyArgs>(
      args?: SelectSubset<T, PlacementDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Placements
     * const placement = await prisma.placement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PlacementUpdateManyArgs>(
      args: SelectSubset<T, PlacementUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Placements and returns the data updated in the database.
     * @param {PlacementUpdateManyAndReturnArgs} args - Arguments to update many Placements.
     * @example
     * // Update many Placements
     * const placement = await prisma.placement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Placements and only return the `id`
     * const placementWithIdOnly = await prisma.placement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PlacementUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PlacementUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Placement.
     * @param {PlacementUpsertArgs} args - Arguments to update or create a Placement.
     * @example
     * // Update or create a Placement
     * const placement = await prisma.placement.upsert({
     *   create: {
     *     // ... data to create a Placement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Placement we want to update
     *   }
     * })
     */
    upsert<T extends PlacementUpsertArgs>(
      args: SelectSubset<T, PlacementUpsertArgs<ExtArgs>>,
    ): Prisma__PlacementClient<
      $Result.GetResult<
        Prisma.$PlacementPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementCountArgs} args - Arguments to filter Placements to count.
     * @example
     * // Count the number of Placements
     * const count = await prisma.placement.count({
     *   where: {
     *     // ... the filter for the Placements we want to count
     *   }
     * })
     **/
    count<T extends PlacementCountArgs>(
      args?: Subset<T, PlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PlacementCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PlacementAggregateArgs>(
      args: Subset<T, PlacementAggregateArgs>,
    ): Prisma.PrismaPromise<GetPlacementAggregateType<T>>;

    /**
     * Group by Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementGroupByArgs["orderBy"] }
        : { orderBy?: PlacementGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PlacementGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetPlacementGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Placement model
     */
    readonly fields: PlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Placement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, StudentDefaultArgs<ExtArgs>>,
    ): Prisma__StudentClient<
      | $Result.GetResult<
          Prisma.$StudentPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    year<T extends YearDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, YearDefaultArgs<ExtArgs>>,
    ): Prisma__YearClient<
      | $Result.GetResult<
          Prisma.$YearPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    offers<T extends Placement$offersArgs<ExtArgs> = {}>(
      args?: Subset<T, Placement$offersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OfferPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Placement model
   */
  interface PlacementFieldRefs {
    readonly id: FieldRef<"Placement", "String">;
    readonly yearId: FieldRef<"Placement", "String">;
    readonly studentId: FieldRef<"Placement", "String">;
  }

  // Custom InputTypes
  /**
   * Placement findUnique
   */
  export type PlacementFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput;
  };

  /**
   * Placement findUniqueOrThrow
   */
  export type PlacementFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput;
  };

  /**
   * Placement findFirst
   */
  export type PlacementFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Placements to fetch.
     */
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Placements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[];
  };

  /**
   * Placement findFirstOrThrow
   */
  export type PlacementFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Placements to fetch.
     */
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Placements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[];
  };

  /**
   * Placement findMany
   */
  export type PlacementFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Placements to fetch.
     */
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Placements.
     */
    cursor?: PlacementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Placements.
     */
    skip?: number;
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[];
  };

  /**
   * Placement create
   */
  export type PlacementCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * The data needed to create a Placement.
     */
    data: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>;
  };

  /**
   * Placement createMany
   */
  export type PlacementCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Placement createManyAndReturn
   */
  export type PlacementCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Placement update
   */
  export type PlacementUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * The data needed to update a Placement.
     */
    data: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>;
    /**
     * Choose, which Placement to update.
     */
    where: PlacementWhereUniqueInput;
  };

  /**
   * Placement updateMany
   */
  export type PlacementUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Placements.
     */
    data: XOR<
      PlacementUpdateManyMutationInput,
      PlacementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Placements to update
     */
    where?: PlacementWhereInput;
    /**
     * Limit how many Placements to update.
     */
    limit?: number;
  };

  /**
   * Placement updateManyAndReturn
   */
  export type PlacementUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * The data used to update Placements.
     */
    data: XOR<
      PlacementUpdateManyMutationInput,
      PlacementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Placements to update
     */
    where?: PlacementWhereInput;
    /**
     * Limit how many Placements to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Placement upsert
   */
  export type PlacementUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * The filter to search for the Placement to update in case it exists.
     */
    where: PlacementWhereUniqueInput;
    /**
     * In case the Placement found by the `where` argument doesn't exist, create a new Placement with this data.
     */
    create: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>;
    /**
     * In case the Placement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>;
  };

  /**
   * Placement delete
   */
  export type PlacementDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    /**
     * Filter which Placement to delete.
     */
    where: PlacementWhereUniqueInput;
  };

  /**
   * Placement deleteMany
   */
  export type PlacementDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Placements to delete
     */
    where?: PlacementWhereInput;
    /**
     * Limit how many Placements to delete.
     */
    limit?: number;
  };

  /**
   * Placement.offers
   */
  export type Placement$offersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    where?: OfferWhereInput;
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    cursor?: OfferWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[];
  };

  /**
   * Placement without action
   */
  export type PlacementDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
  };

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null;
    _min: CompanyMinAggregateOutputType | null;
    _max: CompanyMaxAggregateOutputType | null;
  };

  export type CompanyMinAggregateOutputType = {
    id: string | null;
    companyName: string | null;
    image: string | null;
  };

  export type CompanyMaxAggregateOutputType = {
    id: string | null;
    companyName: string | null;
    image: string | null;
  };

  export type CompanyCountAggregateOutputType = {
    id: number;
    companyName: number;
    image: number;
    _all: number;
  };

  export type CompanyMinAggregateInputType = {
    id?: true;
    companyName?: true;
    image?: true;
  };

  export type CompanyMaxAggregateInputType = {
    id?: true;
    companyName?: true;
    image?: true;
  };

  export type CompanyCountAggregateInputType = {
    id?: true;
    companyName?: true;
    image?: true;
    _all?: true;
  };

  export type CompanyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?:
      | CompanyOrderByWithRelationInput
      | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Companies
     **/
    _count?: true | CompanyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CompanyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CompanyMaxAggregateInputType;
  };

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>;
  };

  export type CompanyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CompanyWhereInput;
    orderBy?:
      | CompanyOrderByWithAggregationInput
      | CompanyOrderByWithAggregationInput[];
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum;
    having?: CompanyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CompanyCountAggregateInputType | true;
    _min?: CompanyMinAggregateInputType;
    _max?: CompanyMaxAggregateInputType;
  };

  export type CompanyGroupByOutputType = {
    id: string;
    companyName: string;
    image: string;
    _count: CompanyCountAggregateOutputType | null;
    _min: CompanyMinAggregateOutputType | null;
    _max: CompanyMaxAggregateOutputType | null;
  };

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CompanyGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CompanyGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>;
        }
      >
    >;

  export type CompanySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyName?: boolean;
      image?: boolean;
      offers?: boolean | Company$offersArgs<ExtArgs>;
      _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["company"]
  >;

  export type CompanySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyName?: boolean;
      image?: boolean;
    },
    ExtArgs["result"]["company"]
  >;

  export type CompanySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyName?: boolean;
      image?: boolean;
    },
    ExtArgs["result"]["company"]
  >;

  export type CompanySelectScalar = {
    id?: boolean;
    companyName?: boolean;
    image?: boolean;
  };

  export type CompanyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "companyName" | "image",
    ExtArgs["result"]["company"]
  >;
  export type CompanyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    offers?: boolean | Company$offersArgs<ExtArgs>;
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CompanyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type CompanyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $CompanyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Company";
    objects: {
      offers: Prisma.$OfferPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        companyName: string;
        image: string;
      },
      ExtArgs["result"]["company"]
    >;
    composites: {};
  };

  type CompanyGetPayload<
    S extends boolean | null | undefined | CompanyDefaultArgs,
  > = $Result.GetResult<Prisma.$CompanyPayload, S>;

  type CompanyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CompanyFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CompanyCountAggregateInputType | true;
  };

  export interface CompanyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Company"];
      meta: { name: "Company" };
    };
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     *
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     *
     */
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     *
     */
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      $Result.GetResult<
        Prisma.$CompanyPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
     **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CompanyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CompanyAggregateArgs>(
      args: Subset<T, CompanyAggregateArgs>,
    ): Prisma.PrismaPromise<GetCompanyAggregateType<T>>;

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs["orderBy"] }
        : { orderBy?: CompanyGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCompanyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Company model
     */
    readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    offers<T extends Company$offersArgs<ExtArgs> = {}>(
      args?: Subset<T, Company$offersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OfferPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", "String">;
    readonly companyName: FieldRef<"Company", "String">;
    readonly image: FieldRef<"Company", "String">;
  }

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?:
      | CompanyOrderByWithRelationInput
      | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?:
      | CompanyOrderByWithRelationInput
      | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     */
    orderBy?:
      | CompanyOrderByWithRelationInput
      | CompanyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     */
    skip?: number;
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
  };

  /**
   * Company create
   */
  export type CompanyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
  };

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Company update
   */
  export type CompanyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to update.
     */
    limit?: number;
  };

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to update.
     */
    limit?: number;
  };

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput;
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
  };

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput;
  };

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput;
    /**
     * Limit how many Companies to delete.
     */
    limit?: number;
  };

  /**
   * Company.offers
   */
  export type Company$offersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    where?: OfferWhereInput;
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    cursor?: OfferWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[];
  };

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null;
  };

  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null;
    _min: OfferMinAggregateOutputType | null;
    _max: OfferMaxAggregateOutputType | null;
  };

  export type OfferMinAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    package: string | null;
  };

  export type OfferMaxAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    package: string | null;
  };

  export type OfferCountAggregateOutputType = {
    id: number;
    companyId: number;
    package: number;
    _all: number;
  };

  export type OfferMinAggregateInputType = {
    id?: true;
    companyId?: true;
    package?: true;
  };

  export type OfferMaxAggregateInputType = {
    id?: true;
    companyId?: true;
    package?: true;
  };

  export type OfferCountAggregateInputType = {
    id?: true;
    companyId?: true;
    package?: true;
    _all?: true;
  };

  export type OfferAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Offers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Offers
     **/
    _count?: true | OfferCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OfferMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OfferMaxAggregateInputType;
  };

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
    [P in keyof T & keyof AggregateOffer]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>;
  };

  export type OfferGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OfferWhereInput;
    orderBy?:
      | OfferOrderByWithAggregationInput
      | OfferOrderByWithAggregationInput[];
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum;
    having?: OfferScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OfferCountAggregateInputType | true;
    _min?: OfferMinAggregateInputType;
    _max?: OfferMaxAggregateInputType;
  };

  export type OfferGroupByOutputType = {
    id: string;
    companyId: string;
    package: string;
    _count: OfferCountAggregateOutputType | null;
    _min: OfferMinAggregateOutputType | null;
    _max: OfferMaxAggregateOutputType | null;
  };

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OfferGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OfferGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>;
        }
      >
    >;

  export type OfferSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyId?: boolean;
      package?: boolean;
      company?: boolean | CompanyDefaultArgs<ExtArgs>;
      placements?: boolean | Offer$placementsArgs<ExtArgs>;
      _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["offer"]
  >;

  export type OfferSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyId?: boolean;
      package?: boolean;
      company?: boolean | CompanyDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["offer"]
  >;

  export type OfferSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      companyId?: boolean;
      package?: boolean;
      company?: boolean | CompanyDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["offer"]
  >;

  export type OfferSelectScalar = {
    id?: boolean;
    companyId?: boolean;
    package?: boolean;
  };

  export type OfferOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "companyId" | "package",
    ExtArgs["result"]["offer"]
  >;
  export type OfferInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>;
    placements?: boolean | Offer$placementsArgs<ExtArgs>;
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OfferIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>;
  };
  export type OfferIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>;
  };

  export type $OfferPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Offer";
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>;
      placements: Prisma.$PlacementPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        companyId: string;
        package: string;
      },
      ExtArgs["result"]["offer"]
    >;
    composites: {};
  };

  type OfferGetPayload<
    S extends boolean | null | undefined | OfferDefaultArgs,
  > = $Result.GetResult<Prisma.$OfferPayload, S>;

  type OfferCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<OfferFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: OfferCountAggregateInputType | true;
  };

  export interface OfferDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Offer"];
      meta: { name: "Offer" };
    };
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(
      args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(
      args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     *
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OfferFindManyArgs>(
      args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     *
     */
    create<T extends OfferCreateArgs>(
      args: SelectSubset<T, OfferCreateArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OfferCreateManyArgs>(
      args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     *
     */
    delete<T extends OfferDeleteArgs>(
      args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OfferUpdateArgs>(
      args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OfferDeleteManyArgs>(
      args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OfferUpdateManyArgs>(
      args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Offers and returns the data updated in the database.
     * @param {OfferUpdateManyAndReturnArgs} args - Arguments to update many Offers.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OfferUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OfferUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(
      args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>,
    ): Prisma__OfferClient<
      $Result.GetResult<
        Prisma.$OfferPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
     **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OfferCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OfferAggregateArgs>(
      args: Subset<T, OfferAggregateArgs>,
    ): Prisma.PrismaPromise<GetOfferAggregateType<T>>;

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs["orderBy"] }
        : { orderBy?: OfferGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetOfferGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Offer model
     */
    readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CompanyDefaultArgs<ExtArgs>>,
    ): Prisma__CompanyClient<
      | $Result.GetResult<
          Prisma.$CompanyPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    placements<T extends Offer$placementsArgs<ExtArgs> = {}>(
      args?: Subset<T, Offer$placementsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PlacementPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Offer model
   */
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", "String">;
    readonly companyId: FieldRef<"Offer", "String">;
    readonly package: FieldRef<"Offer", "String">;
  }

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput;
  };

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput;
  };

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Offers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[];
  };

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Offers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[];
  };

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Offers.
     */
    skip?: number;
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[];
  };

  /**
   * Offer create
   */
  export type OfferCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>;
  };

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Offer update
   */
  export type OfferUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>;
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput;
  };

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>;
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput;
    /**
     * Limit how many Offers to update.
     */
    limit?: number;
  };

  /**
   * Offer updateManyAndReturn
   */
  export type OfferUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>;
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput;
    /**
     * Limit how many Offers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput;
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>;
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>;
  };

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput;
  };

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput;
    /**
     * Limit how many Offers to delete.
     */
    limit?: number;
  };

  /**
   * Offer.placements
   */
  export type Offer$placementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    where?: PlacementWhereInput;
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    cursor?: PlacementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[];
  };

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null;
  };

  /**
   * Model Year
   */

  export type AggregateYear = {
    _count: YearCountAggregateOutputType | null;
    _min: YearMinAggregateOutputType | null;
    _max: YearMaxAggregateOutputType | null;
  };

  export type YearMinAggregateOutputType = {
    id: string | null;
    year: string | null;
  };

  export type YearMaxAggregateOutputType = {
    id: string | null;
    year: string | null;
  };

  export type YearCountAggregateOutputType = {
    id: number;
    year: number;
    companies: number;
    _all: number;
  };

  export type YearMinAggregateInputType = {
    id?: true;
    year?: true;
  };

  export type YearMaxAggregateInputType = {
    id?: true;
    year?: true;
  };

  export type YearCountAggregateInputType = {
    id?: true;
    year?: true;
    companies?: true;
    _all?: true;
  };

  export type YearAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Year to aggregate.
     */
    where?: YearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Years to fetch.
     */
    orderBy?: YearOrderByWithRelationInput | YearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: YearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Years from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Years.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Years
     **/
    _count?: true | YearCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: YearMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: YearMaxAggregateInputType;
  };

  export type GetYearAggregateType<T extends YearAggregateArgs> = {
    [P in keyof T & keyof AggregateYear]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYear[P]>
      : GetScalarType<T[P], AggregateYear[P]>;
  };

  export type YearGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: YearWhereInput;
    orderBy?:
      | YearOrderByWithAggregationInput
      | YearOrderByWithAggregationInput[];
    by: YearScalarFieldEnum[] | YearScalarFieldEnum;
    having?: YearScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: YearCountAggregateInputType | true;
    _min?: YearMinAggregateInputType;
    _max?: YearMaxAggregateInputType;
  };

  export type YearGroupByOutputType = {
    id: string;
    year: string;
    companies: string[];
    _count: YearCountAggregateOutputType | null;
    _min: YearMinAggregateOutputType | null;
    _max: YearMaxAggregateOutputType | null;
  };

  type GetYearGroupByPayload<T extends YearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof YearGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], YearGroupByOutputType[P]>
          : GetScalarType<T[P], YearGroupByOutputType[P]>;
      }
    >
  >;

  export type YearSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      companies?: boolean;
      placements?: boolean | Year$placementsArgs<ExtArgs>;
      _count?: boolean | YearCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["year"]
  >;

  export type YearSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      companies?: boolean;
    },
    ExtArgs["result"]["year"]
  >;

  export type YearSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      companies?: boolean;
    },
    ExtArgs["result"]["year"]
  >;

  export type YearSelectScalar = {
    id?: boolean;
    year?: boolean;
    companies?: boolean;
  };

  export type YearOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "year" | "companies",
    ExtArgs["result"]["year"]
  >;
  export type YearInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    placements?: boolean | Year$placementsArgs<ExtArgs>;
    _count?: boolean | YearCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type YearIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type YearIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $YearPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Year";
    objects: {
      placements: Prisma.$PlacementPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        year: string;
        companies: string[];
      },
      ExtArgs["result"]["year"]
    >;
    composites: {};
  };

  type YearGetPayload<S extends boolean | null | undefined | YearDefaultArgs> =
    $Result.GetResult<Prisma.$YearPayload, S>;

  type YearCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<YearFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: YearCountAggregateInputType | true;
  };

  export interface YearDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Year"];
      meta: { name: "Year" };
    };
    /**
     * Find zero or one Year that matches the filter.
     * @param {YearFindUniqueArgs} args - Arguments to find a Year
     * @example
     * // Get one Year
     * const year = await prisma.year.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearFindUniqueArgs>(
      args: SelectSubset<T, YearFindUniqueArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Year that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearFindUniqueOrThrowArgs} args - Arguments to find a Year
     * @example
     * // Get one Year
     * const year = await prisma.year.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearFindUniqueOrThrowArgs>(
      args: SelectSubset<T, YearFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Year that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearFindFirstArgs} args - Arguments to find a Year
     * @example
     * // Get one Year
     * const year = await prisma.year.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearFindFirstArgs>(
      args?: SelectSubset<T, YearFindFirstArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Year that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearFindFirstOrThrowArgs} args - Arguments to find a Year
     * @example
     * // Get one Year
     * const year = await prisma.year.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YearFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Years
     * const years = await prisma.year.findMany()
     *
     * // Get first 10 Years
     * const years = await prisma.year.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const yearWithIdOnly = await prisma.year.findMany({ select: { id: true } })
     *
     */
    findMany<T extends YearFindManyArgs>(
      args?: SelectSubset<T, YearFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Year.
     * @param {YearCreateArgs} args - Arguments to create a Year.
     * @example
     * // Create one Year
     * const Year = await prisma.year.create({
     *   data: {
     *     // ... data to create a Year
     *   }
     * })
     *
     */
    create<T extends YearCreateArgs>(
      args: SelectSubset<T, YearCreateArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Years.
     * @param {YearCreateManyArgs} args - Arguments to create many Years.
     * @example
     * // Create many Years
     * const year = await prisma.year.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends YearCreateManyArgs>(
      args?: SelectSubset<T, YearCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Years and returns the data saved in the database.
     * @param {YearCreateManyAndReturnArgs} args - Arguments to create many Years.
     * @example
     * // Create many Years
     * const year = await prisma.year.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Years and only return the `id`
     * const yearWithIdOnly = await prisma.year.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends YearCreateManyAndReturnArgs>(
      args?: SelectSubset<T, YearCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Year.
     * @param {YearDeleteArgs} args - Arguments to delete one Year.
     * @example
     * // Delete one Year
     * const Year = await prisma.year.delete({
     *   where: {
     *     // ... filter to delete one Year
     *   }
     * })
     *
     */
    delete<T extends YearDeleteArgs>(
      args: SelectSubset<T, YearDeleteArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Year.
     * @param {YearUpdateArgs} args - Arguments to update one Year.
     * @example
     * // Update one Year
     * const year = await prisma.year.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends YearUpdateArgs>(
      args: SelectSubset<T, YearUpdateArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Years.
     * @param {YearDeleteManyArgs} args - Arguments to filter Years to delete.
     * @example
     * // Delete a few Years
     * const { count } = await prisma.year.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends YearDeleteManyArgs>(
      args?: SelectSubset<T, YearDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Years
     * const year = await prisma.year.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends YearUpdateManyArgs>(
      args: SelectSubset<T, YearUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Years and returns the data updated in the database.
     * @param {YearUpdateManyAndReturnArgs} args - Arguments to update many Years.
     * @example
     * // Update many Years
     * const year = await prisma.year.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Years and only return the `id`
     * const yearWithIdOnly = await prisma.year.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends YearUpdateManyAndReturnArgs>(
      args: SelectSubset<T, YearUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Year.
     * @param {YearUpsertArgs} args - Arguments to update or create a Year.
     * @example
     * // Update or create a Year
     * const year = await prisma.year.upsert({
     *   create: {
     *     // ... data to create a Year
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Year we want to update
     *   }
     * })
     */
    upsert<T extends YearUpsertArgs>(
      args: SelectSubset<T, YearUpsertArgs<ExtArgs>>,
    ): Prisma__YearClient<
      $Result.GetResult<
        Prisma.$YearPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearCountArgs} args - Arguments to filter Years to count.
     * @example
     * // Count the number of Years
     * const count = await prisma.year.count({
     *   where: {
     *     // ... the filter for the Years we want to count
     *   }
     * })
     **/
    count<T extends YearCountArgs>(
      args?: Subset<T, YearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], YearCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends YearAggregateArgs>(
      args: Subset<T, YearAggregateArgs>,
    ): Prisma.PrismaPromise<GetYearAggregateType<T>>;

    /**
     * Group by Year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends YearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearGroupByArgs["orderBy"] }
        : { orderBy?: YearGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, YearGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetYearGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Year model
     */
    readonly fields: YearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Year.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    placements<T extends Year$placementsArgs<ExtArgs> = {}>(
      args?: Subset<T, Year$placementsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PlacementPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Year model
   */
  interface YearFieldRefs {
    readonly id: FieldRef<"Year", "String">;
    readonly year: FieldRef<"Year", "String">;
    readonly companies: FieldRef<"Year", "String[]">;
  }

  // Custom InputTypes
  /**
   * Year findUnique
   */
  export type YearFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter, which Year to fetch.
     */
    where: YearWhereUniqueInput;
  };

  /**
   * Year findUniqueOrThrow
   */
  export type YearFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter, which Year to fetch.
     */
    where: YearWhereUniqueInput;
  };

  /**
   * Year findFirst
   */
  export type YearFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter, which Year to fetch.
     */
    where?: YearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Years to fetch.
     */
    orderBy?: YearOrderByWithRelationInput | YearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Years.
     */
    cursor?: YearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Years from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Years.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Years.
     */
    distinct?: YearScalarFieldEnum | YearScalarFieldEnum[];
  };

  /**
   * Year findFirstOrThrow
   */
  export type YearFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter, which Year to fetch.
     */
    where?: YearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Years to fetch.
     */
    orderBy?: YearOrderByWithRelationInput | YearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Years.
     */
    cursor?: YearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Years from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Years.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Years.
     */
    distinct?: YearScalarFieldEnum | YearScalarFieldEnum[];
  };

  /**
   * Year findMany
   */
  export type YearFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter, which Years to fetch.
     */
    where?: YearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Years to fetch.
     */
    orderBy?: YearOrderByWithRelationInput | YearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Years.
     */
    cursor?: YearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Years from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Years.
     */
    skip?: number;
    distinct?: YearScalarFieldEnum | YearScalarFieldEnum[];
  };

  /**
   * Year create
   */
  export type YearCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * The data needed to create a Year.
     */
    data: XOR<YearCreateInput, YearUncheckedCreateInput>;
  };

  /**
   * Year createMany
   */
  export type YearCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Years.
     */
    data: YearCreateManyInput | YearCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Year createManyAndReturn
   */
  export type YearCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * The data used to create many Years.
     */
    data: YearCreateManyInput | YearCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Year update
   */
  export type YearUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * The data needed to update a Year.
     */
    data: XOR<YearUpdateInput, YearUncheckedUpdateInput>;
    /**
     * Choose, which Year to update.
     */
    where: YearWhereUniqueInput;
  };

  /**
   * Year updateMany
   */
  export type YearUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Years.
     */
    data: XOR<YearUpdateManyMutationInput, YearUncheckedUpdateManyInput>;
    /**
     * Filter which Years to update
     */
    where?: YearWhereInput;
    /**
     * Limit how many Years to update.
     */
    limit?: number;
  };

  /**
   * Year updateManyAndReturn
   */
  export type YearUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * The data used to update Years.
     */
    data: XOR<YearUpdateManyMutationInput, YearUncheckedUpdateManyInput>;
    /**
     * Filter which Years to update
     */
    where?: YearWhereInput;
    /**
     * Limit how many Years to update.
     */
    limit?: number;
  };

  /**
   * Year upsert
   */
  export type YearUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * The filter to search for the Year to update in case it exists.
     */
    where: YearWhereUniqueInput;
    /**
     * In case the Year found by the `where` argument doesn't exist, create a new Year with this data.
     */
    create: XOR<YearCreateInput, YearUncheckedCreateInput>;
    /**
     * In case the Year was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearUpdateInput, YearUncheckedUpdateInput>;
  };

  /**
   * Year delete
   */
  export type YearDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
    /**
     * Filter which Year to delete.
     */
    where: YearWhereUniqueInput;
  };

  /**
   * Year deleteMany
   */
  export type YearDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Years to delete
     */
    where?: YearWhereInput;
    /**
     * Limit how many Years to delete.
     */
    limit?: number;
  };

  /**
   * Year.placements
   */
  export type Year$placementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Placement
     */
    omit?: PlacementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null;
    where?: PlacementWhereInput;
    orderBy?:
      | PlacementOrderByWithRelationInput
      | PlacementOrderByWithRelationInput[];
    cursor?: PlacementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[];
  };

  /**
   * Year without action
   */
  export type YearDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Year
     */
    select?: YearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Year
     */
    omit?: YearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearInclude<ExtArgs> | null;
  };

  /**
   * Model Patents
   */

  export type AggregatePatents = {
    _count: PatentsCountAggregateOutputType | null;
    _min: PatentsMinAggregateOutputType | null;
    _max: PatentsMaxAggregateOutputType | null;
  };

  export type PatentsMinAggregateOutputType = {
    id: string | null;
    patentId: string | null;
    year: string | null;
    title: string | null;
    certificate: string | null;
  };

  export type PatentsMaxAggregateOutputType = {
    id: string | null;
    patentId: string | null;
    year: string | null;
    title: string | null;
    certificate: string | null;
  };

  export type PatentsCountAggregateOutputType = {
    id: number;
    patentId: number;
    year: number;
    title: number;
    authors: number;
    inventorsName: number;
    inventorsAddress: number;
    certificate: number;
    _all: number;
  };

  export type PatentsMinAggregateInputType = {
    id?: true;
    patentId?: true;
    year?: true;
    title?: true;
    certificate?: true;
  };

  export type PatentsMaxAggregateInputType = {
    id?: true;
    patentId?: true;
    year?: true;
    title?: true;
    certificate?: true;
  };

  export type PatentsCountAggregateInputType = {
    id?: true;
    patentId?: true;
    year?: true;
    title?: true;
    authors?: true;
    inventorsName?: true;
    inventorsAddress?: true;
    certificate?: true;
    _all?: true;
  };

  export type PatentsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Patents to aggregate.
     */
    where?: PatentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Patents to fetch.
     */
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PatentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Patents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Patents
     **/
    _count?: true | PatentsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PatentsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PatentsMaxAggregateInputType;
  };

  export type GetPatentsAggregateType<T extends PatentsAggregateArgs> = {
    [P in keyof T & keyof AggregatePatents]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatents[P]>
      : GetScalarType<T[P], AggregatePatents[P]>;
  };

  export type PatentsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PatentsWhereInput;
    orderBy?:
      | PatentsOrderByWithAggregationInput
      | PatentsOrderByWithAggregationInput[];
    by: PatentsScalarFieldEnum[] | PatentsScalarFieldEnum;
    having?: PatentsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PatentsCountAggregateInputType | true;
    _min?: PatentsMinAggregateInputType;
    _max?: PatentsMaxAggregateInputType;
  };

  export type PatentsGroupByOutputType = {
    id: string;
    patentId: string;
    year: string;
    title: string;
    authors: string[];
    inventorsName: string[];
    inventorsAddress: string[];
    certificate: string | null;
    _count: PatentsCountAggregateOutputType | null;
    _min: PatentsMinAggregateOutputType | null;
    _max: PatentsMaxAggregateOutputType | null;
  };

  type GetPatentsGroupByPayload<T extends PatentsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PatentsGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof PatentsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatentsGroupByOutputType[P]>
            : GetScalarType<T[P], PatentsGroupByOutputType[P]>;
        }
      >
    >;

  export type PatentsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      patentId?: boolean;
      year?: boolean;
      title?: boolean;
      authors?: boolean;
      inventorsName?: boolean;
      inventorsAddress?: boolean;
      certificate?: boolean;
      faculty?: boolean | Patents$facultyArgs<ExtArgs>;
      student?: boolean | Patents$studentArgs<ExtArgs>;
      _count?: boolean | PatentsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["patents"]
  >;

  export type PatentsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      patentId?: boolean;
      year?: boolean;
      title?: boolean;
      authors?: boolean;
      inventorsName?: boolean;
      inventorsAddress?: boolean;
      certificate?: boolean;
    },
    ExtArgs["result"]["patents"]
  >;

  export type PatentsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      patentId?: boolean;
      year?: boolean;
      title?: boolean;
      authors?: boolean;
      inventorsName?: boolean;
      inventorsAddress?: boolean;
      certificate?: boolean;
    },
    ExtArgs["result"]["patents"]
  >;

  export type PatentsSelectScalar = {
    id?: boolean;
    patentId?: boolean;
    year?: boolean;
    title?: boolean;
    authors?: boolean;
    inventorsName?: boolean;
    inventorsAddress?: boolean;
    certificate?: boolean;
  };

  export type PatentsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "patentId"
    | "year"
    | "title"
    | "authors"
    | "inventorsName"
    | "inventorsAddress"
    | "certificate",
    ExtArgs["result"]["patents"]
  >;
  export type PatentsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    faculty?: boolean | Patents$facultyArgs<ExtArgs>;
    student?: boolean | Patents$studentArgs<ExtArgs>;
    _count?: boolean | PatentsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PatentsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type PatentsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $PatentsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Patents";
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>[];
      student: Prisma.$StudentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        patentId: string;
        year: string;
        title: string;
        authors: string[];
        inventorsName: string[];
        inventorsAddress: string[];
        certificate: string | null;
      },
      ExtArgs["result"]["patents"]
    >;
    composites: {};
  };

  type PatentsGetPayload<
    S extends boolean | null | undefined | PatentsDefaultArgs,
  > = $Result.GetResult<Prisma.$PatentsPayload, S>;

  type PatentsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PatentsFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: PatentsCountAggregateInputType | true;
  };

  export interface PatentsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Patents"];
      meta: { name: "Patents" };
    };
    /**
     * Find zero or one Patents that matches the filter.
     * @param {PatentsFindUniqueArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatentsFindUniqueArgs>(
      args: SelectSubset<T, PatentsFindUniqueArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Patents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatentsFindUniqueOrThrowArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatentsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PatentsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Patents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindFirstArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatentsFindFirstArgs>(
      args?: SelectSubset<T, PatentsFindFirstArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Patents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindFirstOrThrowArgs} args - Arguments to find a Patents
     * @example
     * // Get one Patents
     * const patents = await prisma.patents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PatentsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Patents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patents
     * const patents = await prisma.patents.findMany()
     *
     * // Get first 10 Patents
     * const patents = await prisma.patents.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const patentsWithIdOnly = await prisma.patents.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PatentsFindManyArgs>(
      args?: SelectSubset<T, PatentsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Patents.
     * @param {PatentsCreateArgs} args - Arguments to create a Patents.
     * @example
     * // Create one Patents
     * const Patents = await prisma.patents.create({
     *   data: {
     *     // ... data to create a Patents
     *   }
     * })
     *
     */
    create<T extends PatentsCreateArgs>(
      args: SelectSubset<T, PatentsCreateArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Patents.
     * @param {PatentsCreateManyArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patents = await prisma.patents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PatentsCreateManyArgs>(
      args?: SelectSubset<T, PatentsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Patents and returns the data saved in the database.
     * @param {PatentsCreateManyAndReturnArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patents = await prisma.patents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Patents and only return the `id`
     * const patentsWithIdOnly = await prisma.patents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PatentsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PatentsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Patents.
     * @param {PatentsDeleteArgs} args - Arguments to delete one Patents.
     * @example
     * // Delete one Patents
     * const Patents = await prisma.patents.delete({
     *   where: {
     *     // ... filter to delete one Patents
     *   }
     * })
     *
     */
    delete<T extends PatentsDeleteArgs>(
      args: SelectSubset<T, PatentsDeleteArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Patents.
     * @param {PatentsUpdateArgs} args - Arguments to update one Patents.
     * @example
     * // Update one Patents
     * const patents = await prisma.patents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PatentsUpdateArgs>(
      args: SelectSubset<T, PatentsUpdateArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Patents.
     * @param {PatentsDeleteManyArgs} args - Arguments to filter Patents to delete.
     * @example
     * // Delete a few Patents
     * const { count } = await prisma.patents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PatentsDeleteManyArgs>(
      args?: SelectSubset<T, PatentsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patents
     * const patents = await prisma.patents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PatentsUpdateManyArgs>(
      args: SelectSubset<T, PatentsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Patents and returns the data updated in the database.
     * @param {PatentsUpdateManyAndReturnArgs} args - Arguments to update many Patents.
     * @example
     * // Update many Patents
     * const patents = await prisma.patents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Patents and only return the `id`
     * const patentsWithIdOnly = await prisma.patents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PatentsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PatentsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Patents.
     * @param {PatentsUpsertArgs} args - Arguments to update or create a Patents.
     * @example
     * // Update or create a Patents
     * const patents = await prisma.patents.upsert({
     *   create: {
     *     // ... data to create a Patents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patents we want to update
     *   }
     * })
     */
    upsert<T extends PatentsUpsertArgs>(
      args: SelectSubset<T, PatentsUpsertArgs<ExtArgs>>,
    ): Prisma__PatentsClient<
      $Result.GetResult<
        Prisma.$PatentsPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsCountArgs} args - Arguments to filter Patents to count.
     * @example
     * // Count the number of Patents
     * const count = await prisma.patents.count({
     *   where: {
     *     // ... the filter for the Patents we want to count
     *   }
     * })
     **/
    count<T extends PatentsCountArgs>(
      args?: Subset<T, PatentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PatentsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PatentsAggregateArgs>(
      args: Subset<T, PatentsAggregateArgs>,
    ): Prisma.PrismaPromise<GetPatentsAggregateType<T>>;

    /**
     * Group by Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PatentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatentsGroupByArgs["orderBy"] }
        : { orderBy?: PatentsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PatentsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetPatentsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Patents model
     */
    readonly fields: PatentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatentsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    faculty<T extends Patents$facultyArgs<ExtArgs> = {}>(
      args?: Subset<T, Patents$facultyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FacultyPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    student<T extends Patents$studentArgs<ExtArgs> = {}>(
      args?: Subset<T, Patents$studentArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StudentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Patents model
   */
  interface PatentsFieldRefs {
    readonly id: FieldRef<"Patents", "String">;
    readonly patentId: FieldRef<"Patents", "String">;
    readonly year: FieldRef<"Patents", "String">;
    readonly title: FieldRef<"Patents", "String">;
    readonly authors: FieldRef<"Patents", "String[]">;
    readonly inventorsName: FieldRef<"Patents", "String[]">;
    readonly inventorsAddress: FieldRef<"Patents", "String[]">;
    readonly certificate: FieldRef<"Patents", "String">;
  }

  // Custom InputTypes
  /**
   * Patents findUnique
   */
  export type PatentsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter, which Patents to fetch.
     */
    where: PatentsWhereUniqueInput;
  };

  /**
   * Patents findUniqueOrThrow
   */
  export type PatentsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter, which Patents to fetch.
     */
    where: PatentsWhereUniqueInput;
  };

  /**
   * Patents findFirst
   */
  export type PatentsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Patents to fetch.
     */
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Patents.
     */
    cursor?: PatentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Patents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[];
  };

  /**
   * Patents findFirstOrThrow
   */
  export type PatentsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Patents to fetch.
     */
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Patents.
     */
    cursor?: PatentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Patents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[];
  };

  /**
   * Patents findMany
   */
  export type PatentsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Patents to fetch.
     */
    orderBy?:
      | PatentsOrderByWithRelationInput
      | PatentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Patents.
     */
    cursor?: PatentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Patents.
     */
    skip?: number;
    distinct?: PatentsScalarFieldEnum | PatentsScalarFieldEnum[];
  };

  /**
   * Patents create
   */
  export type PatentsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * The data needed to create a Patents.
     */
    data: XOR<PatentsCreateInput, PatentsUncheckedCreateInput>;
  };

  /**
   * Patents createMany
   */
  export type PatentsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Patents.
     */
    data: PatentsCreateManyInput | PatentsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Patents createManyAndReturn
   */
  export type PatentsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * The data used to create many Patents.
     */
    data: PatentsCreateManyInput | PatentsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Patents update
   */
  export type PatentsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * The data needed to update a Patents.
     */
    data: XOR<PatentsUpdateInput, PatentsUncheckedUpdateInput>;
    /**
     * Choose, which Patents to update.
     */
    where: PatentsWhereUniqueInput;
  };

  /**
   * Patents updateMany
   */
  export type PatentsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Patents.
     */
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyInput>;
    /**
     * Filter which Patents to update
     */
    where?: PatentsWhereInput;
    /**
     * Limit how many Patents to update.
     */
    limit?: number;
  };

  /**
   * Patents updateManyAndReturn
   */
  export type PatentsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * The data used to update Patents.
     */
    data: XOR<PatentsUpdateManyMutationInput, PatentsUncheckedUpdateManyInput>;
    /**
     * Filter which Patents to update
     */
    where?: PatentsWhereInput;
    /**
     * Limit how many Patents to update.
     */
    limit?: number;
  };

  /**
   * Patents upsert
   */
  export type PatentsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * The filter to search for the Patents to update in case it exists.
     */
    where: PatentsWhereUniqueInput;
    /**
     * In case the Patents found by the `where` argument doesn't exist, create a new Patents with this data.
     */
    create: XOR<PatentsCreateInput, PatentsUncheckedCreateInput>;
    /**
     * In case the Patents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatentsUpdateInput, PatentsUncheckedUpdateInput>;
  };

  /**
   * Patents delete
   */
  export type PatentsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
    /**
     * Filter which Patents to delete.
     */
    where: PatentsWhereUniqueInput;
  };

  /**
   * Patents deleteMany
   */
  export type PatentsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Patents to delete
     */
    where?: PatentsWhereInput;
    /**
     * Limit how many Patents to delete.
     */
    limit?: number;
  };

  /**
   * Patents.faculty
   */
  export type Patents$facultyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    where?: FacultyWhereInput;
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    cursor?: FacultyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
  };

  /**
   * Patents.student
   */
  export type Patents$studentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null;
    where?: StudentWhereInput;
    orderBy?:
      | StudentOrderByWithRelationInput
      | StudentOrderByWithRelationInput[];
    cursor?: StudentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[];
  };

  /**
   * Patents without action
   */
  export type PatentsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Patents
     */
    select?: PatentsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Patents
     */
    omit?: PatentsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentsInclude<ExtArgs> | null;
  };

  /**
   * Model Publication
   */

  export type AggregatePublication = {
    _count: PublicationCountAggregateOutputType | null;
    _avg: PublicationAvgAggregateOutputType | null;
    _sum: PublicationSumAggregateOutputType | null;
    _min: PublicationMinAggregateOutputType | null;
    _max: PublicationMaxAggregateOutputType | null;
  };

  export type PublicationAvgAggregateOutputType = {
    year: number | null;
  };

  export type PublicationSumAggregateOutputType = {
    year: number | null;
  };

  export type PublicationMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    publish_date: string | null;
    publisher: string | null;
    journal: string | null;
    conference: string | null;
    link: string | null;
    ranking: string | null;
    impact_factor: string | null;
    indexed: string | null;
    publisher_conference: string | null;
    year: number | null;
  };

  export type PublicationMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    publish_date: string | null;
    publisher: string | null;
    journal: string | null;
    conference: string | null;
    link: string | null;
    ranking: string | null;
    impact_factor: string | null;
    indexed: string | null;
    publisher_conference: string | null;
    year: number | null;
  };

  export type PublicationCountAggregateOutputType = {
    id: number;
    authors: number;
    title: number;
    publish_date: number;
    publisher: number;
    journal: number;
    conference: number;
    link: number;
    ranking: number;
    impact_factor: number;
    indexed: number;
    publisher_conference: number;
    year: number;
    _all: number;
  };

  export type PublicationAvgAggregateInputType = {
    year?: true;
  };

  export type PublicationSumAggregateInputType = {
    year?: true;
  };

  export type PublicationMinAggregateInputType = {
    id?: true;
    title?: true;
    publish_date?: true;
    publisher?: true;
    journal?: true;
    conference?: true;
    link?: true;
    ranking?: true;
    impact_factor?: true;
    indexed?: true;
    publisher_conference?: true;
    year?: true;
  };

  export type PublicationMaxAggregateInputType = {
    id?: true;
    title?: true;
    publish_date?: true;
    publisher?: true;
    journal?: true;
    conference?: true;
    link?: true;
    ranking?: true;
    impact_factor?: true;
    indexed?: true;
    publisher_conference?: true;
    year?: true;
  };

  export type PublicationCountAggregateInputType = {
    id?: true;
    authors?: true;
    title?: true;
    publish_date?: true;
    publisher?: true;
    journal?: true;
    conference?: true;
    link?: true;
    ranking?: true;
    impact_factor?: true;
    indexed?: true;
    publisher_conference?: true;
    year?: true;
    _all?: true;
  };

  export type PublicationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Publication to aggregate.
     */
    where?: PublicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Publications to fetch.
     */
    orderBy?:
      | PublicationOrderByWithRelationInput
      | PublicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PublicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Publications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Publications
     **/
    _count?: true | PublicationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PublicationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PublicationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PublicationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PublicationMaxAggregateInputType;
  };

  export type GetPublicationAggregateType<T extends PublicationAggregateArgs> =
    {
      [P in keyof T & keyof AggregatePublication]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregatePublication[P]>
        : GetScalarType<T[P], AggregatePublication[P]>;
    };

  export type PublicationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PublicationWhereInput;
    orderBy?:
      | PublicationOrderByWithAggregationInput
      | PublicationOrderByWithAggregationInput[];
    by: PublicationScalarFieldEnum[] | PublicationScalarFieldEnum;
    having?: PublicationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PublicationCountAggregateInputType | true;
    _avg?: PublicationAvgAggregateInputType;
    _sum?: PublicationSumAggregateInputType;
    _min?: PublicationMinAggregateInputType;
    _max?: PublicationMaxAggregateInputType;
  };

  export type PublicationGroupByOutputType = {
    id: string;
    authors: string[];
    title: string;
    publish_date: string;
    publisher: string | null;
    journal: string | null;
    conference: string | null;
    link: string;
    ranking: string | null;
    impact_factor: string | null;
    indexed: string;
    publisher_conference: string | null;
    year: number;
    _count: PublicationCountAggregateOutputType | null;
    _avg: PublicationAvgAggregateOutputType | null;
    _sum: PublicationSumAggregateOutputType | null;
    _min: PublicationMinAggregateOutputType | null;
    _max: PublicationMaxAggregateOutputType | null;
  };

  type GetPublicationGroupByPayload<T extends PublicationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PublicationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof PublicationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationGroupByOutputType[P]>;
        }
      >
    >;

  export type PublicationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      authors?: boolean;
      title?: boolean;
      publish_date?: boolean;
      publisher?: boolean;
      journal?: boolean;
      conference?: boolean;
      link?: boolean;
      ranking?: boolean;
      impact_factor?: boolean;
      indexed?: boolean;
      publisher_conference?: boolean;
      year?: boolean;
      faculty?: boolean | Publication$facultyArgs<ExtArgs>;
      _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["publication"]
  >;

  export type PublicationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      authors?: boolean;
      title?: boolean;
      publish_date?: boolean;
      publisher?: boolean;
      journal?: boolean;
      conference?: boolean;
      link?: boolean;
      ranking?: boolean;
      impact_factor?: boolean;
      indexed?: boolean;
      publisher_conference?: boolean;
      year?: boolean;
    },
    ExtArgs["result"]["publication"]
  >;

  export type PublicationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      authors?: boolean;
      title?: boolean;
      publish_date?: boolean;
      publisher?: boolean;
      journal?: boolean;
      conference?: boolean;
      link?: boolean;
      ranking?: boolean;
      impact_factor?: boolean;
      indexed?: boolean;
      publisher_conference?: boolean;
      year?: boolean;
    },
    ExtArgs["result"]["publication"]
  >;

  export type PublicationSelectScalar = {
    id?: boolean;
    authors?: boolean;
    title?: boolean;
    publish_date?: boolean;
    publisher?: boolean;
    journal?: boolean;
    conference?: boolean;
    link?: boolean;
    ranking?: boolean;
    impact_factor?: boolean;
    indexed?: boolean;
    publisher_conference?: boolean;
    year?: boolean;
  };

  export type PublicationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "authors"
    | "title"
    | "publish_date"
    | "publisher"
    | "journal"
    | "conference"
    | "link"
    | "ranking"
    | "impact_factor"
    | "indexed"
    | "publisher_conference"
    | "year",
    ExtArgs["result"]["publication"]
  >;
  export type PublicationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    faculty?: boolean | Publication$facultyArgs<ExtArgs>;
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PublicationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type PublicationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $PublicationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Publication";
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        authors: string[];
        title: string;
        publish_date: string;
        publisher: string | null;
        journal: string | null;
        conference: string | null;
        link: string;
        ranking: string | null;
        impact_factor: string | null;
        indexed: string;
        publisher_conference: string | null;
        year: number;
      },
      ExtArgs["result"]["publication"]
    >;
    composites: {};
  };

  type PublicationGetPayload<
    S extends boolean | null | undefined | PublicationDefaultArgs,
  > = $Result.GetResult<Prisma.$PublicationPayload, S>;

  type PublicationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PublicationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PublicationCountAggregateInputType | true;
  };

  export interface PublicationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Publication"];
      meta: { name: "Publication" };
    };
    /**
     * Find zero or one Publication that matches the filter.
     * @param {PublicationFindUniqueArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationFindUniqueArgs>(
      args: SelectSubset<T, PublicationFindUniqueArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Publication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicationFindUniqueOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PublicationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationFindFirstArgs>(
      args?: SelectSubset<T, PublicationFindFirstArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PublicationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publication.findMany()
     *
     * // Get first 10 Publications
     * const publications = await prisma.publication.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const publicationWithIdOnly = await prisma.publication.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PublicationFindManyArgs>(
      args?: SelectSubset<T, PublicationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Publication.
     * @param {PublicationCreateArgs} args - Arguments to create a Publication.
     * @example
     * // Create one Publication
     * const Publication = await prisma.publication.create({
     *   data: {
     *     // ... data to create a Publication
     *   }
     * })
     *
     */
    create<T extends PublicationCreateArgs>(
      args: SelectSubset<T, PublicationCreateArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Publications.
     * @param {PublicationCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PublicationCreateManyArgs>(
      args?: SelectSubset<T, PublicationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {PublicationCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Publications and only return the `id`
     * const publicationWithIdOnly = await prisma.publication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PublicationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PublicationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Publication.
     * @param {PublicationDeleteArgs} args - Arguments to delete one Publication.
     * @example
     * // Delete one Publication
     * const Publication = await prisma.publication.delete({
     *   where: {
     *     // ... filter to delete one Publication
     *   }
     * })
     *
     */
    delete<T extends PublicationDeleteArgs>(
      args: SelectSubset<T, PublicationDeleteArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Publication.
     * @param {PublicationUpdateArgs} args - Arguments to update one Publication.
     * @example
     * // Update one Publication
     * const publication = await prisma.publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PublicationUpdateArgs>(
      args: SelectSubset<T, PublicationUpdateArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Publications.
     * @param {PublicationDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PublicationDeleteManyArgs>(
      args?: SelectSubset<T, PublicationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PublicationUpdateManyArgs>(
      args: SelectSubset<T, PublicationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Publications and returns the data updated in the database.
     * @param {PublicationUpdateManyAndReturnArgs} args - Arguments to update many Publications.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Publications and only return the `id`
     * const publicationWithIdOnly = await prisma.publication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PublicationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PublicationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Publication.
     * @param {PublicationUpsertArgs} args - Arguments to update or create a Publication.
     * @example
     * // Update or create a Publication
     * const publication = await prisma.publication.upsert({
     *   create: {
     *     // ... data to create a Publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication we want to update
     *   }
     * })
     */
    upsert<T extends PublicationUpsertArgs>(
      args: SelectSubset<T, PublicationUpsertArgs<ExtArgs>>,
    ): Prisma__PublicationClient<
      $Result.GetResult<
        Prisma.$PublicationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publication.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
     **/
    count<T extends PublicationCountArgs>(
      args?: Subset<T, PublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PublicationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PublicationAggregateArgs>(
      args: Subset<T, PublicationAggregateArgs>,
    ): Prisma.PrismaPromise<GetPublicationAggregateType<T>>;

    /**
     * Group by Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationGroupByArgs["orderBy"] }
        : { orderBy?: PublicationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PublicationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetPublicationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Publication model
     */
    readonly fields: PublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    faculty<T extends Publication$facultyArgs<ExtArgs> = {}>(
      args?: Subset<T, Publication$facultyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FacultyPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Publication model
   */
  interface PublicationFieldRefs {
    readonly id: FieldRef<"Publication", "String">;
    readonly authors: FieldRef<"Publication", "String[]">;
    readonly title: FieldRef<"Publication", "String">;
    readonly publish_date: FieldRef<"Publication", "String">;
    readonly publisher: FieldRef<"Publication", "String">;
    readonly journal: FieldRef<"Publication", "String">;
    readonly conference: FieldRef<"Publication", "String">;
    readonly link: FieldRef<"Publication", "String">;
    readonly ranking: FieldRef<"Publication", "String">;
    readonly impact_factor: FieldRef<"Publication", "String">;
    readonly indexed: FieldRef<"Publication", "String">;
    readonly publisher_conference: FieldRef<"Publication", "String">;
    readonly year: FieldRef<"Publication", "Int">;
  }

  // Custom InputTypes
  /**
   * Publication findUnique
   */
  export type PublicationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput;
  };

  /**
   * Publication findUniqueOrThrow
   */
  export type PublicationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput;
  };

  /**
   * Publication findFirst
   */
  export type PublicationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Publications to fetch.
     */
    orderBy?:
      | PublicationOrderByWithRelationInput
      | PublicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Publications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[];
  };

  /**
   * Publication findFirstOrThrow
   */
  export type PublicationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Publications to fetch.
     */
    orderBy?:
      | PublicationOrderByWithRelationInput
      | PublicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Publications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[];
  };

  /**
   * Publication findMany
   */
  export type PublicationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Publications to fetch.
     */
    orderBy?:
      | PublicationOrderByWithRelationInput
      | PublicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Publications.
     */
    cursor?: PublicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Publications.
     */
    skip?: number;
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[];
  };

  /**
   * Publication create
   */
  export type PublicationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Publication.
     */
    data: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>;
  };

  /**
   * Publication createMany
   */
  export type PublicationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Publication createManyAndReturn
   */
  export type PublicationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Publication update
   */
  export type PublicationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Publication.
     */
    data: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>;
    /**
     * Choose, which Publication to update.
     */
    where: PublicationWhereUniqueInput;
  };

  /**
   * Publication updateMany
   */
  export type PublicationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Publications.
     */
    data: XOR<
      PublicationUpdateManyMutationInput,
      PublicationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput;
    /**
     * Limit how many Publications to update.
     */
    limit?: number;
  };

  /**
   * Publication updateManyAndReturn
   */
  export type PublicationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * The data used to update Publications.
     */
    data: XOR<
      PublicationUpdateManyMutationInput,
      PublicationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput;
    /**
     * Limit how many Publications to update.
     */
    limit?: number;
  };

  /**
   * Publication upsert
   */
  export type PublicationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Publication to update in case it exists.
     */
    where: PublicationWhereUniqueInput;
    /**
     * In case the Publication found by the `where` argument doesn't exist, create a new Publication with this data.
     */
    create: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>;
    /**
     * In case the Publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>;
  };

  /**
   * Publication delete
   */
  export type PublicationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
    /**
     * Filter which Publication to delete.
     */
    where: PublicationWhereUniqueInput;
  };

  /**
   * Publication deleteMany
   */
  export type PublicationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationWhereInput;
    /**
     * Limit how many Publications to delete.
     */
    limit?: number;
  };

  /**
   * Publication.faculty
   */
  export type Publication$facultyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null;
    where?: FacultyWhereInput;
    orderBy?:
      | FacultyOrderByWithRelationInput
      | FacultyOrderByWithRelationInput[];
    cursor?: FacultyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
  };

  /**
   * Publication without action
   */
  export type PublicationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadCommitted: "ReadCommitted";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    emailVerified: "emailVerified";
    image: "image";
    bio: "bio";
    phone: "phone";
    username: "username";
    usn: "usn";
    lightTheme: "lightTheme";
    darkTheme: "darkTheme";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    displayName: "displayName";
    college: "college";
    role: "role";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    userId: "userId";
    type: "type";
    provider: "provider";
    providerAccountId: "providerAccountId";
    refresh_token: "refresh_token";
    access_token: "access_token";
    expires_at: "expires_at";
    token_type: "token_type";
    scope: "scope";
    id_token: "id_token";
    session_state: "session_state";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    sessionToken: "sessionToken";
    userId: "userId";
    expires: "expires";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const StudentScalarFieldEnum: {
    id: "id";
    image: "image";
    userId: "userId";
  };

  export type StudentScalarFieldEnum =
    (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum];

  export const CoreScalarFieldEnum: {
    id: "id";
    year: "year";
    userId: "userId";
    image: "image";
    order: "order";
    post: "post";
    quote: "quote";
  };

  export type CoreScalarFieldEnum =
    (typeof CoreScalarFieldEnum)[keyof typeof CoreScalarFieldEnum];

  export const FacultyScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    designation: "designation";
    image: "image";
    about: "about";
    order: "order";
    published: "published";
    designation2: "designation2";
  };

  export type FacultyScalarFieldEnum =
    (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum];

  export const EventScalarFieldEnum: {
    id: "id";
    title: "title";
    description: "description";
    image: "image";
    date: "date";
    time: "time";
    reportLink: "reportLink";
    venue: "venue";
    guests: "guests";
    published: "published";
    type: "type";
    category: "category";
    maxTeamSize: "maxTeamSize";
    minTeamSize: "minTeamSize";
    brief: "brief";
    entryFee: "entryFee";
    qr: "qr";
    registrationsAvailable: "registrationsAvailable";
    endDate: "endDate";
    maxTeams: "maxTeams";
    notification: "notification";
  };

  export type EventScalarFieldEnum =
    (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

  export const LinksScalarFieldEnum: {
    id: "id";
    instagram: "instagram";
    linkedin: "linkedin";
    github: "github";
    userId: "userId";
    twitter: "twitter";
    order: "order";
    custom: "custom";
  };

  export type LinksScalarFieldEnum =
    (typeof LinksScalarFieldEnum)[keyof typeof LinksScalarFieldEnum];

  export const TeamScalarFieldEnum: {
    id: "id";
    attended: "attended";
    eventId: "eventId";
    name: "name";
    leaderId: "leaderId";
    transactionId: "transactionId";
    isConfirmed: "isConfirmed";
  };

  export type TeamScalarFieldEnum =
    (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

  export const WinnersScalarFieldEnum: {
    id: "id";
    teamId: "teamId";
    eventId: "eventId";
    position: "position";
  };

  export type WinnersScalarFieldEnum =
    (typeof WinnersScalarFieldEnum)[keyof typeof WinnersScalarFieldEnum];

  export const PlacementScalarFieldEnum: {
    id: "id";
    yearId: "yearId";
    studentId: "studentId";
  };

  export type PlacementScalarFieldEnum =
    (typeof PlacementScalarFieldEnum)[keyof typeof PlacementScalarFieldEnum];

  export const CompanyScalarFieldEnum: {
    id: "id";
    companyName: "companyName";
    image: "image";
  };

  export type CompanyScalarFieldEnum =
    (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum];

  export const OfferScalarFieldEnum: {
    id: "id";
    companyId: "companyId";
    package: "package";
  };

  export type OfferScalarFieldEnum =
    (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum];

  export const YearScalarFieldEnum: {
    id: "id";
    year: "year";
    companies: "companies";
  };

  export type YearScalarFieldEnum =
    (typeof YearScalarFieldEnum)[keyof typeof YearScalarFieldEnum];

  export const PatentsScalarFieldEnum: {
    id: "id";
    patentId: "patentId";
    year: "year";
    title: "title";
    authors: "authors";
    inventorsName: "inventorsName";
    inventorsAddress: "inventorsAddress";
    certificate: "certificate";
  };

  export type PatentsScalarFieldEnum =
    (typeof PatentsScalarFieldEnum)[keyof typeof PatentsScalarFieldEnum];

  export const PublicationScalarFieldEnum: {
    id: "id";
    authors: "authors";
    title: "title";
    publish_date: "publish_date";
    publisher: "publisher";
    journal: "journal";
    conference: "conference";
    link: "link";
    ranking: "ranking";
    impact_factor: "impact_factor";
    indexed: "indexed";
    publisher_conference: "publisher_conference";
    year: "year";
  };

  export type PublicationScalarFieldEnum =
    (typeof PublicationScalarFieldEnum)[keyof typeof PublicationScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Role"
  >;

  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Role[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventType"
  >;

  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventType[]"
  >;

  /**
   * Reference to a field of type 'EventCategory'
   */
  export type EnumEventCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventCategory"
  >;

  /**
   * Reference to a field of type 'EventCategory[]'
   */
  export type ListEnumEventCategoryFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "EventCategory[]">;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "QueryMode"
  >;

  /**
   * Reference to a field of type 'WinnerType'
   */
  export type EnumWinnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "WinnerType"
  >;

  /**
   * Reference to a field of type 'WinnerType[]'
   */
  export type ListEnumWinnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "WinnerType[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    email?: StringFilter<"User"> | string;
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
    image?: StringNullableFilter<"User"> | string | null;
    bio?: StringNullableFilter<"User"> | string | null;
    phone?: StringNullableFilter<"User"> | string | null;
    username?: StringNullableFilter<"User"> | string | null;
    usn?: StringNullableFilter<"User"> | string | null;
    lightTheme?: StringNullableFilter<"User"> | string | null;
    darkTheme?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    displayName?: StringNullableFilter<"User"> | string | null;
    college?: StringNullableFilter<"User"> | string | null;
    role?: EnumRoleFilter<"User"> | $Enums.Role;
    accounts?: AccountListRelationFilter;
    Core?: CoreListRelationFilter;
    links?: XOR<LinksNullableScalarRelationFilter, LinksWhereInput> | null;
    sessions?: SessionListRelationFilter;
    Student?: XOR<
      StudentNullableScalarRelationFilter,
      StudentWhereInput
    > | null;
    organizers?: EventListRelationFilter;
    Team?: TeamListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    usn?: SortOrderInput | SortOrder;
    lightTheme?: SortOrderInput | SortOrder;
    darkTheme?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    displayName?: SortOrderInput | SortOrder;
    college?: SortOrderInput | SortOrder;
    role?: SortOrder;
    accounts?: AccountOrderByRelationAggregateInput;
    Core?: CoreOrderByRelationAggregateInput;
    links?: LinksOrderByWithRelationInput;
    sessions?: SessionOrderByRelationAggregateInput;
    Student?: StudentOrderByWithRelationInput;
    organizers?: EventOrderByRelationAggregateInput;
    Team?: TeamOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
      image?: StringNullableFilter<"User"> | string | null;
      bio?: StringNullableFilter<"User"> | string | null;
      phone?: StringNullableFilter<"User"> | string | null;
      username?: StringNullableFilter<"User"> | string | null;
      usn?: StringNullableFilter<"User"> | string | null;
      lightTheme?: StringNullableFilter<"User"> | string | null;
      darkTheme?: StringNullableFilter<"User"> | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      displayName?: StringNullableFilter<"User"> | string | null;
      college?: StringNullableFilter<"User"> | string | null;
      role?: EnumRoleFilter<"User"> | $Enums.Role;
      accounts?: AccountListRelationFilter;
      Core?: CoreListRelationFilter;
      links?: XOR<LinksNullableScalarRelationFilter, LinksWhereInput> | null;
      sessions?: SessionListRelationFilter;
      Student?: XOR<
        StudentNullableScalarRelationFilter,
        StudentWhereInput
      > | null;
      organizers?: EventListRelationFilter;
      Team?: TeamListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    usn?: SortOrderInput | SortOrder;
    lightTheme?: SortOrderInput | SortOrder;
    darkTheme?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    displayName?: SortOrderInput | SortOrder;
    college?: SortOrderInput | SortOrder;
    role?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    email?: StringWithAggregatesFilter<"User"> | string;
    emailVerified?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    image?: StringNullableWithAggregatesFilter<"User"> | string | null;
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null;
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null;
    username?: StringNullableWithAggregatesFilter<"User"> | string | null;
    usn?: StringNullableWithAggregatesFilter<"User"> | string | null;
    lightTheme?: StringNullableWithAggregatesFilter<"User"> | string | null;
    darkTheme?: StringNullableWithAggregatesFilter<"User"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null;
    college?: StringNullableWithAggregatesFilter<"User"> | string | null;
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    createdAt?: DateTimeFilter<"Account"> | Date | string;
    updatedAt?: DateTimeFilter<"Account"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<"Account"> | string;
      type?: StringFilter<"Account"> | string;
      provider?: StringFilter<"Account"> | string;
      providerAccountId?: StringFilter<"Account"> | string;
      refresh_token?: StringNullableFilter<"Account"> | string | null;
      access_token?: StringNullableFilter<"Account"> | string | null;
      expires_at?: IntNullableFilter<"Account"> | number | null;
      token_type?: StringNullableFilter<"Account"> | string | null;
      scope?: StringNullableFilter<"Account"> | string | null;
      id_token?: StringNullableFilter<"Account"> | string | null;
      session_state?: StringNullableFilter<"Account"> | string | null;
      createdAt?: DateTimeFilter<"Account"> | Date | string;
      updatedAt?: DateTimeFilter<"Account"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "provider_providerAccountId"
  >;

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<"Account"> | string;
    type?: StringWithAggregatesFilter<"Account"> | string;
    provider?: StringWithAggregatesFilter<"Account"> | string;
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string;
    refresh_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    access_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null;
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    session_state?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    createdAt?: DateTimeFilter<"Session"> | Date | string;
    updatedAt?: DateTimeFilter<"Session"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<"Session"> | string;
      expires?: DateTimeFilter<"Session"> | Date | string;
      createdAt?: DateTimeFilter<"Session"> | Date | string;
      updatedAt?: DateTimeFilter<"Session"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "sessionToken"
  >;

  export type SessionOrderByWithAggregationInput = {
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    sessionToken?: StringWithAggregatesFilter<"Session"> | string;
    userId?: StringWithAggregatesFilter<"Session"> | string;
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
  };

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[];
    OR?: StudentWhereInput[];
    NOT?: StudentWhereInput | StudentWhereInput[];
    id?: StringFilter<"Student"> | string;
    image?: StringFilter<"Student"> | string;
    userId?: StringFilter<"Student"> | string;
    placement?: XOR<
      PlacementNullableScalarRelationFilter,
      PlacementWhereInput
    > | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    patents?: PatentsListRelationFilter;
  };

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder;
    image?: SortOrder;
    userId?: SortOrder;
    placement?: PlacementOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    patents?: PatentsOrderByRelationAggregateInput;
  };

  export type StudentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: StudentWhereInput | StudentWhereInput[];
      OR?: StudentWhereInput[];
      NOT?: StudentWhereInput | StudentWhereInput[];
      image?: StringFilter<"Student"> | string;
      placement?: XOR<
        PlacementNullableScalarRelationFilter,
        PlacementWhereInput
      > | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      patents?: PatentsListRelationFilter;
    },
    "id" | "userId"
  >;

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder;
    image?: SortOrder;
    userId?: SortOrder;
    _count?: StudentCountOrderByAggregateInput;
    _max?: StudentMaxOrderByAggregateInput;
    _min?: StudentMinOrderByAggregateInput;
  };

  export type StudentScalarWhereWithAggregatesInput = {
    AND?:
      | StudentScalarWhereWithAggregatesInput
      | StudentScalarWhereWithAggregatesInput[];
    OR?: StudentScalarWhereWithAggregatesInput[];
    NOT?:
      | StudentScalarWhereWithAggregatesInput
      | StudentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Student"> | string;
    image?: StringWithAggregatesFilter<"Student"> | string;
    userId?: StringWithAggregatesFilter<"Student"> | string;
  };

  export type CoreWhereInput = {
    AND?: CoreWhereInput | CoreWhereInput[];
    OR?: CoreWhereInput[];
    NOT?: CoreWhereInput | CoreWhereInput[];
    id?: StringFilter<"Core"> | string;
    year?: StringFilter<"Core"> | string;
    userId?: StringFilter<"Core"> | string;
    image?: StringFilter<"Core"> | string;
    order?: IntFilter<"Core"> | number;
    post?: StringFilter<"Core"> | string;
    quote?: StringNullableFilter<"Core"> | string | null;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type CoreOrderByWithRelationInput = {
    id?: SortOrder;
    year?: SortOrder;
    userId?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    post?: SortOrder;
    quote?: SortOrderInput | SortOrder;
    User?: UserOrderByWithRelationInput;
  };

  export type CoreWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CoreWhereInput | CoreWhereInput[];
      OR?: CoreWhereInput[];
      NOT?: CoreWhereInput | CoreWhereInput[];
      year?: StringFilter<"Core"> | string;
      userId?: StringFilter<"Core"> | string;
      image?: StringFilter<"Core"> | string;
      order?: IntFilter<"Core"> | number;
      post?: StringFilter<"Core"> | string;
      quote?: StringNullableFilter<"Core"> | string | null;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type CoreOrderByWithAggregationInput = {
    id?: SortOrder;
    year?: SortOrder;
    userId?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    post?: SortOrder;
    quote?: SortOrderInput | SortOrder;
    _count?: CoreCountOrderByAggregateInput;
    _avg?: CoreAvgOrderByAggregateInput;
    _max?: CoreMaxOrderByAggregateInput;
    _min?: CoreMinOrderByAggregateInput;
    _sum?: CoreSumOrderByAggregateInput;
  };

  export type CoreScalarWhereWithAggregatesInput = {
    AND?:
      | CoreScalarWhereWithAggregatesInput
      | CoreScalarWhereWithAggregatesInput[];
    OR?: CoreScalarWhereWithAggregatesInput[];
    NOT?:
      | CoreScalarWhereWithAggregatesInput
      | CoreScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Core"> | string;
    year?: StringWithAggregatesFilter<"Core"> | string;
    userId?: StringWithAggregatesFilter<"Core"> | string;
    image?: StringWithAggregatesFilter<"Core"> | string;
    order?: IntWithAggregatesFilter<"Core"> | number;
    post?: StringWithAggregatesFilter<"Core"> | string;
    quote?: StringNullableWithAggregatesFilter<"Core"> | string | null;
  };

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[];
    OR?: FacultyWhereInput[];
    NOT?: FacultyWhereInput | FacultyWhereInput[];
    id?: StringFilter<"Faculty"> | string;
    name?: StringFilter<"Faculty"> | string;
    email?: StringFilter<"Faculty"> | string;
    designation?: StringFilter<"Faculty"> | string;
    image?: StringFilter<"Faculty"> | string;
    about?: StringNullableListFilter<"Faculty">;
    order?: IntFilter<"Faculty"> | number;
    published?: BoolFilter<"Faculty"> | boolean;
    designation2?: StringNullableFilter<"Faculty"> | string | null;
    patents?: PatentsListRelationFilter;
    publications?: PublicationListRelationFilter;
  };

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    designation?: SortOrder;
    image?: SortOrder;
    about?: SortOrder;
    order?: SortOrder;
    published?: SortOrder;
    designation2?: SortOrderInput | SortOrder;
    patents?: PatentsOrderByRelationAggregateInput;
    publications?: PublicationOrderByRelationAggregateInput;
  };

  export type FacultyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      order?: number;
      AND?: FacultyWhereInput | FacultyWhereInput[];
      OR?: FacultyWhereInput[];
      NOT?: FacultyWhereInput | FacultyWhereInput[];
      name?: StringFilter<"Faculty"> | string;
      email?: StringFilter<"Faculty"> | string;
      designation?: StringFilter<"Faculty"> | string;
      image?: StringFilter<"Faculty"> | string;
      about?: StringNullableListFilter<"Faculty">;
      published?: BoolFilter<"Faculty"> | boolean;
      designation2?: StringNullableFilter<"Faculty"> | string | null;
      patents?: PatentsListRelationFilter;
      publications?: PublicationListRelationFilter;
    },
    "id" | "order"
  >;

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    designation?: SortOrder;
    image?: SortOrder;
    about?: SortOrder;
    order?: SortOrder;
    published?: SortOrder;
    designation2?: SortOrderInput | SortOrder;
    _count?: FacultyCountOrderByAggregateInput;
    _avg?: FacultyAvgOrderByAggregateInput;
    _max?: FacultyMaxOrderByAggregateInput;
    _min?: FacultyMinOrderByAggregateInput;
    _sum?: FacultySumOrderByAggregateInput;
  };

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?:
      | FacultyScalarWhereWithAggregatesInput
      | FacultyScalarWhereWithAggregatesInput[];
    OR?: FacultyScalarWhereWithAggregatesInput[];
    NOT?:
      | FacultyScalarWhereWithAggregatesInput
      | FacultyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Faculty"> | string;
    name?: StringWithAggregatesFilter<"Faculty"> | string;
    email?: StringWithAggregatesFilter<"Faculty"> | string;
    designation?: StringWithAggregatesFilter<"Faculty"> | string;
    image?: StringWithAggregatesFilter<"Faculty"> | string;
    about?: StringNullableListFilter<"Faculty">;
    order?: IntWithAggregatesFilter<"Faculty"> | number;
    published?: BoolWithAggregatesFilter<"Faculty"> | boolean;
    designation2?:
      | StringNullableWithAggregatesFilter<"Faculty">
      | string
      | null;
  };

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[];
    OR?: EventWhereInput[];
    NOT?: EventWhereInput | EventWhereInput[];
    id?: StringFilter<"Event"> | string;
    title?: StringFilter<"Event"> | string;
    description?: StringNullableFilter<"Event"> | string | null;
    image?: StringFilter<"Event"> | string;
    date?: DateTimeFilter<"Event"> | Date | string;
    time?: StringNullableFilter<"Event"> | string | null;
    reportLink?: StringNullableFilter<"Event"> | string | null;
    venue?: StringNullableFilter<"Event"> | string | null;
    guests?: StringNullableListFilter<"Event">;
    published?: BoolFilter<"Event"> | boolean;
    type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
    category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory;
    maxTeamSize?: IntFilter<"Event"> | number;
    minTeamSize?: IntFilter<"Event"> | number;
    brief?: StringNullableFilter<"Event"> | string | null;
    entryFee?: StringNullableFilter<"Event"> | string | null;
    qr?: StringNullableFilter<"Event"> | string | null;
    registrationsAvailable?: BoolFilter<"Event"> | boolean;
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null;
    maxTeams?: IntNullableFilter<"Event"> | number | null;
    notification?: StringNullableFilter<"Event"> | string | null;
    participants?: TeamListRelationFilter;
    winners?: WinnersListRelationFilter;
    organizers?: UserListRelationFilter;
  };

  export type EventOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    image?: SortOrder;
    date?: SortOrder;
    time?: SortOrderInput | SortOrder;
    reportLink?: SortOrderInput | SortOrder;
    venue?: SortOrderInput | SortOrder;
    guests?: SortOrder;
    published?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    brief?: SortOrderInput | SortOrder;
    entryFee?: SortOrderInput | SortOrder;
    qr?: SortOrderInput | SortOrder;
    registrationsAvailable?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    maxTeams?: SortOrderInput | SortOrder;
    notification?: SortOrderInput | SortOrder;
    participants?: TeamOrderByRelationAggregateInput;
    winners?: WinnersOrderByRelationAggregateInput;
    organizers?: UserOrderByRelationAggregateInput;
  };

  export type EventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: EventWhereInput | EventWhereInput[];
      OR?: EventWhereInput[];
      NOT?: EventWhereInput | EventWhereInput[];
      title?: StringFilter<"Event"> | string;
      description?: StringNullableFilter<"Event"> | string | null;
      image?: StringFilter<"Event"> | string;
      date?: DateTimeFilter<"Event"> | Date | string;
      time?: StringNullableFilter<"Event"> | string | null;
      reportLink?: StringNullableFilter<"Event"> | string | null;
      venue?: StringNullableFilter<"Event"> | string | null;
      guests?: StringNullableListFilter<"Event">;
      published?: BoolFilter<"Event"> | boolean;
      type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
      category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory;
      maxTeamSize?: IntFilter<"Event"> | number;
      minTeamSize?: IntFilter<"Event"> | number;
      brief?: StringNullableFilter<"Event"> | string | null;
      entryFee?: StringNullableFilter<"Event"> | string | null;
      qr?: StringNullableFilter<"Event"> | string | null;
      registrationsAvailable?: BoolFilter<"Event"> | boolean;
      endDate?: DateTimeNullableFilter<"Event"> | Date | string | null;
      maxTeams?: IntNullableFilter<"Event"> | number | null;
      notification?: StringNullableFilter<"Event"> | string | null;
      participants?: TeamListRelationFilter;
      winners?: WinnersListRelationFilter;
      organizers?: UserListRelationFilter;
    },
    "id"
  >;

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    image?: SortOrder;
    date?: SortOrder;
    time?: SortOrderInput | SortOrder;
    reportLink?: SortOrderInput | SortOrder;
    venue?: SortOrderInput | SortOrder;
    guests?: SortOrder;
    published?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    brief?: SortOrderInput | SortOrder;
    entryFee?: SortOrderInput | SortOrder;
    qr?: SortOrderInput | SortOrder;
    registrationsAvailable?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    maxTeams?: SortOrderInput | SortOrder;
    notification?: SortOrderInput | SortOrder;
    _count?: EventCountOrderByAggregateInput;
    _avg?: EventAvgOrderByAggregateInput;
    _max?: EventMaxOrderByAggregateInput;
    _min?: EventMinOrderByAggregateInput;
    _sum?: EventSumOrderByAggregateInput;
  };

  export type EventScalarWhereWithAggregatesInput = {
    AND?:
      | EventScalarWhereWithAggregatesInput
      | EventScalarWhereWithAggregatesInput[];
    OR?: EventScalarWhereWithAggregatesInput[];
    NOT?:
      | EventScalarWhereWithAggregatesInput
      | EventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Event"> | string;
    title?: StringWithAggregatesFilter<"Event"> | string;
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    image?: StringWithAggregatesFilter<"Event"> | string;
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string;
    time?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    reportLink?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    venue?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    guests?: StringNullableListFilter<"Event">;
    published?: BoolWithAggregatesFilter<"Event"> | boolean;
    type?: EnumEventTypeWithAggregatesFilter<"Event"> | $Enums.EventType;
    category?:
      | EnumEventCategoryWithAggregatesFilter<"Event">
      | $Enums.EventCategory;
    maxTeamSize?: IntWithAggregatesFilter<"Event"> | number;
    minTeamSize?: IntWithAggregatesFilter<"Event"> | number;
    brief?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    entryFee?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    qr?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    registrationsAvailable?: BoolWithAggregatesFilter<"Event"> | boolean;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    maxTeams?: IntNullableWithAggregatesFilter<"Event"> | number | null;
    notification?: StringNullableWithAggregatesFilter<"Event"> | string | null;
  };

  export type LinksWhereInput = {
    AND?: LinksWhereInput | LinksWhereInput[];
    OR?: LinksWhereInput[];
    NOT?: LinksWhereInput | LinksWhereInput[];
    id?: StringFilter<"Links"> | string;
    instagram?: StringNullableFilter<"Links"> | string | null;
    linkedin?: StringNullableFilter<"Links"> | string | null;
    github?: StringNullableFilter<"Links"> | string | null;
    userId?: StringFilter<"Links"> | string;
    twitter?: StringNullableFilter<"Links"> | string | null;
    order?: StringNullableListFilter<"Links">;
    custom?: JsonNullableFilter<"Links">;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type LinksOrderByWithRelationInput = {
    id?: SortOrder;
    instagram?: SortOrderInput | SortOrder;
    linkedin?: SortOrderInput | SortOrder;
    github?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    twitter?: SortOrderInput | SortOrder;
    order?: SortOrder;
    custom?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type LinksWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: LinksWhereInput | LinksWhereInput[];
      OR?: LinksWhereInput[];
      NOT?: LinksWhereInput | LinksWhereInput[];
      instagram?: StringNullableFilter<"Links"> | string | null;
      linkedin?: StringNullableFilter<"Links"> | string | null;
      github?: StringNullableFilter<"Links"> | string | null;
      twitter?: StringNullableFilter<"Links"> | string | null;
      order?: StringNullableListFilter<"Links">;
      custom?: JsonNullableFilter<"Links">;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId"
  >;

  export type LinksOrderByWithAggregationInput = {
    id?: SortOrder;
    instagram?: SortOrderInput | SortOrder;
    linkedin?: SortOrderInput | SortOrder;
    github?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    twitter?: SortOrderInput | SortOrder;
    order?: SortOrder;
    custom?: SortOrderInput | SortOrder;
    _count?: LinksCountOrderByAggregateInput;
    _max?: LinksMaxOrderByAggregateInput;
    _min?: LinksMinOrderByAggregateInput;
  };

  export type LinksScalarWhereWithAggregatesInput = {
    AND?:
      | LinksScalarWhereWithAggregatesInput
      | LinksScalarWhereWithAggregatesInput[];
    OR?: LinksScalarWhereWithAggregatesInput[];
    NOT?:
      | LinksScalarWhereWithAggregatesInput
      | LinksScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Links"> | string;
    instagram?: StringNullableWithAggregatesFilter<"Links"> | string | null;
    linkedin?: StringNullableWithAggregatesFilter<"Links"> | string | null;
    github?: StringNullableWithAggregatesFilter<"Links"> | string | null;
    userId?: StringWithAggregatesFilter<"Links"> | string;
    twitter?: StringNullableWithAggregatesFilter<"Links"> | string | null;
    order?: StringNullableListFilter<"Links">;
    custom?: JsonNullableWithAggregatesFilter<"Links">;
  };

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[];
    OR?: TeamWhereInput[];
    NOT?: TeamWhereInput | TeamWhereInput[];
    id?: StringFilter<"Team"> | string;
    attended?: BoolFilter<"Team"> | boolean;
    eventId?: StringFilter<"Team"> | string;
    name?: StringNullableFilter<"Team"> | string | null;
    leaderId?: StringNullableFilter<"Team"> | string | null;
    transactionId?: StringNullableFilter<"Team"> | string | null;
    isConfirmed?: BoolFilter<"Team"> | boolean;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    winner?: XOR<WinnersNullableScalarRelationFilter, WinnersWhereInput> | null;
    user?: UserListRelationFilter;
  };

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder;
    attended?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrderInput | SortOrder;
    leaderId?: SortOrderInput | SortOrder;
    transactionId?: SortOrderInput | SortOrder;
    isConfirmed?: SortOrder;
    event?: EventOrderByWithRelationInput;
    winner?: WinnersOrderByWithRelationInput;
    user?: UserOrderByRelationAggregateInput;
  };

  export type TeamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TeamWhereInput | TeamWhereInput[];
      OR?: TeamWhereInput[];
      NOT?: TeamWhereInput | TeamWhereInput[];
      attended?: BoolFilter<"Team"> | boolean;
      eventId?: StringFilter<"Team"> | string;
      name?: StringNullableFilter<"Team"> | string | null;
      leaderId?: StringNullableFilter<"Team"> | string | null;
      transactionId?: StringNullableFilter<"Team"> | string | null;
      isConfirmed?: BoolFilter<"Team"> | boolean;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      winner?: XOR<
        WinnersNullableScalarRelationFilter,
        WinnersWhereInput
      > | null;
      user?: UserListRelationFilter;
    },
    "id"
  >;

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder;
    attended?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrderInput | SortOrder;
    leaderId?: SortOrderInput | SortOrder;
    transactionId?: SortOrderInput | SortOrder;
    isConfirmed?: SortOrder;
    _count?: TeamCountOrderByAggregateInput;
    _max?: TeamMaxOrderByAggregateInput;
    _min?: TeamMinOrderByAggregateInput;
  };

  export type TeamScalarWhereWithAggregatesInput = {
    AND?:
      | TeamScalarWhereWithAggregatesInput
      | TeamScalarWhereWithAggregatesInput[];
    OR?: TeamScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamScalarWhereWithAggregatesInput
      | TeamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Team"> | string;
    attended?: BoolWithAggregatesFilter<"Team"> | boolean;
    eventId?: StringWithAggregatesFilter<"Team"> | string;
    name?: StringNullableWithAggregatesFilter<"Team"> | string | null;
    leaderId?: StringNullableWithAggregatesFilter<"Team"> | string | null;
    transactionId?: StringNullableWithAggregatesFilter<"Team"> | string | null;
    isConfirmed?: BoolWithAggregatesFilter<"Team"> | boolean;
  };

  export type WinnersWhereInput = {
    AND?: WinnersWhereInput | WinnersWhereInput[];
    OR?: WinnersWhereInput[];
    NOT?: WinnersWhereInput | WinnersWhereInput[];
    id?: StringFilter<"Winners"> | string;
    teamId?: StringFilter<"Winners"> | string;
    eventId?: StringFilter<"Winners"> | string;
    position?: EnumWinnerTypeFilter<"Winners"> | $Enums.WinnerType;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
  };

  export type WinnersOrderByWithRelationInput = {
    id?: SortOrder;
    teamId?: SortOrder;
    eventId?: SortOrder;
    position?: SortOrder;
    event?: EventOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
  };

  export type WinnersWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      teamId?: string;
      AND?: WinnersWhereInput | WinnersWhereInput[];
      OR?: WinnersWhereInput[];
      NOT?: WinnersWhereInput | WinnersWhereInput[];
      eventId?: StringFilter<"Winners"> | string;
      position?: EnumWinnerTypeFilter<"Winners"> | $Enums.WinnerType;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
    },
    "id" | "teamId"
  >;

  export type WinnersOrderByWithAggregationInput = {
    id?: SortOrder;
    teamId?: SortOrder;
    eventId?: SortOrder;
    position?: SortOrder;
    _count?: WinnersCountOrderByAggregateInput;
    _max?: WinnersMaxOrderByAggregateInput;
    _min?: WinnersMinOrderByAggregateInput;
  };

  export type WinnersScalarWhereWithAggregatesInput = {
    AND?:
      | WinnersScalarWhereWithAggregatesInput
      | WinnersScalarWhereWithAggregatesInput[];
    OR?: WinnersScalarWhereWithAggregatesInput[];
    NOT?:
      | WinnersScalarWhereWithAggregatesInput
      | WinnersScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Winners"> | string;
    teamId?: StringWithAggregatesFilter<"Winners"> | string;
    eventId?: StringWithAggregatesFilter<"Winners"> | string;
    position?:
      | EnumWinnerTypeWithAggregatesFilter<"Winners">
      | $Enums.WinnerType;
  };

  export type PlacementWhereInput = {
    AND?: PlacementWhereInput | PlacementWhereInput[];
    OR?: PlacementWhereInput[];
    NOT?: PlacementWhereInput | PlacementWhereInput[];
    id?: StringFilter<"Placement"> | string;
    yearId?: StringFilter<"Placement"> | string;
    studentId?: StringFilter<"Placement"> | string;
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>;
    year?: XOR<YearScalarRelationFilter, YearWhereInput>;
    offers?: OfferListRelationFilter;
  };

  export type PlacementOrderByWithRelationInput = {
    id?: SortOrder;
    yearId?: SortOrder;
    studentId?: SortOrder;
    student?: StudentOrderByWithRelationInput;
    year?: YearOrderByWithRelationInput;
    offers?: OfferOrderByRelationAggregateInput;
  };

  export type PlacementWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      studentId?: string;
      AND?: PlacementWhereInput | PlacementWhereInput[];
      OR?: PlacementWhereInput[];
      NOT?: PlacementWhereInput | PlacementWhereInput[];
      yearId?: StringFilter<"Placement"> | string;
      student?: XOR<StudentScalarRelationFilter, StudentWhereInput>;
      year?: XOR<YearScalarRelationFilter, YearWhereInput>;
      offers?: OfferListRelationFilter;
    },
    "id" | "studentId"
  >;

  export type PlacementOrderByWithAggregationInput = {
    id?: SortOrder;
    yearId?: SortOrder;
    studentId?: SortOrder;
    _count?: PlacementCountOrderByAggregateInput;
    _max?: PlacementMaxOrderByAggregateInput;
    _min?: PlacementMinOrderByAggregateInput;
  };

  export type PlacementScalarWhereWithAggregatesInput = {
    AND?:
      | PlacementScalarWhereWithAggregatesInput
      | PlacementScalarWhereWithAggregatesInput[];
    OR?: PlacementScalarWhereWithAggregatesInput[];
    NOT?:
      | PlacementScalarWhereWithAggregatesInput
      | PlacementScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Placement"> | string;
    yearId?: StringWithAggregatesFilter<"Placement"> | string;
    studentId?: StringWithAggregatesFilter<"Placement"> | string;
  };

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[];
    OR?: CompanyWhereInput[];
    NOT?: CompanyWhereInput | CompanyWhereInput[];
    id?: StringFilter<"Company"> | string;
    companyName?: StringFilter<"Company"> | string;
    image?: StringFilter<"Company"> | string;
    offers?: OfferListRelationFilter;
  };

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder;
    companyName?: SortOrder;
    image?: SortOrder;
    offers?: OfferOrderByRelationAggregateInput;
  };

  export type CompanyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CompanyWhereInput | CompanyWhereInput[];
      OR?: CompanyWhereInput[];
      NOT?: CompanyWhereInput | CompanyWhereInput[];
      companyName?: StringFilter<"Company"> | string;
      image?: StringFilter<"Company"> | string;
      offers?: OfferListRelationFilter;
    },
    "id"
  >;

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder;
    companyName?: SortOrder;
    image?: SortOrder;
    _count?: CompanyCountOrderByAggregateInput;
    _max?: CompanyMaxOrderByAggregateInput;
    _min?: CompanyMinOrderByAggregateInput;
  };

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?:
      | CompanyScalarWhereWithAggregatesInput
      | CompanyScalarWhereWithAggregatesInput[];
    OR?: CompanyScalarWhereWithAggregatesInput[];
    NOT?:
      | CompanyScalarWhereWithAggregatesInput
      | CompanyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Company"> | string;
    companyName?: StringWithAggregatesFilter<"Company"> | string;
    image?: StringWithAggregatesFilter<"Company"> | string;
  };

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[];
    OR?: OfferWhereInput[];
    NOT?: OfferWhereInput | OfferWhereInput[];
    id?: StringFilter<"Offer"> | string;
    companyId?: StringFilter<"Offer"> | string;
    package?: StringFilter<"Offer"> | string;
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>;
    placements?: PlacementListRelationFilter;
  };

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder;
    companyId?: SortOrder;
    package?: SortOrder;
    company?: CompanyOrderByWithRelationInput;
    placements?: PlacementOrderByRelationAggregateInput;
  };

  export type OfferWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OfferWhereInput | OfferWhereInput[];
      OR?: OfferWhereInput[];
      NOT?: OfferWhereInput | OfferWhereInput[];
      companyId?: StringFilter<"Offer"> | string;
      package?: StringFilter<"Offer"> | string;
      company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>;
      placements?: PlacementListRelationFilter;
    },
    "id"
  >;

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder;
    companyId?: SortOrder;
    package?: SortOrder;
    _count?: OfferCountOrderByAggregateInput;
    _max?: OfferMaxOrderByAggregateInput;
    _min?: OfferMinOrderByAggregateInput;
  };

  export type OfferScalarWhereWithAggregatesInput = {
    AND?:
      | OfferScalarWhereWithAggregatesInput
      | OfferScalarWhereWithAggregatesInput[];
    OR?: OfferScalarWhereWithAggregatesInput[];
    NOT?:
      | OfferScalarWhereWithAggregatesInput
      | OfferScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Offer"> | string;
    companyId?: StringWithAggregatesFilter<"Offer"> | string;
    package?: StringWithAggregatesFilter<"Offer"> | string;
  };

  export type YearWhereInput = {
    AND?: YearWhereInput | YearWhereInput[];
    OR?: YearWhereInput[];
    NOT?: YearWhereInput | YearWhereInput[];
    id?: StringFilter<"Year"> | string;
    year?: StringFilter<"Year"> | string;
    companies?: StringNullableListFilter<"Year">;
    placements?: PlacementListRelationFilter;
  };

  export type YearOrderByWithRelationInput = {
    id?: SortOrder;
    year?: SortOrder;
    companies?: SortOrder;
    placements?: PlacementOrderByRelationAggregateInput;
  };

  export type YearWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: YearWhereInput | YearWhereInput[];
      OR?: YearWhereInput[];
      NOT?: YearWhereInput | YearWhereInput[];
      year?: StringFilter<"Year"> | string;
      companies?: StringNullableListFilter<"Year">;
      placements?: PlacementListRelationFilter;
    },
    "id"
  >;

  export type YearOrderByWithAggregationInput = {
    id?: SortOrder;
    year?: SortOrder;
    companies?: SortOrder;
    _count?: YearCountOrderByAggregateInput;
    _max?: YearMaxOrderByAggregateInput;
    _min?: YearMinOrderByAggregateInput;
  };

  export type YearScalarWhereWithAggregatesInput = {
    AND?:
      | YearScalarWhereWithAggregatesInput
      | YearScalarWhereWithAggregatesInput[];
    OR?: YearScalarWhereWithAggregatesInput[];
    NOT?:
      | YearScalarWhereWithAggregatesInput
      | YearScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Year"> | string;
    year?: StringWithAggregatesFilter<"Year"> | string;
    companies?: StringNullableListFilter<"Year">;
  };

  export type PatentsWhereInput = {
    AND?: PatentsWhereInput | PatentsWhereInput[];
    OR?: PatentsWhereInput[];
    NOT?: PatentsWhereInput | PatentsWhereInput[];
    id?: StringFilter<"Patents"> | string;
    patentId?: StringFilter<"Patents"> | string;
    year?: StringFilter<"Patents"> | string;
    title?: StringFilter<"Patents"> | string;
    authors?: StringNullableListFilter<"Patents">;
    inventorsName?: StringNullableListFilter<"Patents">;
    inventorsAddress?: StringNullableListFilter<"Patents">;
    certificate?: StringNullableFilter<"Patents"> | string | null;
    faculty?: FacultyListRelationFilter;
    student?: StudentListRelationFilter;
  };

  export type PatentsOrderByWithRelationInput = {
    id?: SortOrder;
    patentId?: SortOrder;
    year?: SortOrder;
    title?: SortOrder;
    authors?: SortOrder;
    inventorsName?: SortOrder;
    inventorsAddress?: SortOrder;
    certificate?: SortOrderInput | SortOrder;
    faculty?: FacultyOrderByRelationAggregateInput;
    student?: StudentOrderByRelationAggregateInput;
  };

  export type PatentsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PatentsWhereInput | PatentsWhereInput[];
      OR?: PatentsWhereInput[];
      NOT?: PatentsWhereInput | PatentsWhereInput[];
      patentId?: StringFilter<"Patents"> | string;
      year?: StringFilter<"Patents"> | string;
      title?: StringFilter<"Patents"> | string;
      authors?: StringNullableListFilter<"Patents">;
      inventorsName?: StringNullableListFilter<"Patents">;
      inventorsAddress?: StringNullableListFilter<"Patents">;
      certificate?: StringNullableFilter<"Patents"> | string | null;
      faculty?: FacultyListRelationFilter;
      student?: StudentListRelationFilter;
    },
    "id"
  >;

  export type PatentsOrderByWithAggregationInput = {
    id?: SortOrder;
    patentId?: SortOrder;
    year?: SortOrder;
    title?: SortOrder;
    authors?: SortOrder;
    inventorsName?: SortOrder;
    inventorsAddress?: SortOrder;
    certificate?: SortOrderInput | SortOrder;
    _count?: PatentsCountOrderByAggregateInput;
    _max?: PatentsMaxOrderByAggregateInput;
    _min?: PatentsMinOrderByAggregateInput;
  };

  export type PatentsScalarWhereWithAggregatesInput = {
    AND?:
      | PatentsScalarWhereWithAggregatesInput
      | PatentsScalarWhereWithAggregatesInput[];
    OR?: PatentsScalarWhereWithAggregatesInput[];
    NOT?:
      | PatentsScalarWhereWithAggregatesInput
      | PatentsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Patents"> | string;
    patentId?: StringWithAggregatesFilter<"Patents"> | string;
    year?: StringWithAggregatesFilter<"Patents"> | string;
    title?: StringWithAggregatesFilter<"Patents"> | string;
    authors?: StringNullableListFilter<"Patents">;
    inventorsName?: StringNullableListFilter<"Patents">;
    inventorsAddress?: StringNullableListFilter<"Patents">;
    certificate?: StringNullableWithAggregatesFilter<"Patents"> | string | null;
  };

  export type PublicationWhereInput = {
    AND?: PublicationWhereInput | PublicationWhereInput[];
    OR?: PublicationWhereInput[];
    NOT?: PublicationWhereInput | PublicationWhereInput[];
    id?: StringFilter<"Publication"> | string;
    authors?: StringNullableListFilter<"Publication">;
    title?: StringFilter<"Publication"> | string;
    publish_date?: StringFilter<"Publication"> | string;
    publisher?: StringNullableFilter<"Publication"> | string | null;
    journal?: StringNullableFilter<"Publication"> | string | null;
    conference?: StringNullableFilter<"Publication"> | string | null;
    link?: StringFilter<"Publication"> | string;
    ranking?: StringNullableFilter<"Publication"> | string | null;
    impact_factor?: StringNullableFilter<"Publication"> | string | null;
    indexed?: StringFilter<"Publication"> | string;
    publisher_conference?: StringNullableFilter<"Publication"> | string | null;
    year?: IntFilter<"Publication"> | number;
    faculty?: FacultyListRelationFilter;
  };

  export type PublicationOrderByWithRelationInput = {
    id?: SortOrder;
    authors?: SortOrder;
    title?: SortOrder;
    publish_date?: SortOrder;
    publisher?: SortOrderInput | SortOrder;
    journal?: SortOrderInput | SortOrder;
    conference?: SortOrderInput | SortOrder;
    link?: SortOrder;
    ranking?: SortOrderInput | SortOrder;
    impact_factor?: SortOrderInput | SortOrder;
    indexed?: SortOrder;
    publisher_conference?: SortOrderInput | SortOrder;
    year?: SortOrder;
    faculty?: FacultyOrderByRelationAggregateInput;
  };

  export type PublicationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PublicationWhereInput | PublicationWhereInput[];
      OR?: PublicationWhereInput[];
      NOT?: PublicationWhereInput | PublicationWhereInput[];
      authors?: StringNullableListFilter<"Publication">;
      title?: StringFilter<"Publication"> | string;
      publish_date?: StringFilter<"Publication"> | string;
      publisher?: StringNullableFilter<"Publication"> | string | null;
      journal?: StringNullableFilter<"Publication"> | string | null;
      conference?: StringNullableFilter<"Publication"> | string | null;
      link?: StringFilter<"Publication"> | string;
      ranking?: StringNullableFilter<"Publication"> | string | null;
      impact_factor?: StringNullableFilter<"Publication"> | string | null;
      indexed?: StringFilter<"Publication"> | string;
      publisher_conference?:
        | StringNullableFilter<"Publication">
        | string
        | null;
      year?: IntFilter<"Publication"> | number;
      faculty?: FacultyListRelationFilter;
    },
    "id"
  >;

  export type PublicationOrderByWithAggregationInput = {
    id?: SortOrder;
    authors?: SortOrder;
    title?: SortOrder;
    publish_date?: SortOrder;
    publisher?: SortOrderInput | SortOrder;
    journal?: SortOrderInput | SortOrder;
    conference?: SortOrderInput | SortOrder;
    link?: SortOrder;
    ranking?: SortOrderInput | SortOrder;
    impact_factor?: SortOrderInput | SortOrder;
    indexed?: SortOrder;
    publisher_conference?: SortOrderInput | SortOrder;
    year?: SortOrder;
    _count?: PublicationCountOrderByAggregateInput;
    _avg?: PublicationAvgOrderByAggregateInput;
    _max?: PublicationMaxOrderByAggregateInput;
    _min?: PublicationMinOrderByAggregateInput;
    _sum?: PublicationSumOrderByAggregateInput;
  };

  export type PublicationScalarWhereWithAggregatesInput = {
    AND?:
      | PublicationScalarWhereWithAggregatesInput
      | PublicationScalarWhereWithAggregatesInput[];
    OR?: PublicationScalarWhereWithAggregatesInput[];
    NOT?:
      | PublicationScalarWhereWithAggregatesInput
      | PublicationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Publication"> | string;
    authors?: StringNullableListFilter<"Publication">;
    title?: StringWithAggregatesFilter<"Publication"> | string;
    publish_date?: StringWithAggregatesFilter<"Publication"> | string;
    publisher?:
      | StringNullableWithAggregatesFilter<"Publication">
      | string
      | null;
    journal?: StringNullableWithAggregatesFilter<"Publication"> | string | null;
    conference?:
      | StringNullableWithAggregatesFilter<"Publication">
      | string
      | null;
    link?: StringWithAggregatesFilter<"Publication"> | string;
    ranking?: StringNullableWithAggregatesFilter<"Publication"> | string | null;
    impact_factor?:
      | StringNullableWithAggregatesFilter<"Publication">
      | string
      | null;
    indexed?: StringWithAggregatesFilter<"Publication"> | string;
    publisher_conference?:
      | StringNullableWithAggregatesFilter<"Publication">
      | string
      | null;
    year?: IntWithAggregatesFilter<"Publication"> | number;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type AccountCreateInput = {
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountCreateManyInput = {
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateInput = {
    sessionToken: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    sessionToken: string;
    userId: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    sessionToken: string;
    userId: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StudentCreateInput = {
    id?: string;
    image: string;
    placement?: PlacementCreateNestedOneWithoutStudentInput;
    user: UserCreateNestedOneWithoutStudentInput;
    patents?: PatentsCreateNestedManyWithoutStudentInput;
  };

  export type StudentUncheckedCreateInput = {
    id?: string;
    image: string;
    userId: string;
    placement?: PlacementUncheckedCreateNestedOneWithoutStudentInput;
    patents?: PatentsUncheckedCreateNestedManyWithoutStudentInput;
  };

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUpdateOneWithoutStudentNestedInput;
    user?: UserUpdateOneRequiredWithoutStudentNestedInput;
    patents?: PatentsUpdateManyWithoutStudentNestedInput;
  };

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUncheckedUpdateOneWithoutStudentNestedInput;
    patents?: PatentsUncheckedUpdateManyWithoutStudentNestedInput;
  };

  export type StudentCreateManyInput = {
    id?: string;
    image: string;
    userId: string;
  };

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
  };

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type CoreCreateInput = {
    id?: string;
    year: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
    User: UserCreateNestedOneWithoutCoreInput;
  };

  export type CoreUncheckedCreateInput = {
    id?: string;
    year: string;
    userId: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
  };

  export type CoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneRequiredWithoutCoreNestedInput;
  };

  export type CoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CoreCreateManyInput = {
    id?: string;
    year: string;
    userId: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
  };

  export type CoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FacultyCreateInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    patents?: PatentsCreateNestedManyWithoutFacultyInput;
    publications?: PublicationCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyUncheckedCreateInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput;
    publications?: PublicationUncheckedCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    patents?: PatentsUpdateManyWithoutFacultyNestedInput;
    publications?: PublicationUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput;
    publications?: PublicationUncheckedUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyCreateManyInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
  };

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamCreateNestedManyWithoutEventInput;
    winners?: WinnersCreateNestedManyWithoutEventInput;
    organizers?: UserCreateNestedManyWithoutOrganizersInput;
  };

  export type EventUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamUncheckedCreateNestedManyWithoutEventInput;
    winners?: WinnersUncheckedCreateNestedManyWithoutEventInput;
    organizers?: UserUncheckedCreateNestedManyWithoutOrganizersInput;
  };

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUpdateManyWithoutEventNestedInput;
    winners?: WinnersUpdateManyWithoutEventNestedInput;
    organizers?: UserUpdateManyWithoutOrganizersNestedInput;
  };

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    winners?: WinnersUncheckedUpdateManyWithoutEventNestedInput;
    organizers?: UserUncheckedUpdateManyWithoutOrganizersNestedInput;
  };

  export type EventCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
  };

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LinksCreateInput = {
    id?: string;
    instagram?: string | null;
    linkedin?: string | null;
    github?: string | null;
    twitter?: string | null;
    order?: LinksCreateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
    user: UserCreateNestedOneWithoutLinksInput;
  };

  export type LinksUncheckedCreateInput = {
    id?: string;
    instagram?: string | null;
    linkedin?: string | null;
    github?: string | null;
    userId: string;
    twitter?: string | null;
    order?: LinksCreateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
    user?: UserUpdateOneRequiredWithoutLinksNestedInput;
  };

  export type LinksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksCreateManyInput = {
    id?: string;
    instagram?: string | null;
    linkedin?: string | null;
    github?: string | null;
    userId: string;
    twitter?: string | null;
    order?: LinksCreateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TeamCreateInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    event: EventCreateNestedOneWithoutParticipantsInput;
    winner?: WinnersCreateNestedOneWithoutTeamInput;
    user?: UserCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateInput = {
    id?: string;
    attended?: boolean;
    eventId: string;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    winner?: WinnersUncheckedCreateNestedOneWithoutTeamInput;
    user?: UserUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput;
    winner?: WinnersUpdateOneWithoutTeamNestedInput;
    user?: UserUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    winner?: WinnersUncheckedUpdateOneWithoutTeamNestedInput;
    user?: UserUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamCreateManyInput = {
    id?: string;
    attended?: boolean;
    eventId: string;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
  };

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type WinnersCreateInput = {
    id?: string;
    position: $Enums.WinnerType;
    event: EventCreateNestedOneWithoutWinnersInput;
    team: TeamCreateNestedOneWithoutWinnerInput;
  };

  export type WinnersUncheckedCreateInput = {
    id?: string;
    teamId: string;
    eventId: string;
    position: $Enums.WinnerType;
  };

  export type WinnersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
    event?: EventUpdateOneRequiredWithoutWinnersNestedInput;
    team?: TeamUpdateOneRequiredWithoutWinnerNestedInput;
  };

  export type WinnersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type WinnersCreateManyInput = {
    id?: string;
    teamId: string;
    eventId: string;
    position: $Enums.WinnerType;
  };

  export type WinnersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type WinnersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type PlacementCreateInput = {
    id?: string;
    student: StudentCreateNestedOneWithoutPlacementInput;
    year: YearCreateNestedOneWithoutPlacementsInput;
    offers?: OfferCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementUncheckedCreateInput = {
    id?: string;
    yearId: string;
    studentId: string;
    offers?: OfferUncheckedCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    student?: StudentUpdateOneRequiredWithoutPlacementNestedInput;
    year?: YearUpdateOneRequiredWithoutPlacementsNestedInput;
    offers?: OfferUpdateManyWithoutPlacementsNestedInput;
  };

  export type PlacementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearId?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
    offers?: OfferUncheckedUpdateManyWithoutPlacementsNestedInput;
  };

  export type PlacementCreateManyInput = {
    id?: string;
    yearId: string;
    studentId: string;
  };

  export type PlacementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
  };

  export type PlacementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearId?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
  };

  export type CompanyCreateInput = {
    id?: string;
    companyName: string;
    image: string;
    offers?: OfferCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUncheckedCreateInput = {
    id?: string;
    companyName: string;
    image: string;
    offers?: OfferUncheckedCreateNestedManyWithoutCompanyInput;
  };

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    offers?: OfferUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    offers?: OfferUncheckedUpdateManyWithoutCompanyNestedInput;
  };

  export type CompanyCreateManyInput = {
    id?: string;
    companyName: string;
    image: string;
  };

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
  };

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
  };

  export type OfferCreateInput = {
    id?: string;
    package: string;
    company: CompanyCreateNestedOneWithoutOffersInput;
    placements?: PlacementCreateNestedManyWithoutOffersInput;
  };

  export type OfferUncheckedCreateInput = {
    id?: string;
    companyId: string;
    package: string;
    placements?: PlacementUncheckedCreateNestedManyWithoutOffersInput;
  };

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
    company?: CompanyUpdateOneRequiredWithoutOffersNestedInput;
    placements?: PlacementUpdateManyWithoutOffersNestedInput;
  };

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyId?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
    placements?: PlacementUncheckedUpdateManyWithoutOffersNestedInput;
  };

  export type OfferCreateManyInput = {
    id?: string;
    companyId: string;
    package: string;
  };

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
  };

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyId?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
  };

  export type YearCreateInput = {
    id?: string;
    year: string;
    companies?: YearCreatecompaniesInput | string[];
    placements?: PlacementCreateNestedManyWithoutYearInput;
  };

  export type YearUncheckedCreateInput = {
    id?: string;
    year: string;
    companies?: YearCreatecompaniesInput | string[];
    placements?: PlacementUncheckedCreateNestedManyWithoutYearInput;
  };

  export type YearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
    placements?: PlacementUpdateManyWithoutYearNestedInput;
  };

  export type YearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
    placements?: PlacementUncheckedUpdateManyWithoutYearNestedInput;
  };

  export type YearCreateManyInput = {
    id?: string;
    year: string;
    companies?: YearCreatecompaniesInput | string[];
  };

  export type YearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
  };

  export type YearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
  };

  export type PatentsCreateInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    faculty?: FacultyCreateNestedManyWithoutPatentsInput;
    student?: StudentCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsUncheckedCreateInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    faculty?: FacultyUncheckedCreateNestedManyWithoutPatentsInput;
    student?: StudentUncheckedCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    faculty?: FacultyUpdateManyWithoutPatentsNestedInput;
    student?: StudentUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    faculty?: FacultyUncheckedUpdateManyWithoutPatentsNestedInput;
    student?: StudentUncheckedUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsCreateManyInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
  };

  export type PatentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PatentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PublicationCreateInput = {
    id?: string;
    authors?: PublicationCreateauthorsInput | string[];
    title: string;
    publish_date: string;
    publisher?: string | null;
    journal?: string | null;
    conference?: string | null;
    link: string;
    ranking?: string | null;
    impact_factor?: string | null;
    indexed: string;
    publisher_conference?: string | null;
    year: number;
    faculty?: FacultyCreateNestedManyWithoutPublicationsInput;
  };

  export type PublicationUncheckedCreateInput = {
    id?: string;
    authors?: PublicationCreateauthorsInput | string[];
    title: string;
    publish_date: string;
    publisher?: string | null;
    journal?: string | null;
    conference?: string | null;
    link: string;
    ranking?: string | null;
    impact_factor?: string | null;
    indexed: string;
    publisher_conference?: string | null;
    year: number;
    faculty?: FacultyUncheckedCreateNestedManyWithoutPublicationsInput;
  };

  export type PublicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
    faculty?: FacultyUpdateManyWithoutPublicationsNestedInput;
  };

  export type PublicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
    faculty?: FacultyUncheckedUpdateManyWithoutPublicationsNestedInput;
  };

  export type PublicationCreateManyInput = {
    id?: string;
    authors?: PublicationCreateauthorsInput | string[];
    title: string;
    publish_date: string;
    publisher?: string | null;
    journal?: string | null;
    conference?: string | null;
    link: string;
    ranking?: string | null;
    impact_factor?: string | null;
    indexed: string;
    publisher_conference?: string | null;
    year: number;
  };

  export type PublicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
  };

  export type PublicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type CoreListRelationFilter = {
    every?: CoreWhereInput;
    some?: CoreWhereInput;
    none?: CoreWhereInput;
  };

  export type LinksNullableScalarRelationFilter = {
    is?: LinksWhereInput | null;
    isNot?: LinksWhereInput | null;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null;
    isNot?: StudentWhereInput | null;
  };

  export type EventListRelationFilter = {
    every?: EventWhereInput;
    some?: EventWhereInput;
    none?: EventWhereInput;
  };

  export type TeamListRelationFilter = {
    every?: TeamWhereInput;
    some?: TeamWhereInput;
    none?: TeamWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CoreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    bio?: SortOrder;
    phone?: SortOrder;
    username?: SortOrder;
    usn?: SortOrder;
    lightTheme?: SortOrder;
    darkTheme?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    displayName?: SortOrder;
    college?: SortOrder;
    role?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    bio?: SortOrder;
    phone?: SortOrder;
    username?: SortOrder;
    usn?: SortOrder;
    lightTheme?: SortOrder;
    darkTheme?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    displayName?: SortOrder;
    college?: SortOrder;
    role?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    bio?: SortOrder;
    phone?: SortOrder;
    username?: SortOrder;
    usn?: SortOrder;
    lightTheme?: SortOrder;
    darkTheme?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    displayName?: SortOrder;
    college?: SortOrder;
    role?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type SessionCountOrderByAggregateInput = {
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PlacementNullableScalarRelationFilter = {
    is?: PlacementWhereInput | null;
    isNot?: PlacementWhereInput | null;
  };

  export type PatentsListRelationFilter = {
    every?: PatentsWhereInput;
    some?: PatentsWhereInput;
    none?: PatentsWhereInput;
  };

  export type PatentsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder;
    image?: SortOrder;
    userId?: SortOrder;
  };

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder;
    image?: SortOrder;
    userId?: SortOrder;
  };

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder;
    image?: SortOrder;
    userId?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type CoreCountOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    userId?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    post?: SortOrder;
    quote?: SortOrder;
  };

  export type CoreAvgOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type CoreMaxOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    userId?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    post?: SortOrder;
    quote?: SortOrder;
  };

  export type CoreMinOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    userId?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    post?: SortOrder;
    quote?: SortOrder;
  };

  export type CoreSumOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type PublicationListRelationFilter = {
    every?: PublicationWhereInput;
    some?: PublicationWhereInput;
    none?: PublicationWhereInput;
  };

  export type PublicationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    designation?: SortOrder;
    image?: SortOrder;
    about?: SortOrder;
    order?: SortOrder;
    published?: SortOrder;
    designation2?: SortOrder;
  };

  export type FacultyAvgOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    designation?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    published?: SortOrder;
    designation2?: SortOrder;
  };

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    designation?: SortOrder;
    image?: SortOrder;
    order?: SortOrder;
    published?: SortOrder;
    designation2?: SortOrder;
  };

  export type FacultySumOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType;
  };

  export type EnumEventCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventCategory
      | EnumEventCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventCategoryFilter<$PrismaModel> | $Enums.EventCategory;
  };

  export type WinnersListRelationFilter = {
    every?: WinnersWhereInput;
    some?: WinnersWhereInput;
    none?: WinnersWhereInput;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type WinnersOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    image?: SortOrder;
    date?: SortOrder;
    time?: SortOrder;
    reportLink?: SortOrder;
    venue?: SortOrder;
    guests?: SortOrder;
    published?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    brief?: SortOrder;
    entryFee?: SortOrder;
    qr?: SortOrder;
    registrationsAvailable?: SortOrder;
    endDate?: SortOrder;
    maxTeams?: SortOrder;
    notification?: SortOrder;
  };

  export type EventAvgOrderByAggregateInput = {
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    maxTeams?: SortOrder;
  };

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    image?: SortOrder;
    date?: SortOrder;
    time?: SortOrder;
    reportLink?: SortOrder;
    venue?: SortOrder;
    published?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    brief?: SortOrder;
    entryFee?: SortOrder;
    qr?: SortOrder;
    registrationsAvailable?: SortOrder;
    endDate?: SortOrder;
    maxTeams?: SortOrder;
    notification?: SortOrder;
  };

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    image?: SortOrder;
    date?: SortOrder;
    time?: SortOrder;
    reportLink?: SortOrder;
    venue?: SortOrder;
    published?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    brief?: SortOrder;
    entryFee?: SortOrder;
    qr?: SortOrder;
    registrationsAvailable?: SortOrder;
    endDate?: SortOrder;
    maxTeams?: SortOrder;
    notification?: SortOrder;
  };

  export type EventSumOrderByAggregateInput = {
    maxTeamSize?: SortOrder;
    minTeamSize?: SortOrder;
    maxTeams?: SortOrder;
  };

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumEventTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventTypeFilter<$PrismaModel>;
    _max?: NestedEnumEventTypeFilter<$PrismaModel>;
  };

  export type EnumEventCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventCategory
      | EnumEventCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumEventCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.EventCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventCategoryFilter<$PrismaModel>;
    _max?: NestedEnumEventCategoryFilter<$PrismaModel>;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type LinksCountOrderByAggregateInput = {
    id?: SortOrder;
    instagram?: SortOrder;
    linkedin?: SortOrder;
    github?: SortOrder;
    userId?: SortOrder;
    twitter?: SortOrder;
    order?: SortOrder;
    custom?: SortOrder;
  };

  export type LinksMaxOrderByAggregateInput = {
    id?: SortOrder;
    instagram?: SortOrder;
    linkedin?: SortOrder;
    github?: SortOrder;
    userId?: SortOrder;
    twitter?: SortOrder;
  };

  export type LinksMinOrderByAggregateInput = {
    id?: SortOrder;
    instagram?: SortOrder;
    linkedin?: SortOrder;
    github?: SortOrder;
    userId?: SortOrder;
    twitter?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EventScalarRelationFilter = {
    is?: EventWhereInput;
    isNot?: EventWhereInput;
  };

  export type WinnersNullableScalarRelationFilter = {
    is?: WinnersWhereInput | null;
    isNot?: WinnersWhereInput | null;
  };

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder;
    attended?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    leaderId?: SortOrder;
    transactionId?: SortOrder;
    isConfirmed?: SortOrder;
  };

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder;
    attended?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    leaderId?: SortOrder;
    transactionId?: SortOrder;
    isConfirmed?: SortOrder;
  };

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder;
    attended?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    leaderId?: SortOrder;
    transactionId?: SortOrder;
    isConfirmed?: SortOrder;
  };

  export type EnumWinnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WinnerType | EnumWinnerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumWinnerTypeFilter<$PrismaModel> | $Enums.WinnerType;
  };

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput;
    isNot?: TeamWhereInput;
  };

  export type WinnersCountOrderByAggregateInput = {
    id?: SortOrder;
    teamId?: SortOrder;
    eventId?: SortOrder;
    position?: SortOrder;
  };

  export type WinnersMaxOrderByAggregateInput = {
    id?: SortOrder;
    teamId?: SortOrder;
    eventId?: SortOrder;
    position?: SortOrder;
  };

  export type WinnersMinOrderByAggregateInput = {
    id?: SortOrder;
    teamId?: SortOrder;
    eventId?: SortOrder;
    position?: SortOrder;
  };

  export type EnumWinnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WinnerType | EnumWinnerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumWinnerTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.WinnerType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumWinnerTypeFilter<$PrismaModel>;
    _max?: NestedEnumWinnerTypeFilter<$PrismaModel>;
  };

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput;
    isNot?: StudentWhereInput;
  };

  export type YearScalarRelationFilter = {
    is?: YearWhereInput;
    isNot?: YearWhereInput;
  };

  export type OfferListRelationFilter = {
    every?: OfferWhereInput;
    some?: OfferWhereInput;
    none?: OfferWhereInput;
  };

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PlacementCountOrderByAggregateInput = {
    id?: SortOrder;
    yearId?: SortOrder;
    studentId?: SortOrder;
  };

  export type PlacementMaxOrderByAggregateInput = {
    id?: SortOrder;
    yearId?: SortOrder;
    studentId?: SortOrder;
  };

  export type PlacementMinOrderByAggregateInput = {
    id?: SortOrder;
    yearId?: SortOrder;
    studentId?: SortOrder;
  };

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder;
    companyName?: SortOrder;
    image?: SortOrder;
  };

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder;
    companyName?: SortOrder;
    image?: SortOrder;
  };

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder;
    companyName?: SortOrder;
    image?: SortOrder;
  };

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput;
    isNot?: CompanyWhereInput;
  };

  export type PlacementListRelationFilter = {
    every?: PlacementWhereInput;
    some?: PlacementWhereInput;
    none?: PlacementWhereInput;
  };

  export type PlacementOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder;
    companyId?: SortOrder;
    package?: SortOrder;
  };

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder;
    companyId?: SortOrder;
    package?: SortOrder;
  };

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder;
    companyId?: SortOrder;
    package?: SortOrder;
  };

  export type YearCountOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    companies?: SortOrder;
  };

  export type YearMaxOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
  };

  export type YearMinOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
  };

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput;
    some?: FacultyWhereInput;
    none?: FacultyWhereInput;
  };

  export type StudentListRelationFilter = {
    every?: StudentWhereInput;
    some?: StudentWhereInput;
    none?: StudentWhereInput;
  };

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PatentsCountOrderByAggregateInput = {
    id?: SortOrder;
    patentId?: SortOrder;
    year?: SortOrder;
    title?: SortOrder;
    authors?: SortOrder;
    inventorsName?: SortOrder;
    inventorsAddress?: SortOrder;
    certificate?: SortOrder;
  };

  export type PatentsMaxOrderByAggregateInput = {
    id?: SortOrder;
    patentId?: SortOrder;
    year?: SortOrder;
    title?: SortOrder;
    certificate?: SortOrder;
  };

  export type PatentsMinOrderByAggregateInput = {
    id?: SortOrder;
    patentId?: SortOrder;
    year?: SortOrder;
    title?: SortOrder;
    certificate?: SortOrder;
  };

  export type PublicationCountOrderByAggregateInput = {
    id?: SortOrder;
    authors?: SortOrder;
    title?: SortOrder;
    publish_date?: SortOrder;
    publisher?: SortOrder;
    journal?: SortOrder;
    conference?: SortOrder;
    link?: SortOrder;
    ranking?: SortOrder;
    impact_factor?: SortOrder;
    indexed?: SortOrder;
    publisher_conference?: SortOrder;
    year?: SortOrder;
  };

  export type PublicationAvgOrderByAggregateInput = {
    year?: SortOrder;
  };

  export type PublicationMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    publish_date?: SortOrder;
    publisher?: SortOrder;
    journal?: SortOrder;
    conference?: SortOrder;
    link?: SortOrder;
    ranking?: SortOrder;
    impact_factor?: SortOrder;
    indexed?: SortOrder;
    publisher_conference?: SortOrder;
    year?: SortOrder;
  };

  export type PublicationMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    publish_date?: SortOrder;
    publisher?: SortOrder;
    journal?: SortOrder;
    conference?: SortOrder;
    link?: SortOrder;
    ranking?: SortOrder;
    impact_factor?: SortOrder;
    indexed?: SortOrder;
    publisher_conference?: SortOrder;
    year?: SortOrder;
  };

  export type PublicationSumOrderByAggregateInput = {
    year?: SortOrder;
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type CoreCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CoreCreateWithoutUserInput, CoreUncheckedCreateWithoutUserInput>
      | CoreCreateWithoutUserInput[]
      | CoreUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CoreCreateOrConnectWithoutUserInput
      | CoreCreateOrConnectWithoutUserInput[];
    createMany?: CoreCreateManyUserInputEnvelope;
    connect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
  };

  export type LinksCreateNestedOneWithoutUserInput = {
    create?: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: LinksCreateOrConnectWithoutUserInput;
    connect?: LinksWhereUniqueInput;
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput;
    connect?: StudentWhereUniqueInput;
  };

  export type EventCreateNestedManyWithoutOrganizersInput = {
    create?:
      | XOR<
          EventCreateWithoutOrganizersInput,
          EventUncheckedCreateWithoutOrganizersInput
        >
      | EventCreateWithoutOrganizersInput[]
      | EventUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrganizersInput
      | EventCreateOrConnectWithoutOrganizersInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type TeamCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
      | TeamCreateWithoutUserInput[]
      | TeamUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutUserInput
      | TeamCreateOrConnectWithoutUserInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type CoreUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CoreCreateWithoutUserInput, CoreUncheckedCreateWithoutUserInput>
      | CoreCreateWithoutUserInput[]
      | CoreUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CoreCreateOrConnectWithoutUserInput
      | CoreCreateOrConnectWithoutUserInput[];
    createMany?: CoreCreateManyUserInputEnvelope;
    connect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
  };

  export type LinksUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: LinksCreateOrConnectWithoutUserInput;
    connect?: LinksWhereUniqueInput;
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput;
    connect?: StudentWhereUniqueInput;
  };

  export type EventUncheckedCreateNestedManyWithoutOrganizersInput = {
    create?:
      | XOR<
          EventCreateWithoutOrganizersInput,
          EventUncheckedCreateWithoutOrganizersInput
        >
      | EventCreateWithoutOrganizersInput[]
      | EventUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrganizersInput
      | EventCreateOrConnectWithoutOrganizersInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type TeamUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
      | TeamCreateWithoutUserInput[]
      | TeamUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutUserInput
      | TeamCreateOrConnectWithoutUserInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type CoreUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CoreCreateWithoutUserInput, CoreUncheckedCreateWithoutUserInput>
      | CoreCreateWithoutUserInput[]
      | CoreUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CoreCreateOrConnectWithoutUserInput
      | CoreCreateOrConnectWithoutUserInput[];
    upsert?:
      | CoreUpsertWithWhereUniqueWithoutUserInput
      | CoreUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CoreCreateManyUserInputEnvelope;
    set?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    disconnect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    delete?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    connect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    update?:
      | CoreUpdateWithWhereUniqueWithoutUserInput
      | CoreUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CoreUpdateManyWithWhereWithoutUserInput
      | CoreUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CoreScalarWhereInput | CoreScalarWhereInput[];
  };

  export type LinksUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: LinksCreateOrConnectWithoutUserInput;
    upsert?: LinksUpsertWithoutUserInput;
    disconnect?: LinksWhereInput | boolean;
    delete?: LinksWhereInput | boolean;
    connect?: LinksWhereUniqueInput;
    update?: XOR<
      XOR<
        LinksUpdateToOneWithWhereWithoutUserInput,
        LinksUpdateWithoutUserInput
      >,
      LinksUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput;
    upsert?: StudentUpsertWithoutUserInput;
    disconnect?: StudentWhereInput | boolean;
    delete?: StudentWhereInput | boolean;
    connect?: StudentWhereUniqueInput;
    update?: XOR<
      XOR<
        StudentUpdateToOneWithWhereWithoutUserInput,
        StudentUpdateWithoutUserInput
      >,
      StudentUncheckedUpdateWithoutUserInput
    >;
  };

  export type EventUpdateManyWithoutOrganizersNestedInput = {
    create?:
      | XOR<
          EventCreateWithoutOrganizersInput,
          EventUncheckedCreateWithoutOrganizersInput
        >
      | EventCreateWithoutOrganizersInput[]
      | EventUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrganizersInput
      | EventCreateOrConnectWithoutOrganizersInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutOrganizersInput
      | EventUpsertWithWhereUniqueWithoutOrganizersInput[];
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutOrganizersInput
      | EventUpdateWithWhereUniqueWithoutOrganizersInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutOrganizersInput
      | EventUpdateManyWithWhereWithoutOrganizersInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type TeamUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
      | TeamCreateWithoutUserInput[]
      | TeamUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutUserInput
      | TeamCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutUserInput
      | TeamUpsertWithWhereUniqueWithoutUserInput[];
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutUserInput
      | TeamUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutUserInput
      | TeamUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type CoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CoreCreateWithoutUserInput, CoreUncheckedCreateWithoutUserInput>
      | CoreCreateWithoutUserInput[]
      | CoreUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CoreCreateOrConnectWithoutUserInput
      | CoreCreateOrConnectWithoutUserInput[];
    upsert?:
      | CoreUpsertWithWhereUniqueWithoutUserInput
      | CoreUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CoreCreateManyUserInputEnvelope;
    set?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    disconnect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    delete?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    connect?: CoreWhereUniqueInput | CoreWhereUniqueInput[];
    update?:
      | CoreUpdateWithWhereUniqueWithoutUserInput
      | CoreUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CoreUpdateManyWithWhereWithoutUserInput
      | CoreUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CoreScalarWhereInput | CoreScalarWhereInput[];
  };

  export type LinksUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: LinksCreateOrConnectWithoutUserInput;
    upsert?: LinksUpsertWithoutUserInput;
    disconnect?: LinksWhereInput | boolean;
    delete?: LinksWhereInput | boolean;
    connect?: LinksWhereUniqueInput;
    update?: XOR<
      XOR<
        LinksUpdateToOneWithWhereWithoutUserInput,
        LinksUpdateWithoutUserInput
      >,
      LinksUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput;
    upsert?: StudentUpsertWithoutUserInput;
    disconnect?: StudentWhereInput | boolean;
    delete?: StudentWhereInput | boolean;
    connect?: StudentWhereUniqueInput;
    update?: XOR<
      XOR<
        StudentUpdateToOneWithWhereWithoutUserInput,
        StudentUpdateWithoutUserInput
      >,
      StudentUncheckedUpdateWithoutUserInput
    >;
  };

  export type EventUncheckedUpdateManyWithoutOrganizersNestedInput = {
    create?:
      | XOR<
          EventCreateWithoutOrganizersInput,
          EventUncheckedCreateWithoutOrganizersInput
        >
      | EventCreateWithoutOrganizersInput[]
      | EventUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrganizersInput
      | EventCreateOrConnectWithoutOrganizersInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutOrganizersInput
      | EventUpsertWithWhereUniqueWithoutOrganizersInput[];
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutOrganizersInput
      | EventUpdateWithWhereUniqueWithoutOrganizersInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutOrganizersInput
      | EventUpdateManyWithWhereWithoutOrganizersInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type TeamUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
      | TeamCreateWithoutUserInput[]
      | TeamUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutUserInput
      | TeamCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutUserInput
      | TeamUpsertWithWhereUniqueWithoutUserInput[];
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutUserInput
      | TeamUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutUserInput
      | TeamUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAccountsInput,
        UserUpdateWithoutAccountsInput
      >,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionsInput,
        UserUpdateWithoutSessionsInput
      >,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type PlacementCreateNestedOneWithoutStudentInput = {
    create?: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: PlacementCreateOrConnectWithoutStudentInput;
    connect?: PlacementWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<
      UserCreateWithoutStudentInput,
      UserUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput;
    connect?: UserWhereUniqueInput;
  };

  export type PatentsCreateNestedManyWithoutStudentInput = {
    create?:
      | XOR<
          PatentsCreateWithoutStudentInput,
          PatentsUncheckedCreateWithoutStudentInput
        >
      | PatentsCreateWithoutStudentInput[]
      | PatentsUncheckedCreateWithoutStudentInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutStudentInput
      | PatentsCreateOrConnectWithoutStudentInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
  };

  export type PlacementUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: PlacementCreateOrConnectWithoutStudentInput;
    connect?: PlacementWhereUniqueInput;
  };

  export type PatentsUncheckedCreateNestedManyWithoutStudentInput = {
    create?:
      | XOR<
          PatentsCreateWithoutStudentInput,
          PatentsUncheckedCreateWithoutStudentInput
        >
      | PatentsCreateWithoutStudentInput[]
      | PatentsUncheckedCreateWithoutStudentInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutStudentInput
      | PatentsCreateOrConnectWithoutStudentInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
  };

  export type PlacementUpdateOneWithoutStudentNestedInput = {
    create?: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: PlacementCreateOrConnectWithoutStudentInput;
    upsert?: PlacementUpsertWithoutStudentInput;
    disconnect?: PlacementWhereInput | boolean;
    delete?: PlacementWhereInput | boolean;
    connect?: PlacementWhereUniqueInput;
    update?: XOR<
      XOR<
        PlacementUpdateToOneWithWhereWithoutStudentInput,
        PlacementUpdateWithoutStudentInput
      >,
      PlacementUncheckedUpdateWithoutStudentInput
    >;
  };

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<
      UserCreateWithoutStudentInput,
      UserUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput;
    upsert?: UserUpsertWithoutStudentInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutStudentInput,
        UserUpdateWithoutStudentInput
      >,
      UserUncheckedUpdateWithoutStudentInput
    >;
  };

  export type PatentsUpdateManyWithoutStudentNestedInput = {
    create?:
      | XOR<
          PatentsCreateWithoutStudentInput,
          PatentsUncheckedCreateWithoutStudentInput
        >
      | PatentsCreateWithoutStudentInput[]
      | PatentsUncheckedCreateWithoutStudentInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutStudentInput
      | PatentsCreateOrConnectWithoutStudentInput[];
    upsert?:
      | PatentsUpsertWithWhereUniqueWithoutStudentInput
      | PatentsUpsertWithWhereUniqueWithoutStudentInput[];
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    update?:
      | PatentsUpdateWithWhereUniqueWithoutStudentInput
      | PatentsUpdateWithWhereUniqueWithoutStudentInput[];
    updateMany?:
      | PatentsUpdateManyWithWhereWithoutStudentInput
      | PatentsUpdateManyWithWhereWithoutStudentInput[];
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
  };

  export type PlacementUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
    connectOrCreate?: PlacementCreateOrConnectWithoutStudentInput;
    upsert?: PlacementUpsertWithoutStudentInput;
    disconnect?: PlacementWhereInput | boolean;
    delete?: PlacementWhereInput | boolean;
    connect?: PlacementWhereUniqueInput;
    update?: XOR<
      XOR<
        PlacementUpdateToOneWithWhereWithoutStudentInput,
        PlacementUpdateWithoutStudentInput
      >,
      PlacementUncheckedUpdateWithoutStudentInput
    >;
  };

  export type PatentsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?:
      | XOR<
          PatentsCreateWithoutStudentInput,
          PatentsUncheckedCreateWithoutStudentInput
        >
      | PatentsCreateWithoutStudentInput[]
      | PatentsUncheckedCreateWithoutStudentInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutStudentInput
      | PatentsCreateOrConnectWithoutStudentInput[];
    upsert?:
      | PatentsUpsertWithWhereUniqueWithoutStudentInput
      | PatentsUpsertWithWhereUniqueWithoutStudentInput[];
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    update?:
      | PatentsUpdateWithWhereUniqueWithoutStudentInput
      | PatentsUpdateWithWhereUniqueWithoutStudentInput[];
    updateMany?:
      | PatentsUpdateManyWithWhereWithoutStudentInput
      | PatentsUpdateManyWithWhereWithoutStudentInput[];
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutCoreInput = {
    create?: XOR<
      UserCreateWithoutCoreInput,
      UserUncheckedCreateWithoutCoreInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCoreInput;
    connect?: UserWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutCoreNestedInput = {
    create?: XOR<
      UserCreateWithoutCoreInput,
      UserUncheckedCreateWithoutCoreInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCoreInput;
    upsert?: UserUpsertWithoutCoreInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCoreInput, UserUpdateWithoutCoreInput>,
      UserUncheckedUpdateWithoutCoreInput
    >;
  };

  export type FacultyCreateaboutInput = {
    set: string[];
  };

  export type PatentsCreateNestedManyWithoutFacultyInput = {
    create?:
      | XOR<
          PatentsCreateWithoutFacultyInput,
          PatentsUncheckedCreateWithoutFacultyInput
        >
      | PatentsCreateWithoutFacultyInput[]
      | PatentsUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutFacultyInput
      | PatentsCreateOrConnectWithoutFacultyInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
  };

  export type PublicationCreateNestedManyWithoutFacultyInput = {
    create?:
      | XOR<
          PublicationCreateWithoutFacultyInput,
          PublicationUncheckedCreateWithoutFacultyInput
        >
      | PublicationCreateWithoutFacultyInput[]
      | PublicationUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PublicationCreateOrConnectWithoutFacultyInput
      | PublicationCreateOrConnectWithoutFacultyInput[];
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
  };

  export type PatentsUncheckedCreateNestedManyWithoutFacultyInput = {
    create?:
      | XOR<
          PatentsCreateWithoutFacultyInput,
          PatentsUncheckedCreateWithoutFacultyInput
        >
      | PatentsCreateWithoutFacultyInput[]
      | PatentsUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutFacultyInput
      | PatentsCreateOrConnectWithoutFacultyInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
  };

  export type PublicationUncheckedCreateNestedManyWithoutFacultyInput = {
    create?:
      | XOR<
          PublicationCreateWithoutFacultyInput,
          PublicationUncheckedCreateWithoutFacultyInput
        >
      | PublicationCreateWithoutFacultyInput[]
      | PublicationUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PublicationCreateOrConnectWithoutFacultyInput
      | PublicationCreateOrConnectWithoutFacultyInput[];
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
  };

  export type FacultyUpdateaboutInput = {
    set?: string[];
    push?: string | string[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type PatentsUpdateManyWithoutFacultyNestedInput = {
    create?:
      | XOR<
          PatentsCreateWithoutFacultyInput,
          PatentsUncheckedCreateWithoutFacultyInput
        >
      | PatentsCreateWithoutFacultyInput[]
      | PatentsUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutFacultyInput
      | PatentsCreateOrConnectWithoutFacultyInput[];
    upsert?:
      | PatentsUpsertWithWhereUniqueWithoutFacultyInput
      | PatentsUpsertWithWhereUniqueWithoutFacultyInput[];
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    update?:
      | PatentsUpdateWithWhereUniqueWithoutFacultyInput
      | PatentsUpdateWithWhereUniqueWithoutFacultyInput[];
    updateMany?:
      | PatentsUpdateManyWithWhereWithoutFacultyInput
      | PatentsUpdateManyWithWhereWithoutFacultyInput[];
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
  };

  export type PublicationUpdateManyWithoutFacultyNestedInput = {
    create?:
      | XOR<
          PublicationCreateWithoutFacultyInput,
          PublicationUncheckedCreateWithoutFacultyInput
        >
      | PublicationCreateWithoutFacultyInput[]
      | PublicationUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PublicationCreateOrConnectWithoutFacultyInput
      | PublicationCreateOrConnectWithoutFacultyInput[];
    upsert?:
      | PublicationUpsertWithWhereUniqueWithoutFacultyInput
      | PublicationUpsertWithWhereUniqueWithoutFacultyInput[];
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    update?:
      | PublicationUpdateWithWhereUniqueWithoutFacultyInput
      | PublicationUpdateWithWhereUniqueWithoutFacultyInput[];
    updateMany?:
      | PublicationUpdateManyWithWhereWithoutFacultyInput
      | PublicationUpdateManyWithWhereWithoutFacultyInput[];
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[];
  };

  export type PatentsUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?:
      | XOR<
          PatentsCreateWithoutFacultyInput,
          PatentsUncheckedCreateWithoutFacultyInput
        >
      | PatentsCreateWithoutFacultyInput[]
      | PatentsUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PatentsCreateOrConnectWithoutFacultyInput
      | PatentsCreateOrConnectWithoutFacultyInput[];
    upsert?:
      | PatentsUpsertWithWhereUniqueWithoutFacultyInput
      | PatentsUpsertWithWhereUniqueWithoutFacultyInput[];
    set?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    disconnect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    delete?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    connect?: PatentsWhereUniqueInput | PatentsWhereUniqueInput[];
    update?:
      | PatentsUpdateWithWhereUniqueWithoutFacultyInput
      | PatentsUpdateWithWhereUniqueWithoutFacultyInput[];
    updateMany?:
      | PatentsUpdateManyWithWhereWithoutFacultyInput
      | PatentsUpdateManyWithWhereWithoutFacultyInput[];
    deleteMany?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
  };

  export type PublicationUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?:
      | XOR<
          PublicationCreateWithoutFacultyInput,
          PublicationUncheckedCreateWithoutFacultyInput
        >
      | PublicationCreateWithoutFacultyInput[]
      | PublicationUncheckedCreateWithoutFacultyInput[];
    connectOrCreate?:
      | PublicationCreateOrConnectWithoutFacultyInput
      | PublicationCreateOrConnectWithoutFacultyInput[];
    upsert?:
      | PublicationUpsertWithWhereUniqueWithoutFacultyInput
      | PublicationUpsertWithWhereUniqueWithoutFacultyInput[];
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[];
    update?:
      | PublicationUpdateWithWhereUniqueWithoutFacultyInput
      | PublicationUpdateWithWhereUniqueWithoutFacultyInput[];
    updateMany?:
      | PublicationUpdateManyWithWhereWithoutFacultyInput
      | PublicationUpdateManyWithWhereWithoutFacultyInput[];
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[];
  };

  export type EventCreateguestsInput = {
    set: string[];
  };

  export type TeamCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type WinnersCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          WinnersCreateWithoutEventInput,
          WinnersUncheckedCreateWithoutEventInput
        >
      | WinnersCreateWithoutEventInput[]
      | WinnersUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | WinnersCreateOrConnectWithoutEventInput
      | WinnersCreateOrConnectWithoutEventInput[];
    createMany?: WinnersCreateManyEventInputEnvelope;
    connect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
  };

  export type UserCreateNestedManyWithoutOrganizersInput = {
    create?:
      | XOR<
          UserCreateWithoutOrganizersInput,
          UserUncheckedCreateWithoutOrganizersInput
        >
      | UserCreateWithoutOrganizersInput[]
      | UserUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizersInput
      | UserCreateOrConnectWithoutOrganizersInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type TeamUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type WinnersUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          WinnersCreateWithoutEventInput,
          WinnersUncheckedCreateWithoutEventInput
        >
      | WinnersCreateWithoutEventInput[]
      | WinnersUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | WinnersCreateOrConnectWithoutEventInput
      | WinnersCreateOrConnectWithoutEventInput[];
    createMany?: WinnersCreateManyEventInputEnvelope;
    connect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
  };

  export type UserUncheckedCreateNestedManyWithoutOrganizersInput = {
    create?:
      | XOR<
          UserCreateWithoutOrganizersInput,
          UserUncheckedCreateWithoutOrganizersInput
        >
      | UserCreateWithoutOrganizersInput[]
      | UserUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizersInput
      | UserCreateOrConnectWithoutOrganizersInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type EventUpdateguestsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType;
  };

  export type EnumEventCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EventCategory;
  };

  export type TeamUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutEventInput
      | TeamUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutEventInput
      | TeamUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutEventInput
      | TeamUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type WinnersUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          WinnersCreateWithoutEventInput,
          WinnersUncheckedCreateWithoutEventInput
        >
      | WinnersCreateWithoutEventInput[]
      | WinnersUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | WinnersCreateOrConnectWithoutEventInput
      | WinnersCreateOrConnectWithoutEventInput[];
    upsert?:
      | WinnersUpsertWithWhereUniqueWithoutEventInput
      | WinnersUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: WinnersCreateManyEventInputEnvelope;
    set?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    disconnect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    delete?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    connect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    update?:
      | WinnersUpdateWithWhereUniqueWithoutEventInput
      | WinnersUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | WinnersUpdateManyWithWhereWithoutEventInput
      | WinnersUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: WinnersScalarWhereInput | WinnersScalarWhereInput[];
  };

  export type UserUpdateManyWithoutOrganizersNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutOrganizersInput,
          UserUncheckedCreateWithoutOrganizersInput
        >
      | UserCreateWithoutOrganizersInput[]
      | UserUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizersInput
      | UserCreateOrConnectWithoutOrganizersInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutOrganizersInput
      | UserUpsertWithWhereUniqueWithoutOrganizersInput[];
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutOrganizersInput
      | UserUpdateWithWhereUniqueWithoutOrganizersInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutOrganizersInput
      | UserUpdateManyWithWhereWithoutOrganizersInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type TeamUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutEventInput
      | TeamUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutEventInput
      | TeamUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutEventInput
      | TeamUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type WinnersUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          WinnersCreateWithoutEventInput,
          WinnersUncheckedCreateWithoutEventInput
        >
      | WinnersCreateWithoutEventInput[]
      | WinnersUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | WinnersCreateOrConnectWithoutEventInput
      | WinnersCreateOrConnectWithoutEventInput[];
    upsert?:
      | WinnersUpsertWithWhereUniqueWithoutEventInput
      | WinnersUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: WinnersCreateManyEventInputEnvelope;
    set?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    disconnect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    delete?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    connect?: WinnersWhereUniqueInput | WinnersWhereUniqueInput[];
    update?:
      | WinnersUpdateWithWhereUniqueWithoutEventInput
      | WinnersUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | WinnersUpdateManyWithWhereWithoutEventInput
      | WinnersUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: WinnersScalarWhereInput | WinnersScalarWhereInput[];
  };

  export type UserUncheckedUpdateManyWithoutOrganizersNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutOrganizersInput,
          UserUncheckedCreateWithoutOrganizersInput
        >
      | UserCreateWithoutOrganizersInput[]
      | UserUncheckedCreateWithoutOrganizersInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizersInput
      | UserCreateOrConnectWithoutOrganizersInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutOrganizersInput
      | UserUpsertWithWhereUniqueWithoutOrganizersInput[];
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutOrganizersInput
      | UserUpdateWithWhereUniqueWithoutOrganizersInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutOrganizersInput
      | UserUpdateManyWithWhereWithoutOrganizersInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type LinksCreateorderInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutLinksInput = {
    create?: XOR<
      UserCreateWithoutLinksInput,
      UserUncheckedCreateWithoutLinksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput;
    connect?: UserWhereUniqueInput;
  };

  export type LinksUpdateorderInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<
      UserCreateWithoutLinksInput,
      UserUncheckedCreateWithoutLinksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput;
    upsert?: UserUpsertWithoutLinksInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutLinksInput,
        UserUpdateWithoutLinksInput
      >,
      UserUncheckedUpdateWithoutLinksInput
    >;
  };

  export type EventCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput;
    connect?: EventWhereUniqueInput;
  };

  export type WinnersCreateNestedOneWithoutTeamInput = {
    create?: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
    connectOrCreate?: WinnersCreateOrConnectWithoutTeamInput;
    connect?: WinnersWhereUniqueInput;
  };

  export type UserCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
      | UserCreateWithoutTeamInput[]
      | UserUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutTeamInput
      | UserCreateOrConnectWithoutTeamInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type WinnersUncheckedCreateNestedOneWithoutTeamInput = {
    create?: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
    connectOrCreate?: WinnersCreateOrConnectWithoutTeamInput;
    connect?: WinnersWhereUniqueInput;
  };

  export type UserUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
      | UserCreateWithoutTeamInput[]
      | UserUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutTeamInput
      | UserCreateOrConnectWithoutTeamInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type EventUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput;
    upsert?: EventUpsertWithoutParticipantsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutParticipantsInput,
        EventUpdateWithoutParticipantsInput
      >,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type WinnersUpdateOneWithoutTeamNestedInput = {
    create?: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
    connectOrCreate?: WinnersCreateOrConnectWithoutTeamInput;
    upsert?: WinnersUpsertWithoutTeamInput;
    disconnect?: WinnersWhereInput | boolean;
    delete?: WinnersWhereInput | boolean;
    connect?: WinnersWhereUniqueInput;
    update?: XOR<
      XOR<
        WinnersUpdateToOneWithWhereWithoutTeamInput,
        WinnersUpdateWithoutTeamInput
      >,
      WinnersUncheckedUpdateWithoutTeamInput
    >;
  };

  export type UserUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
      | UserCreateWithoutTeamInput[]
      | UserUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutTeamInput
      | UserCreateOrConnectWithoutTeamInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutTeamInput
      | UserUpsertWithWhereUniqueWithoutTeamInput[];
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutTeamInput
      | UserUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutTeamInput
      | UserUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type WinnersUncheckedUpdateOneWithoutTeamNestedInput = {
    create?: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
    connectOrCreate?: WinnersCreateOrConnectWithoutTeamInput;
    upsert?: WinnersUpsertWithoutTeamInput;
    disconnect?: WinnersWhereInput | boolean;
    delete?: WinnersWhereInput | boolean;
    connect?: WinnersWhereUniqueInput;
    update?: XOR<
      XOR<
        WinnersUpdateToOneWithWhereWithoutTeamInput,
        WinnersUpdateWithoutTeamInput
      >,
      WinnersUncheckedUpdateWithoutTeamInput
    >;
  };

  export type UserUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
      | UserCreateWithoutTeamInput[]
      | UserUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutTeamInput
      | UserCreateOrConnectWithoutTeamInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutTeamInput
      | UserUpsertWithWhereUniqueWithoutTeamInput[];
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutTeamInput
      | UserUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutTeamInput
      | UserUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type EventCreateNestedOneWithoutWinnersInput = {
    create?: XOR<
      EventCreateWithoutWinnersInput,
      EventUncheckedCreateWithoutWinnersInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutWinnersInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutWinnerInput = {
    create?: XOR<
      TeamCreateWithoutWinnerInput,
      TeamUncheckedCreateWithoutWinnerInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutWinnerInput;
    connect?: TeamWhereUniqueInput;
  };

  export type EnumWinnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.WinnerType;
  };

  export type EventUpdateOneRequiredWithoutWinnersNestedInput = {
    create?: XOR<
      EventCreateWithoutWinnersInput,
      EventUncheckedCreateWithoutWinnersInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutWinnersInput;
    upsert?: EventUpsertWithoutWinnersInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutWinnersInput,
        EventUpdateWithoutWinnersInput
      >,
      EventUncheckedUpdateWithoutWinnersInput
    >;
  };

  export type TeamUpdateOneRequiredWithoutWinnerNestedInput = {
    create?: XOR<
      TeamCreateWithoutWinnerInput,
      TeamUncheckedCreateWithoutWinnerInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutWinnerInput;
    upsert?: TeamUpsertWithoutWinnerInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutWinnerInput,
        TeamUpdateWithoutWinnerInput
      >,
      TeamUncheckedUpdateWithoutWinnerInput
    >;
  };

  export type StudentCreateNestedOneWithoutPlacementInput = {
    create?: XOR<
      StudentCreateWithoutPlacementInput,
      StudentUncheckedCreateWithoutPlacementInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutPlacementInput;
    connect?: StudentWhereUniqueInput;
  };

  export type YearCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<
      YearCreateWithoutPlacementsInput,
      YearUncheckedCreateWithoutPlacementsInput
    >;
    connectOrCreate?: YearCreateOrConnectWithoutPlacementsInput;
    connect?: YearWhereUniqueInput;
  };

  export type OfferCreateNestedManyWithoutPlacementsInput = {
    create?:
      | XOR<
          OfferCreateWithoutPlacementsInput,
          OfferUncheckedCreateWithoutPlacementsInput
        >
      | OfferCreateWithoutPlacementsInput[]
      | OfferUncheckedCreateWithoutPlacementsInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutPlacementsInput
      | OfferCreateOrConnectWithoutPlacementsInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
  };

  export type OfferUncheckedCreateNestedManyWithoutPlacementsInput = {
    create?:
      | XOR<
          OfferCreateWithoutPlacementsInput,
          OfferUncheckedCreateWithoutPlacementsInput
        >
      | OfferCreateWithoutPlacementsInput[]
      | OfferUncheckedCreateWithoutPlacementsInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutPlacementsInput
      | OfferCreateOrConnectWithoutPlacementsInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
  };

  export type StudentUpdateOneRequiredWithoutPlacementNestedInput = {
    create?: XOR<
      StudentCreateWithoutPlacementInput,
      StudentUncheckedCreateWithoutPlacementInput
    >;
    connectOrCreate?: StudentCreateOrConnectWithoutPlacementInput;
    upsert?: StudentUpsertWithoutPlacementInput;
    connect?: StudentWhereUniqueInput;
    update?: XOR<
      XOR<
        StudentUpdateToOneWithWhereWithoutPlacementInput,
        StudentUpdateWithoutPlacementInput
      >,
      StudentUncheckedUpdateWithoutPlacementInput
    >;
  };

  export type YearUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<
      YearCreateWithoutPlacementsInput,
      YearUncheckedCreateWithoutPlacementsInput
    >;
    connectOrCreate?: YearCreateOrConnectWithoutPlacementsInput;
    upsert?: YearUpsertWithoutPlacementsInput;
    connect?: YearWhereUniqueInput;
    update?: XOR<
      XOR<
        YearUpdateToOneWithWhereWithoutPlacementsInput,
        YearUpdateWithoutPlacementsInput
      >,
      YearUncheckedUpdateWithoutPlacementsInput
    >;
  };

  export type OfferUpdateManyWithoutPlacementsNestedInput = {
    create?:
      | XOR<
          OfferCreateWithoutPlacementsInput,
          OfferUncheckedCreateWithoutPlacementsInput
        >
      | OfferCreateWithoutPlacementsInput[]
      | OfferUncheckedCreateWithoutPlacementsInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutPlacementsInput
      | OfferCreateOrConnectWithoutPlacementsInput[];
    upsert?:
      | OfferUpsertWithWhereUniqueWithoutPlacementsInput
      | OfferUpsertWithWhereUniqueWithoutPlacementsInput[];
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    update?:
      | OfferUpdateWithWhereUniqueWithoutPlacementsInput
      | OfferUpdateWithWhereUniqueWithoutPlacementsInput[];
    updateMany?:
      | OfferUpdateManyWithWhereWithoutPlacementsInput
      | OfferUpdateManyWithWhereWithoutPlacementsInput[];
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[];
  };

  export type OfferUncheckedUpdateManyWithoutPlacementsNestedInput = {
    create?:
      | XOR<
          OfferCreateWithoutPlacementsInput,
          OfferUncheckedCreateWithoutPlacementsInput
        >
      | OfferCreateWithoutPlacementsInput[]
      | OfferUncheckedCreateWithoutPlacementsInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutPlacementsInput
      | OfferCreateOrConnectWithoutPlacementsInput[];
    upsert?:
      | OfferUpsertWithWhereUniqueWithoutPlacementsInput
      | OfferUpsertWithWhereUniqueWithoutPlacementsInput[];
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    update?:
      | OfferUpdateWithWhereUniqueWithoutPlacementsInput
      | OfferUpdateWithWhereUniqueWithoutPlacementsInput[];
    updateMany?:
      | OfferUpdateManyWithWhereWithoutPlacementsInput
      | OfferUpdateManyWithWhereWithoutPlacementsInput[];
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[];
  };

  export type OfferCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<
          OfferCreateWithoutCompanyInput,
          OfferUncheckedCreateWithoutCompanyInput
        >
      | OfferCreateWithoutCompanyInput[]
      | OfferUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutCompanyInput
      | OfferCreateOrConnectWithoutCompanyInput[];
    createMany?: OfferCreateManyCompanyInputEnvelope;
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
  };

  export type OfferUncheckedCreateNestedManyWithoutCompanyInput = {
    create?:
      | XOR<
          OfferCreateWithoutCompanyInput,
          OfferUncheckedCreateWithoutCompanyInput
        >
      | OfferCreateWithoutCompanyInput[]
      | OfferUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutCompanyInput
      | OfferCreateOrConnectWithoutCompanyInput[];
    createMany?: OfferCreateManyCompanyInputEnvelope;
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
  };

  export type OfferUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<
          OfferCreateWithoutCompanyInput,
          OfferUncheckedCreateWithoutCompanyInput
        >
      | OfferCreateWithoutCompanyInput[]
      | OfferUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutCompanyInput
      | OfferCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | OfferUpsertWithWhereUniqueWithoutCompanyInput
      | OfferUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: OfferCreateManyCompanyInputEnvelope;
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    update?:
      | OfferUpdateWithWhereUniqueWithoutCompanyInput
      | OfferUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | OfferUpdateManyWithWhereWithoutCompanyInput
      | OfferUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[];
  };

  export type OfferUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?:
      | XOR<
          OfferCreateWithoutCompanyInput,
          OfferUncheckedCreateWithoutCompanyInput
        >
      | OfferCreateWithoutCompanyInput[]
      | OfferUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
      | OfferCreateOrConnectWithoutCompanyInput
      | OfferCreateOrConnectWithoutCompanyInput[];
    upsert?:
      | OfferUpsertWithWhereUniqueWithoutCompanyInput
      | OfferUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: OfferCreateManyCompanyInputEnvelope;
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[];
    update?:
      | OfferUpdateWithWhereUniqueWithoutCompanyInput
      | OfferUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
      | OfferUpdateManyWithWhereWithoutCompanyInput
      | OfferUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[];
  };

  export type CompanyCreateNestedOneWithoutOffersInput = {
    create?: XOR<
      CompanyCreateWithoutOffersInput,
      CompanyUncheckedCreateWithoutOffersInput
    >;
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersInput;
    connect?: CompanyWhereUniqueInput;
  };

  export type PlacementCreateNestedManyWithoutOffersInput = {
    create?:
      | XOR<
          PlacementCreateWithoutOffersInput,
          PlacementUncheckedCreateWithoutOffersInput
        >
      | PlacementCreateWithoutOffersInput[]
      | PlacementUncheckedCreateWithoutOffersInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutOffersInput
      | PlacementCreateOrConnectWithoutOffersInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
  };

  export type PlacementUncheckedCreateNestedManyWithoutOffersInput = {
    create?:
      | XOR<
          PlacementCreateWithoutOffersInput,
          PlacementUncheckedCreateWithoutOffersInput
        >
      | PlacementCreateWithoutOffersInput[]
      | PlacementUncheckedCreateWithoutOffersInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutOffersInput
      | PlacementCreateOrConnectWithoutOffersInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
  };

  export type CompanyUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<
      CompanyCreateWithoutOffersInput,
      CompanyUncheckedCreateWithoutOffersInput
    >;
    connectOrCreate?: CompanyCreateOrConnectWithoutOffersInput;
    upsert?: CompanyUpsertWithoutOffersInput;
    connect?: CompanyWhereUniqueInput;
    update?: XOR<
      XOR<
        CompanyUpdateToOneWithWhereWithoutOffersInput,
        CompanyUpdateWithoutOffersInput
      >,
      CompanyUncheckedUpdateWithoutOffersInput
    >;
  };

  export type PlacementUpdateManyWithoutOffersNestedInput = {
    create?:
      | XOR<
          PlacementCreateWithoutOffersInput,
          PlacementUncheckedCreateWithoutOffersInput
        >
      | PlacementCreateWithoutOffersInput[]
      | PlacementUncheckedCreateWithoutOffersInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutOffersInput
      | PlacementCreateOrConnectWithoutOffersInput[];
    upsert?:
      | PlacementUpsertWithWhereUniqueWithoutOffersInput
      | PlacementUpsertWithWhereUniqueWithoutOffersInput[];
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    update?:
      | PlacementUpdateWithWhereUniqueWithoutOffersInput
      | PlacementUpdateWithWhereUniqueWithoutOffersInput[];
    updateMany?:
      | PlacementUpdateManyWithWhereWithoutOffersInput
      | PlacementUpdateManyWithWhereWithoutOffersInput[];
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
  };

  export type PlacementUncheckedUpdateManyWithoutOffersNestedInput = {
    create?:
      | XOR<
          PlacementCreateWithoutOffersInput,
          PlacementUncheckedCreateWithoutOffersInput
        >
      | PlacementCreateWithoutOffersInput[]
      | PlacementUncheckedCreateWithoutOffersInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutOffersInput
      | PlacementCreateOrConnectWithoutOffersInput[];
    upsert?:
      | PlacementUpsertWithWhereUniqueWithoutOffersInput
      | PlacementUpsertWithWhereUniqueWithoutOffersInput[];
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    update?:
      | PlacementUpdateWithWhereUniqueWithoutOffersInput
      | PlacementUpdateWithWhereUniqueWithoutOffersInput[];
    updateMany?:
      | PlacementUpdateManyWithWhereWithoutOffersInput
      | PlacementUpdateManyWithWhereWithoutOffersInput[];
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
  };

  export type YearCreatecompaniesInput = {
    set: string[];
  };

  export type PlacementCreateNestedManyWithoutYearInput = {
    create?:
      | XOR<
          PlacementCreateWithoutYearInput,
          PlacementUncheckedCreateWithoutYearInput
        >
      | PlacementCreateWithoutYearInput[]
      | PlacementUncheckedCreateWithoutYearInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutYearInput
      | PlacementCreateOrConnectWithoutYearInput[];
    createMany?: PlacementCreateManyYearInputEnvelope;
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
  };

  export type PlacementUncheckedCreateNestedManyWithoutYearInput = {
    create?:
      | XOR<
          PlacementCreateWithoutYearInput,
          PlacementUncheckedCreateWithoutYearInput
        >
      | PlacementCreateWithoutYearInput[]
      | PlacementUncheckedCreateWithoutYearInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutYearInput
      | PlacementCreateOrConnectWithoutYearInput[];
    createMany?: PlacementCreateManyYearInputEnvelope;
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
  };

  export type YearUpdatecompaniesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type PlacementUpdateManyWithoutYearNestedInput = {
    create?:
      | XOR<
          PlacementCreateWithoutYearInput,
          PlacementUncheckedCreateWithoutYearInput
        >
      | PlacementCreateWithoutYearInput[]
      | PlacementUncheckedCreateWithoutYearInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutYearInput
      | PlacementCreateOrConnectWithoutYearInput[];
    upsert?:
      | PlacementUpsertWithWhereUniqueWithoutYearInput
      | PlacementUpsertWithWhereUniqueWithoutYearInput[];
    createMany?: PlacementCreateManyYearInputEnvelope;
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    update?:
      | PlacementUpdateWithWhereUniqueWithoutYearInput
      | PlacementUpdateWithWhereUniqueWithoutYearInput[];
    updateMany?:
      | PlacementUpdateManyWithWhereWithoutYearInput
      | PlacementUpdateManyWithWhereWithoutYearInput[];
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
  };

  export type PlacementUncheckedUpdateManyWithoutYearNestedInput = {
    create?:
      | XOR<
          PlacementCreateWithoutYearInput,
          PlacementUncheckedCreateWithoutYearInput
        >
      | PlacementCreateWithoutYearInput[]
      | PlacementUncheckedCreateWithoutYearInput[];
    connectOrCreate?:
      | PlacementCreateOrConnectWithoutYearInput
      | PlacementCreateOrConnectWithoutYearInput[];
    upsert?:
      | PlacementUpsertWithWhereUniqueWithoutYearInput
      | PlacementUpsertWithWhereUniqueWithoutYearInput[];
    createMany?: PlacementCreateManyYearInputEnvelope;
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[];
    update?:
      | PlacementUpdateWithWhereUniqueWithoutYearInput
      | PlacementUpdateWithWhereUniqueWithoutYearInput[];
    updateMany?:
      | PlacementUpdateManyWithWhereWithoutYearInput
      | PlacementUpdateManyWithWhereWithoutYearInput[];
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
  };

  export type PatentsCreateauthorsInput = {
    set: string[];
  };

  export type PatentsCreateinventorsNameInput = {
    set: string[];
  };

  export type PatentsCreateinventorsAddressInput = {
    set: string[];
  };

  export type FacultyCreateNestedManyWithoutPatentsInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPatentsInput,
          FacultyUncheckedCreateWithoutPatentsInput
        >
      | FacultyCreateWithoutPatentsInput[]
      | FacultyUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPatentsInput
      | FacultyCreateOrConnectWithoutPatentsInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
  };

  export type StudentCreateNestedManyWithoutPatentsInput = {
    create?:
      | XOR<
          StudentCreateWithoutPatentsInput,
          StudentUncheckedCreateWithoutPatentsInput
        >
      | StudentCreateWithoutPatentsInput[]
      | StudentUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | StudentCreateOrConnectWithoutPatentsInput
      | StudentCreateOrConnectWithoutPatentsInput[];
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
  };

  export type FacultyUncheckedCreateNestedManyWithoutPatentsInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPatentsInput,
          FacultyUncheckedCreateWithoutPatentsInput
        >
      | FacultyCreateWithoutPatentsInput[]
      | FacultyUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPatentsInput
      | FacultyCreateOrConnectWithoutPatentsInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
  };

  export type StudentUncheckedCreateNestedManyWithoutPatentsInput = {
    create?:
      | XOR<
          StudentCreateWithoutPatentsInput,
          StudentUncheckedCreateWithoutPatentsInput
        >
      | StudentCreateWithoutPatentsInput[]
      | StudentUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | StudentCreateOrConnectWithoutPatentsInput
      | StudentCreateOrConnectWithoutPatentsInput[];
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
  };

  export type PatentsUpdateauthorsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type PatentsUpdateinventorsNameInput = {
    set?: string[];
    push?: string | string[];
  };

  export type PatentsUpdateinventorsAddressInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FacultyUpdateManyWithoutPatentsNestedInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPatentsInput,
          FacultyUncheckedCreateWithoutPatentsInput
        >
      | FacultyCreateWithoutPatentsInput[]
      | FacultyUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPatentsInput
      | FacultyCreateOrConnectWithoutPatentsInput[];
    upsert?:
      | FacultyUpsertWithWhereUniqueWithoutPatentsInput
      | FacultyUpsertWithWhereUniqueWithoutPatentsInput[];
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    update?:
      | FacultyUpdateWithWhereUniqueWithoutPatentsInput
      | FacultyUpdateWithWhereUniqueWithoutPatentsInput[];
    updateMany?:
      | FacultyUpdateManyWithWhereWithoutPatentsInput
      | FacultyUpdateManyWithWhereWithoutPatentsInput[];
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
  };

  export type StudentUpdateManyWithoutPatentsNestedInput = {
    create?:
      | XOR<
          StudentCreateWithoutPatentsInput,
          StudentUncheckedCreateWithoutPatentsInput
        >
      | StudentCreateWithoutPatentsInput[]
      | StudentUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | StudentCreateOrConnectWithoutPatentsInput
      | StudentCreateOrConnectWithoutPatentsInput[];
    upsert?:
      | StudentUpsertWithWhereUniqueWithoutPatentsInput
      | StudentUpsertWithWhereUniqueWithoutPatentsInput[];
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    update?:
      | StudentUpdateWithWhereUniqueWithoutPatentsInput
      | StudentUpdateWithWhereUniqueWithoutPatentsInput[];
    updateMany?:
      | StudentUpdateManyWithWhereWithoutPatentsInput
      | StudentUpdateManyWithWhereWithoutPatentsInput[];
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[];
  };

  export type FacultyUncheckedUpdateManyWithoutPatentsNestedInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPatentsInput,
          FacultyUncheckedCreateWithoutPatentsInput
        >
      | FacultyCreateWithoutPatentsInput[]
      | FacultyUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPatentsInput
      | FacultyCreateOrConnectWithoutPatentsInput[];
    upsert?:
      | FacultyUpsertWithWhereUniqueWithoutPatentsInput
      | FacultyUpsertWithWhereUniqueWithoutPatentsInput[];
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    update?:
      | FacultyUpdateWithWhereUniqueWithoutPatentsInput
      | FacultyUpdateWithWhereUniqueWithoutPatentsInput[];
    updateMany?:
      | FacultyUpdateManyWithWhereWithoutPatentsInput
      | FacultyUpdateManyWithWhereWithoutPatentsInput[];
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
  };

  export type StudentUncheckedUpdateManyWithoutPatentsNestedInput = {
    create?:
      | XOR<
          StudentCreateWithoutPatentsInput,
          StudentUncheckedCreateWithoutPatentsInput
        >
      | StudentCreateWithoutPatentsInput[]
      | StudentUncheckedCreateWithoutPatentsInput[];
    connectOrCreate?:
      | StudentCreateOrConnectWithoutPatentsInput
      | StudentCreateOrConnectWithoutPatentsInput[];
    upsert?:
      | StudentUpsertWithWhereUniqueWithoutPatentsInput
      | StudentUpsertWithWhereUniqueWithoutPatentsInput[];
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[];
    update?:
      | StudentUpdateWithWhereUniqueWithoutPatentsInput
      | StudentUpdateWithWhereUniqueWithoutPatentsInput[];
    updateMany?:
      | StudentUpdateManyWithWhereWithoutPatentsInput
      | StudentUpdateManyWithWhereWithoutPatentsInput[];
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[];
  };

  export type PublicationCreateauthorsInput = {
    set: string[];
  };

  export type FacultyCreateNestedManyWithoutPublicationsInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPublicationsInput,
          FacultyUncheckedCreateWithoutPublicationsInput
        >
      | FacultyCreateWithoutPublicationsInput[]
      | FacultyUncheckedCreateWithoutPublicationsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPublicationsInput
      | FacultyCreateOrConnectWithoutPublicationsInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
  };

  export type FacultyUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPublicationsInput,
          FacultyUncheckedCreateWithoutPublicationsInput
        >
      | FacultyCreateWithoutPublicationsInput[]
      | FacultyUncheckedCreateWithoutPublicationsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPublicationsInput
      | FacultyCreateOrConnectWithoutPublicationsInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
  };

  export type PublicationUpdateauthorsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FacultyUpdateManyWithoutPublicationsNestedInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPublicationsInput,
          FacultyUncheckedCreateWithoutPublicationsInput
        >
      | FacultyCreateWithoutPublicationsInput[]
      | FacultyUncheckedCreateWithoutPublicationsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPublicationsInput
      | FacultyCreateOrConnectWithoutPublicationsInput[];
    upsert?:
      | FacultyUpsertWithWhereUniqueWithoutPublicationsInput
      | FacultyUpsertWithWhereUniqueWithoutPublicationsInput[];
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    update?:
      | FacultyUpdateWithWhereUniqueWithoutPublicationsInput
      | FacultyUpdateWithWhereUniqueWithoutPublicationsInput[];
    updateMany?:
      | FacultyUpdateManyWithWhereWithoutPublicationsInput
      | FacultyUpdateManyWithWhereWithoutPublicationsInput[];
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
  };

  export type FacultyUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?:
      | XOR<
          FacultyCreateWithoutPublicationsInput,
          FacultyUncheckedCreateWithoutPublicationsInput
        >
      | FacultyCreateWithoutPublicationsInput[]
      | FacultyUncheckedCreateWithoutPublicationsInput[];
    connectOrCreate?:
      | FacultyCreateOrConnectWithoutPublicationsInput
      | FacultyCreateOrConnectWithoutPublicationsInput[];
    upsert?:
      | FacultyUpsertWithWhereUniqueWithoutPublicationsInput
      | FacultyUpsertWithWhereUniqueWithoutPublicationsInput[];
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    update?:
      | FacultyUpdateWithWhereUniqueWithoutPublicationsInput
      | FacultyUpdateWithWhereUniqueWithoutPublicationsInput[];
    updateMany?:
      | FacultyUpdateManyWithWhereWithoutPublicationsInput
      | FacultyUpdateManyWithWhereWithoutPublicationsInput[];
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType;
  };

  export type NestedEnumEventCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventCategory
      | EnumEventCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventCategoryFilter<$PrismaModel> | $Enums.EventCategory;
  };

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumEventTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventTypeFilter<$PrismaModel>;
    _max?: NestedEnumEventTypeFilter<$PrismaModel>;
  };

  export type NestedEnumEventCategoryWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.EventCategory
      | EnumEventCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.EventCategory[]
      | ListEnumEventCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumEventCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.EventCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventCategoryFilter<$PrismaModel>;
    _max?: NestedEnumEventCategoryFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumWinnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WinnerType | EnumWinnerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumWinnerTypeFilter<$PrismaModel> | $Enums.WinnerType;
  };

  export type NestedEnumWinnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WinnerType | EnumWinnerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.WinnerType[] | ListEnumWinnerTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumWinnerTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.WinnerType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumWinnerTypeFilter<$PrismaModel>;
    _max?: NestedEnumWinnerTypeFilter<$PrismaModel>;
  };

  export type AccountCreateWithoutUserInput = {
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CoreCreateWithoutUserInput = {
    id?: string;
    year: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
  };

  export type CoreUncheckedCreateWithoutUserInput = {
    id?: string;
    year: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
  };

  export type CoreCreateOrConnectWithoutUserInput = {
    where: CoreWhereUniqueInput;
    create: XOR<
      CoreCreateWithoutUserInput,
      CoreUncheckedCreateWithoutUserInput
    >;
  };

  export type CoreCreateManyUserInputEnvelope = {
    data: CoreCreateManyUserInput | CoreCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type LinksCreateWithoutUserInput = {
    id?: string;
    instagram?: string | null;
    linkedin?: string | null;
    github?: string | null;
    twitter?: string | null;
    order?: LinksCreateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksUncheckedCreateWithoutUserInput = {
    id?: string;
    instagram?: string | null;
    linkedin?: string | null;
    github?: string | null;
    twitter?: string | null;
    order?: LinksCreateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksCreateOrConnectWithoutUserInput = {
    where: LinksWhereUniqueInput;
    create: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateWithoutUserInput = {
    sessionToken: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    sessionToken: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type StudentCreateWithoutUserInput = {
    id?: string;
    image: string;
    placement?: PlacementCreateNestedOneWithoutStudentInput;
    patents?: PatentsCreateNestedManyWithoutStudentInput;
  };

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string;
    image: string;
    placement?: PlacementUncheckedCreateNestedOneWithoutStudentInput;
    patents?: PatentsUncheckedCreateNestedManyWithoutStudentInput;
  };

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput;
    create: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
  };

  export type EventCreateWithoutOrganizersInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamCreateNestedManyWithoutEventInput;
    winners?: WinnersCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutOrganizersInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamUncheckedCreateNestedManyWithoutEventInput;
    winners?: WinnersUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutOrganizersInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutOrganizersInput,
      EventUncheckedCreateWithoutOrganizersInput
    >;
  };

  export type TeamCreateWithoutUserInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    event: EventCreateNestedOneWithoutParticipantsInput;
    winner?: WinnersCreateNestedOneWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutUserInput = {
    id?: string;
    attended?: boolean;
    eventId: string;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    winner?: WinnersUncheckedCreateNestedOneWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutUserInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutUserInput,
      TeamUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<
      AccountUpdateManyMutationInput,
      AccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    createdAt?: DateTimeFilter<"Account"> | Date | string;
    updatedAt?: DateTimeFilter<"Account"> | Date | string;
  };

  export type CoreUpsertWithWhereUniqueWithoutUserInput = {
    where: CoreWhereUniqueInput;
    update: XOR<
      CoreUpdateWithoutUserInput,
      CoreUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CoreCreateWithoutUserInput,
      CoreUncheckedCreateWithoutUserInput
    >;
  };

  export type CoreUpdateWithWhereUniqueWithoutUserInput = {
    where: CoreWhereUniqueInput;
    data: XOR<CoreUpdateWithoutUserInput, CoreUncheckedUpdateWithoutUserInput>;
  };

  export type CoreUpdateManyWithWhereWithoutUserInput = {
    where: CoreScalarWhereInput;
    data: XOR<
      CoreUpdateManyMutationInput,
      CoreUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CoreScalarWhereInput = {
    AND?: CoreScalarWhereInput | CoreScalarWhereInput[];
    OR?: CoreScalarWhereInput[];
    NOT?: CoreScalarWhereInput | CoreScalarWhereInput[];
    id?: StringFilter<"Core"> | string;
    year?: StringFilter<"Core"> | string;
    userId?: StringFilter<"Core"> | string;
    image?: StringFilter<"Core"> | string;
    order?: IntFilter<"Core"> | number;
    post?: StringFilter<"Core"> | string;
    quote?: StringNullableFilter<"Core"> | string | null;
  };

  export type LinksUpsertWithoutUserInput = {
    update: XOR<
      LinksUpdateWithoutUserInput,
      LinksUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      LinksCreateWithoutUserInput,
      LinksUncheckedCreateWithoutUserInput
    >;
    where?: LinksWhereInput;
  };

  export type LinksUpdateToOneWithWhereWithoutUserInput = {
    where?: LinksWhereInput;
    data: XOR<
      LinksUpdateWithoutUserInput,
      LinksUncheckedUpdateWithoutUserInput
    >;
  };

  export type LinksUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type LinksUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instagram?: NullableStringFieldUpdateOperationsInput | string | null;
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null;
    github?: NullableStringFieldUpdateOperationsInput | string | null;
    twitter?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: LinksUpdateorderInput | string[];
    custom?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    createdAt?: DateTimeFilter<"Session"> | Date | string;
    updatedAt?: DateTimeFilter<"Session"> | Date | string;
  };

  export type StudentUpsertWithoutUserInput = {
    update: XOR<
      StudentUpdateWithoutUserInput,
      StudentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      StudentCreateWithoutUserInput,
      StudentUncheckedCreateWithoutUserInput
    >;
    where?: StudentWhereInput;
  };

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput;
    data: XOR<
      StudentUpdateWithoutUserInput,
      StudentUncheckedUpdateWithoutUserInput
    >;
  };

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUpdateOneWithoutStudentNestedInput;
    patents?: PatentsUpdateManyWithoutStudentNestedInput;
  };

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUncheckedUpdateOneWithoutStudentNestedInput;
    patents?: PatentsUncheckedUpdateManyWithoutStudentNestedInput;
  };

  export type EventUpsertWithWhereUniqueWithoutOrganizersInput = {
    where: EventWhereUniqueInput;
    update: XOR<
      EventUpdateWithoutOrganizersInput,
      EventUncheckedUpdateWithoutOrganizersInput
    >;
    create: XOR<
      EventCreateWithoutOrganizersInput,
      EventUncheckedCreateWithoutOrganizersInput
    >;
  };

  export type EventUpdateWithWhereUniqueWithoutOrganizersInput = {
    where: EventWhereUniqueInput;
    data: XOR<
      EventUpdateWithoutOrganizersInput,
      EventUncheckedUpdateWithoutOrganizersInput
    >;
  };

  export type EventUpdateManyWithWhereWithoutOrganizersInput = {
    where: EventScalarWhereInput;
    data: XOR<
      EventUpdateManyMutationInput,
      EventUncheckedUpdateManyWithoutOrganizersInput
    >;
  };

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[];
    OR?: EventScalarWhereInput[];
    NOT?: EventScalarWhereInput | EventScalarWhereInput[];
    id?: StringFilter<"Event"> | string;
    title?: StringFilter<"Event"> | string;
    description?: StringNullableFilter<"Event"> | string | null;
    image?: StringFilter<"Event"> | string;
    date?: DateTimeFilter<"Event"> | Date | string;
    time?: StringNullableFilter<"Event"> | string | null;
    reportLink?: StringNullableFilter<"Event"> | string | null;
    venue?: StringNullableFilter<"Event"> | string | null;
    guests?: StringNullableListFilter<"Event">;
    published?: BoolFilter<"Event"> | boolean;
    type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
    category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory;
    maxTeamSize?: IntFilter<"Event"> | number;
    minTeamSize?: IntFilter<"Event"> | number;
    brief?: StringNullableFilter<"Event"> | string | null;
    entryFee?: StringNullableFilter<"Event"> | string | null;
    qr?: StringNullableFilter<"Event"> | string | null;
    registrationsAvailable?: BoolFilter<"Event"> | boolean;
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null;
    maxTeams?: IntNullableFilter<"Event"> | number | null;
    notification?: StringNullableFilter<"Event"> | string | null;
  };

  export type TeamUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamWhereUniqueInput;
    update: XOR<
      TeamUpdateWithoutUserInput,
      TeamUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TeamCreateWithoutUserInput,
      TeamUncheckedCreateWithoutUserInput
    >;
  };

  export type TeamUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamWhereUniqueInput;
    data: XOR<TeamUpdateWithoutUserInput, TeamUncheckedUpdateWithoutUserInput>;
  };

  export type TeamUpdateManyWithWhereWithoutUserInput = {
    where: TeamScalarWhereInput;
    data: XOR<
      TeamUpdateManyMutationInput,
      TeamUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[];
    OR?: TeamScalarWhereInput[];
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[];
    id?: StringFilter<"Team"> | string;
    attended?: BoolFilter<"Team"> | boolean;
    eventId?: StringFilter<"Team"> | string;
    name?: StringNullableFilter<"Team"> | string | null;
    leaderId?: StringNullableFilter<"Team"> | string | null;
    transactionId?: StringNullableFilter<"Team"> | string | null;
    isConfirmed?: BoolFilter<"Team"> | boolean;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PlacementCreateWithoutStudentInput = {
    id?: string;
    year: YearCreateNestedOneWithoutPlacementsInput;
    offers?: OfferCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementUncheckedCreateWithoutStudentInput = {
    id?: string;
    yearId: string;
    offers?: OfferUncheckedCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementCreateOrConnectWithoutStudentInput = {
    where: PlacementWhereUniqueInput;
    create: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
  };

  export type UserCreateWithoutStudentInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutStudentInput,
      UserUncheckedCreateWithoutStudentInput
    >;
  };

  export type PatentsCreateWithoutStudentInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    faculty?: FacultyCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsUncheckedCreateWithoutStudentInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    faculty?: FacultyUncheckedCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsCreateOrConnectWithoutStudentInput = {
    where: PatentsWhereUniqueInput;
    create: XOR<
      PatentsCreateWithoutStudentInput,
      PatentsUncheckedCreateWithoutStudentInput
    >;
  };

  export type PlacementUpsertWithoutStudentInput = {
    update: XOR<
      PlacementUpdateWithoutStudentInput,
      PlacementUncheckedUpdateWithoutStudentInput
    >;
    create: XOR<
      PlacementCreateWithoutStudentInput,
      PlacementUncheckedCreateWithoutStudentInput
    >;
    where?: PlacementWhereInput;
  };

  export type PlacementUpdateToOneWithWhereWithoutStudentInput = {
    where?: PlacementWhereInput;
    data: XOR<
      PlacementUpdateWithoutStudentInput,
      PlacementUncheckedUpdateWithoutStudentInput
    >;
  };

  export type PlacementUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: YearUpdateOneRequiredWithoutPlacementsNestedInput;
    offers?: OfferUpdateManyWithoutPlacementsNestedInput;
  };

  export type PlacementUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearId?: StringFieldUpdateOperationsInput | string;
    offers?: OfferUncheckedUpdateManyWithoutPlacementsNestedInput;
  };

  export type UserUpsertWithoutStudentInput = {
    update: XOR<
      UserUpdateWithoutStudentInput,
      UserUncheckedUpdateWithoutStudentInput
    >;
    create: XOR<
      UserCreateWithoutStudentInput,
      UserUncheckedCreateWithoutStudentInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutStudentInput,
      UserUncheckedUpdateWithoutStudentInput
    >;
  };

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PatentsUpsertWithWhereUniqueWithoutStudentInput = {
    where: PatentsWhereUniqueInput;
    update: XOR<
      PatentsUpdateWithoutStudentInput,
      PatentsUncheckedUpdateWithoutStudentInput
    >;
    create: XOR<
      PatentsCreateWithoutStudentInput,
      PatentsUncheckedCreateWithoutStudentInput
    >;
  };

  export type PatentsUpdateWithWhereUniqueWithoutStudentInput = {
    where: PatentsWhereUniqueInput;
    data: XOR<
      PatentsUpdateWithoutStudentInput,
      PatentsUncheckedUpdateWithoutStudentInput
    >;
  };

  export type PatentsUpdateManyWithWhereWithoutStudentInput = {
    where: PatentsScalarWhereInput;
    data: XOR<
      PatentsUpdateManyMutationInput,
      PatentsUncheckedUpdateManyWithoutStudentInput
    >;
  };

  export type PatentsScalarWhereInput = {
    AND?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
    OR?: PatentsScalarWhereInput[];
    NOT?: PatentsScalarWhereInput | PatentsScalarWhereInput[];
    id?: StringFilter<"Patents"> | string;
    patentId?: StringFilter<"Patents"> | string;
    year?: StringFilter<"Patents"> | string;
    title?: StringFilter<"Patents"> | string;
    authors?: StringNullableListFilter<"Patents">;
    inventorsName?: StringNullableListFilter<"Patents">;
    inventorsAddress?: StringNullableListFilter<"Patents">;
    certificate?: StringNullableFilter<"Patents"> | string | null;
  };

  export type UserCreateWithoutCoreInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCoreInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCoreInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCoreInput,
      UserUncheckedCreateWithoutCoreInput
    >;
  };

  export type UserUpsertWithoutCoreInput = {
    update: XOR<
      UserUpdateWithoutCoreInput,
      UserUncheckedUpdateWithoutCoreInput
    >;
    create: XOR<
      UserCreateWithoutCoreInput,
      UserUncheckedCreateWithoutCoreInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCoreInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCoreInput, UserUncheckedUpdateWithoutCoreInput>;
  };

  export type UserUpdateWithoutCoreInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCoreInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PatentsCreateWithoutFacultyInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    student?: StudentCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsUncheckedCreateWithoutFacultyInput = {
    id?: string;
    patentId: string;
    year: string;
    title: string;
    authors?: PatentsCreateauthorsInput | string[];
    inventorsName?: PatentsCreateinventorsNameInput | string[];
    inventorsAddress?: PatentsCreateinventorsAddressInput | string[];
    certificate?: string | null;
    student?: StudentUncheckedCreateNestedManyWithoutPatentsInput;
  };

  export type PatentsCreateOrConnectWithoutFacultyInput = {
    where: PatentsWhereUniqueInput;
    create: XOR<
      PatentsCreateWithoutFacultyInput,
      PatentsUncheckedCreateWithoutFacultyInput
    >;
  };

  export type PublicationCreateWithoutFacultyInput = {
    id?: string;
    authors?: PublicationCreateauthorsInput | string[];
    title: string;
    publish_date: string;
    publisher?: string | null;
    journal?: string | null;
    conference?: string | null;
    link: string;
    ranking?: string | null;
    impact_factor?: string | null;
    indexed: string;
    publisher_conference?: string | null;
    year: number;
  };

  export type PublicationUncheckedCreateWithoutFacultyInput = {
    id?: string;
    authors?: PublicationCreateauthorsInput | string[];
    title: string;
    publish_date: string;
    publisher?: string | null;
    journal?: string | null;
    conference?: string | null;
    link: string;
    ranking?: string | null;
    impact_factor?: string | null;
    indexed: string;
    publisher_conference?: string | null;
    year: number;
  };

  export type PublicationCreateOrConnectWithoutFacultyInput = {
    where: PublicationWhereUniqueInput;
    create: XOR<
      PublicationCreateWithoutFacultyInput,
      PublicationUncheckedCreateWithoutFacultyInput
    >;
  };

  export type PatentsUpsertWithWhereUniqueWithoutFacultyInput = {
    where: PatentsWhereUniqueInput;
    update: XOR<
      PatentsUpdateWithoutFacultyInput,
      PatentsUncheckedUpdateWithoutFacultyInput
    >;
    create: XOR<
      PatentsCreateWithoutFacultyInput,
      PatentsUncheckedCreateWithoutFacultyInput
    >;
  };

  export type PatentsUpdateWithWhereUniqueWithoutFacultyInput = {
    where: PatentsWhereUniqueInput;
    data: XOR<
      PatentsUpdateWithoutFacultyInput,
      PatentsUncheckedUpdateWithoutFacultyInput
    >;
  };

  export type PatentsUpdateManyWithWhereWithoutFacultyInput = {
    where: PatentsScalarWhereInput;
    data: XOR<
      PatentsUpdateManyMutationInput,
      PatentsUncheckedUpdateManyWithoutFacultyInput
    >;
  };

  export type PublicationUpsertWithWhereUniqueWithoutFacultyInput = {
    where: PublicationWhereUniqueInput;
    update: XOR<
      PublicationUpdateWithoutFacultyInput,
      PublicationUncheckedUpdateWithoutFacultyInput
    >;
    create: XOR<
      PublicationCreateWithoutFacultyInput,
      PublicationUncheckedCreateWithoutFacultyInput
    >;
  };

  export type PublicationUpdateWithWhereUniqueWithoutFacultyInput = {
    where: PublicationWhereUniqueInput;
    data: XOR<
      PublicationUpdateWithoutFacultyInput,
      PublicationUncheckedUpdateWithoutFacultyInput
    >;
  };

  export type PublicationUpdateManyWithWhereWithoutFacultyInput = {
    where: PublicationScalarWhereInput;
    data: XOR<
      PublicationUpdateManyMutationInput,
      PublicationUncheckedUpdateManyWithoutFacultyInput
    >;
  };

  export type PublicationScalarWhereInput = {
    AND?: PublicationScalarWhereInput | PublicationScalarWhereInput[];
    OR?: PublicationScalarWhereInput[];
    NOT?: PublicationScalarWhereInput | PublicationScalarWhereInput[];
    id?: StringFilter<"Publication"> | string;
    authors?: StringNullableListFilter<"Publication">;
    title?: StringFilter<"Publication"> | string;
    publish_date?: StringFilter<"Publication"> | string;
    publisher?: StringNullableFilter<"Publication"> | string | null;
    journal?: StringNullableFilter<"Publication"> | string | null;
    conference?: StringNullableFilter<"Publication"> | string | null;
    link?: StringFilter<"Publication"> | string;
    ranking?: StringNullableFilter<"Publication"> | string | null;
    impact_factor?: StringNullableFilter<"Publication"> | string | null;
    indexed?: StringFilter<"Publication"> | string;
    publisher_conference?: StringNullableFilter<"Publication"> | string | null;
    year?: IntFilter<"Publication"> | number;
  };

  export type TeamCreateWithoutEventInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    winner?: WinnersCreateNestedOneWithoutTeamInput;
    user?: UserCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutEventInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    winner?: WinnersUncheckedCreateNestedOneWithoutTeamInput;
    user?: UserUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutEventInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutEventInput,
      TeamUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamCreateManyEventInputEnvelope = {
    data: TeamCreateManyEventInput | TeamCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type WinnersCreateWithoutEventInput = {
    id?: string;
    position: $Enums.WinnerType;
    team: TeamCreateNestedOneWithoutWinnerInput;
  };

  export type WinnersUncheckedCreateWithoutEventInput = {
    id?: string;
    teamId: string;
    position: $Enums.WinnerType;
  };

  export type WinnersCreateOrConnectWithoutEventInput = {
    where: WinnersWhereUniqueInput;
    create: XOR<
      WinnersCreateWithoutEventInput,
      WinnersUncheckedCreateWithoutEventInput
    >;
  };

  export type WinnersCreateManyEventInputEnvelope = {
    data: WinnersCreateManyEventInput | WinnersCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutOrganizersInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOrganizersInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOrganizersInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOrganizersInput,
      UserUncheckedCreateWithoutOrganizersInput
    >;
  };

  export type TeamUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput;
    update: XOR<
      TeamUpdateWithoutEventInput,
      TeamUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      TeamCreateWithoutEventInput,
      TeamUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput;
    data: XOR<
      TeamUpdateWithoutEventInput,
      TeamUncheckedUpdateWithoutEventInput
    >;
  };

  export type TeamUpdateManyWithWhereWithoutEventInput = {
    where: TeamScalarWhereInput;
    data: XOR<
      TeamUpdateManyMutationInput,
      TeamUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type WinnersUpsertWithWhereUniqueWithoutEventInput = {
    where: WinnersWhereUniqueInput;
    update: XOR<
      WinnersUpdateWithoutEventInput,
      WinnersUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      WinnersCreateWithoutEventInput,
      WinnersUncheckedCreateWithoutEventInput
    >;
  };

  export type WinnersUpdateWithWhereUniqueWithoutEventInput = {
    where: WinnersWhereUniqueInput;
    data: XOR<
      WinnersUpdateWithoutEventInput,
      WinnersUncheckedUpdateWithoutEventInput
    >;
  };

  export type WinnersUpdateManyWithWhereWithoutEventInput = {
    where: WinnersScalarWhereInput;
    data: XOR<
      WinnersUpdateManyMutationInput,
      WinnersUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type WinnersScalarWhereInput = {
    AND?: WinnersScalarWhereInput | WinnersScalarWhereInput[];
    OR?: WinnersScalarWhereInput[];
    NOT?: WinnersScalarWhereInput | WinnersScalarWhereInput[];
    id?: StringFilter<"Winners"> | string;
    teamId?: StringFilter<"Winners"> | string;
    eventId?: StringFilter<"Winners"> | string;
    position?: EnumWinnerTypeFilter<"Winners"> | $Enums.WinnerType;
  };

  export type UserUpsertWithWhereUniqueWithoutOrganizersInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutOrganizersInput,
      UserUncheckedUpdateWithoutOrganizersInput
    >;
    create: XOR<
      UserCreateWithoutOrganizersInput,
      UserUncheckedCreateWithoutOrganizersInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutOrganizersInput = {
    where: UserWhereUniqueInput;
    data: XOR<
      UserUpdateWithoutOrganizersInput,
      UserUncheckedUpdateWithoutOrganizersInput
    >;
  };

  export type UserUpdateManyWithWhereWithoutOrganizersInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutOrganizersInput
    >;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    email?: StringFilter<"User"> | string;
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
    image?: StringNullableFilter<"User"> | string | null;
    bio?: StringNullableFilter<"User"> | string | null;
    phone?: StringNullableFilter<"User"> | string | null;
    username?: StringNullableFilter<"User"> | string | null;
    usn?: StringNullableFilter<"User"> | string | null;
    lightTheme?: StringNullableFilter<"User"> | string | null;
    darkTheme?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    displayName?: StringNullableFilter<"User"> | string | null;
    college?: StringNullableFilter<"User"> | string | null;
    role?: EnumRoleFilter<"User"> | $Enums.Role;
  };

  export type UserCreateWithoutLinksInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
    Team?: TeamCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutLinksInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
    Team?: TeamUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutLinksInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutLinksInput,
      UserUncheckedCreateWithoutLinksInput
    >;
  };

  export type UserUpsertWithoutLinksInput = {
    update: XOR<
      UserUpdateWithoutLinksInput,
      UserUncheckedUpdateWithoutLinksInput
    >;
    create: XOR<
      UserCreateWithoutLinksInput,
      UserUncheckedCreateWithoutLinksInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutLinksInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutLinksInput,
      UserUncheckedUpdateWithoutLinksInput
    >;
  };

  export type UserUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutParticipantsInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    winners?: WinnersCreateNestedManyWithoutEventInput;
    organizers?: UserCreateNestedManyWithoutOrganizersInput;
  };

  export type EventUncheckedCreateWithoutParticipantsInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    winners?: WinnersUncheckedCreateNestedManyWithoutEventInput;
    organizers?: UserUncheckedCreateNestedManyWithoutOrganizersInput;
  };

  export type EventCreateOrConnectWithoutParticipantsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
  };

  export type WinnersCreateWithoutTeamInput = {
    id?: string;
    position: $Enums.WinnerType;
    event: EventCreateNestedOneWithoutWinnersInput;
  };

  export type WinnersUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    position: $Enums.WinnerType;
  };

  export type WinnersCreateOrConnectWithoutTeamInput = {
    where: WinnersWhereUniqueInput;
    create: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
  };

  export type UserCreateWithoutTeamInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    Core?: CoreCreateNestedManyWithoutUserInput;
    links?: LinksCreateNestedOneWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    Student?: StudentCreateNestedOneWithoutUserInput;
    organizers?: EventCreateNestedManyWithoutOrganizersInput;
  };

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    bio?: string | null;
    phone?: string | null;
    username?: string | null;
    usn?: string | null;
    lightTheme?: string | null;
    darkTheme?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    displayName?: string | null;
    college?: string | null;
    role?: $Enums.Role;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Core?: CoreUncheckedCreateNestedManyWithoutUserInput;
    links?: LinksUncheckedCreateNestedOneWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    Student?: StudentUncheckedCreateNestedOneWithoutUserInput;
    organizers?: EventUncheckedCreateNestedManyWithoutOrganizersInput;
  };

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamInput,
      UserUncheckedCreateWithoutTeamInput
    >;
  };

  export type EventUpsertWithoutParticipantsInput = {
    update: XOR<
      EventUpdateWithoutParticipantsInput,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
    create: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutParticipantsInput,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type EventUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    winners?: WinnersUpdateManyWithoutEventNestedInput;
    organizers?: UserUpdateManyWithoutOrganizersNestedInput;
  };

  export type EventUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    winners?: WinnersUncheckedUpdateManyWithoutEventNestedInput;
    organizers?: UserUncheckedUpdateManyWithoutOrganizersNestedInput;
  };

  export type WinnersUpsertWithoutTeamInput = {
    update: XOR<
      WinnersUpdateWithoutTeamInput,
      WinnersUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      WinnersCreateWithoutTeamInput,
      WinnersUncheckedCreateWithoutTeamInput
    >;
    where?: WinnersWhereInput;
  };

  export type WinnersUpdateToOneWithWhereWithoutTeamInput = {
    where?: WinnersWhereInput;
    data: XOR<
      WinnersUpdateWithoutTeamInput,
      WinnersUncheckedUpdateWithoutTeamInput
    >;
  };

  export type WinnersUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
    event?: EventUpdateOneRequiredWithoutWinnersNestedInput;
  };

  export type WinnersUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type UserUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutTeamInput,
      UserUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      UserCreateWithoutTeamInput,
      UserUncheckedCreateWithoutTeamInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput;
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>;
  };

  export type UserUpdateManyWithWhereWithoutTeamInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type EventCreateWithoutWinnersInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamCreateNestedManyWithoutEventInput;
    organizers?: UserCreateNestedManyWithoutOrganizersInput;
  };

  export type EventUncheckedCreateWithoutWinnersInput = {
    id?: string;
    title: string;
    description?: string | null;
    image: string;
    date: Date | string;
    time?: string | null;
    reportLink?: string | null;
    venue?: string | null;
    guests?: EventCreateguestsInput | string[];
    published?: boolean;
    type: $Enums.EventType;
    category: $Enums.EventCategory;
    maxTeamSize?: number;
    minTeamSize?: number;
    brief?: string | null;
    entryFee?: string | null;
    qr?: string | null;
    registrationsAvailable?: boolean;
    endDate?: Date | string | null;
    maxTeams?: number | null;
    notification?: string | null;
    participants?: TeamUncheckedCreateNestedManyWithoutEventInput;
    organizers?: UserUncheckedCreateNestedManyWithoutOrganizersInput;
  };

  export type EventCreateOrConnectWithoutWinnersInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutWinnersInput,
      EventUncheckedCreateWithoutWinnersInput
    >;
  };

  export type TeamCreateWithoutWinnerInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    event: EventCreateNestedOneWithoutParticipantsInput;
    user?: UserCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutWinnerInput = {
    id?: string;
    attended?: boolean;
    eventId: string;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
    user?: UserUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutWinnerInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutWinnerInput,
      TeamUncheckedCreateWithoutWinnerInput
    >;
  };

  export type EventUpsertWithoutWinnersInput = {
    update: XOR<
      EventUpdateWithoutWinnersInput,
      EventUncheckedUpdateWithoutWinnersInput
    >;
    create: XOR<
      EventCreateWithoutWinnersInput,
      EventUncheckedCreateWithoutWinnersInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutWinnersInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutWinnersInput,
      EventUncheckedUpdateWithoutWinnersInput
    >;
  };

  export type EventUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUpdateManyWithoutEventNestedInput;
    organizers?: UserUpdateManyWithoutOrganizersNestedInput;
  };

  export type EventUncheckedUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    organizers?: UserUncheckedUpdateManyWithoutOrganizersNestedInput;
  };

  export type TeamUpsertWithoutWinnerInput = {
    update: XOR<
      TeamUpdateWithoutWinnerInput,
      TeamUncheckedUpdateWithoutWinnerInput
    >;
    create: XOR<
      TeamCreateWithoutWinnerInput,
      TeamUncheckedCreateWithoutWinnerInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutWinnerInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutWinnerInput,
      TeamUncheckedUpdateWithoutWinnerInput
    >;
  };

  export type TeamUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput;
    user?: UserUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    user?: UserUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type StudentCreateWithoutPlacementInput = {
    id?: string;
    image: string;
    user: UserCreateNestedOneWithoutStudentInput;
    patents?: PatentsCreateNestedManyWithoutStudentInput;
  };

  export type StudentUncheckedCreateWithoutPlacementInput = {
    id?: string;
    image: string;
    userId: string;
    patents?: PatentsUncheckedCreateNestedManyWithoutStudentInput;
  };

  export type StudentCreateOrConnectWithoutPlacementInput = {
    where: StudentWhereUniqueInput;
    create: XOR<
      StudentCreateWithoutPlacementInput,
      StudentUncheckedCreateWithoutPlacementInput
    >;
  };

  export type YearCreateWithoutPlacementsInput = {
    id?: string;
    year: string;
    companies?: YearCreatecompaniesInput | string[];
  };

  export type YearUncheckedCreateWithoutPlacementsInput = {
    id?: string;
    year: string;
    companies?: YearCreatecompaniesInput | string[];
  };

  export type YearCreateOrConnectWithoutPlacementsInput = {
    where: YearWhereUniqueInput;
    create: XOR<
      YearCreateWithoutPlacementsInput,
      YearUncheckedCreateWithoutPlacementsInput
    >;
  };

  export type OfferCreateWithoutPlacementsInput = {
    id?: string;
    package: string;
    company: CompanyCreateNestedOneWithoutOffersInput;
  };

  export type OfferUncheckedCreateWithoutPlacementsInput = {
    id?: string;
    companyId: string;
    package: string;
  };

  export type OfferCreateOrConnectWithoutPlacementsInput = {
    where: OfferWhereUniqueInput;
    create: XOR<
      OfferCreateWithoutPlacementsInput,
      OfferUncheckedCreateWithoutPlacementsInput
    >;
  };

  export type StudentUpsertWithoutPlacementInput = {
    update: XOR<
      StudentUpdateWithoutPlacementInput,
      StudentUncheckedUpdateWithoutPlacementInput
    >;
    create: XOR<
      StudentCreateWithoutPlacementInput,
      StudentUncheckedCreateWithoutPlacementInput
    >;
    where?: StudentWhereInput;
  };

  export type StudentUpdateToOneWithWhereWithoutPlacementInput = {
    where?: StudentWhereInput;
    data: XOR<
      StudentUpdateWithoutPlacementInput,
      StudentUncheckedUpdateWithoutPlacementInput
    >;
  };

  export type StudentUpdateWithoutPlacementInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    user?: UserUpdateOneRequiredWithoutStudentNestedInput;
    patents?: PatentsUpdateManyWithoutStudentNestedInput;
  };

  export type StudentUncheckedUpdateWithoutPlacementInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    patents?: PatentsUncheckedUpdateManyWithoutStudentNestedInput;
  };

  export type YearUpsertWithoutPlacementsInput = {
    update: XOR<
      YearUpdateWithoutPlacementsInput,
      YearUncheckedUpdateWithoutPlacementsInput
    >;
    create: XOR<
      YearCreateWithoutPlacementsInput,
      YearUncheckedCreateWithoutPlacementsInput
    >;
    where?: YearWhereInput;
  };

  export type YearUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: YearWhereInput;
    data: XOR<
      YearUpdateWithoutPlacementsInput,
      YearUncheckedUpdateWithoutPlacementsInput
    >;
  };

  export type YearUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
  };

  export type YearUncheckedUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    companies?: YearUpdatecompaniesInput | string[];
  };

  export type OfferUpsertWithWhereUniqueWithoutPlacementsInput = {
    where: OfferWhereUniqueInput;
    update: XOR<
      OfferUpdateWithoutPlacementsInput,
      OfferUncheckedUpdateWithoutPlacementsInput
    >;
    create: XOR<
      OfferCreateWithoutPlacementsInput,
      OfferUncheckedCreateWithoutPlacementsInput
    >;
  };

  export type OfferUpdateWithWhereUniqueWithoutPlacementsInput = {
    where: OfferWhereUniqueInput;
    data: XOR<
      OfferUpdateWithoutPlacementsInput,
      OfferUncheckedUpdateWithoutPlacementsInput
    >;
  };

  export type OfferUpdateManyWithWhereWithoutPlacementsInput = {
    where: OfferScalarWhereInput;
    data: XOR<
      OfferUpdateManyMutationInput,
      OfferUncheckedUpdateManyWithoutPlacementsInput
    >;
  };

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[];
    OR?: OfferScalarWhereInput[];
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[];
    id?: StringFilter<"Offer"> | string;
    companyId?: StringFilter<"Offer"> | string;
    package?: StringFilter<"Offer"> | string;
  };

  export type OfferCreateWithoutCompanyInput = {
    id?: string;
    package: string;
    placements?: PlacementCreateNestedManyWithoutOffersInput;
  };

  export type OfferUncheckedCreateWithoutCompanyInput = {
    id?: string;
    package: string;
    placements?: PlacementUncheckedCreateNestedManyWithoutOffersInput;
  };

  export type OfferCreateOrConnectWithoutCompanyInput = {
    where: OfferWhereUniqueInput;
    create: XOR<
      OfferCreateWithoutCompanyInput,
      OfferUncheckedCreateWithoutCompanyInput
    >;
  };

  export type OfferCreateManyCompanyInputEnvelope = {
    data: OfferCreateManyCompanyInput | OfferCreateManyCompanyInput[];
    skipDuplicates?: boolean;
  };

  export type OfferUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OfferWhereUniqueInput;
    update: XOR<
      OfferUpdateWithoutCompanyInput,
      OfferUncheckedUpdateWithoutCompanyInput
    >;
    create: XOR<
      OfferCreateWithoutCompanyInput,
      OfferUncheckedCreateWithoutCompanyInput
    >;
  };

  export type OfferUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OfferWhereUniqueInput;
    data: XOR<
      OfferUpdateWithoutCompanyInput,
      OfferUncheckedUpdateWithoutCompanyInput
    >;
  };

  export type OfferUpdateManyWithWhereWithoutCompanyInput = {
    where: OfferScalarWhereInput;
    data: XOR<
      OfferUpdateManyMutationInput,
      OfferUncheckedUpdateManyWithoutCompanyInput
    >;
  };

  export type CompanyCreateWithoutOffersInput = {
    id?: string;
    companyName: string;
    image: string;
  };

  export type CompanyUncheckedCreateWithoutOffersInput = {
    id?: string;
    companyName: string;
    image: string;
  };

  export type CompanyCreateOrConnectWithoutOffersInput = {
    where: CompanyWhereUniqueInput;
    create: XOR<
      CompanyCreateWithoutOffersInput,
      CompanyUncheckedCreateWithoutOffersInput
    >;
  };

  export type PlacementCreateWithoutOffersInput = {
    id?: string;
    student: StudentCreateNestedOneWithoutPlacementInput;
    year: YearCreateNestedOneWithoutPlacementsInput;
  };

  export type PlacementUncheckedCreateWithoutOffersInput = {
    id?: string;
    yearId: string;
    studentId: string;
  };

  export type PlacementCreateOrConnectWithoutOffersInput = {
    where: PlacementWhereUniqueInput;
    create: XOR<
      PlacementCreateWithoutOffersInput,
      PlacementUncheckedCreateWithoutOffersInput
    >;
  };

  export type CompanyUpsertWithoutOffersInput = {
    update: XOR<
      CompanyUpdateWithoutOffersInput,
      CompanyUncheckedUpdateWithoutOffersInput
    >;
    create: XOR<
      CompanyCreateWithoutOffersInput,
      CompanyUncheckedCreateWithoutOffersInput
    >;
    where?: CompanyWhereInput;
  };

  export type CompanyUpdateToOneWithWhereWithoutOffersInput = {
    where?: CompanyWhereInput;
    data: XOR<
      CompanyUpdateWithoutOffersInput,
      CompanyUncheckedUpdateWithoutOffersInput
    >;
  };

  export type CompanyUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
  };

  export type CompanyUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
  };

  export type PlacementUpsertWithWhereUniqueWithoutOffersInput = {
    where: PlacementWhereUniqueInput;
    update: XOR<
      PlacementUpdateWithoutOffersInput,
      PlacementUncheckedUpdateWithoutOffersInput
    >;
    create: XOR<
      PlacementCreateWithoutOffersInput,
      PlacementUncheckedCreateWithoutOffersInput
    >;
  };

  export type PlacementUpdateWithWhereUniqueWithoutOffersInput = {
    where: PlacementWhereUniqueInput;
    data: XOR<
      PlacementUpdateWithoutOffersInput,
      PlacementUncheckedUpdateWithoutOffersInput
    >;
  };

  export type PlacementUpdateManyWithWhereWithoutOffersInput = {
    where: PlacementScalarWhereInput;
    data: XOR<
      PlacementUpdateManyMutationInput,
      PlacementUncheckedUpdateManyWithoutOffersInput
    >;
  };

  export type PlacementScalarWhereInput = {
    AND?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
    OR?: PlacementScalarWhereInput[];
    NOT?: PlacementScalarWhereInput | PlacementScalarWhereInput[];
    id?: StringFilter<"Placement"> | string;
    yearId?: StringFilter<"Placement"> | string;
    studentId?: StringFilter<"Placement"> | string;
  };

  export type PlacementCreateWithoutYearInput = {
    id?: string;
    student: StudentCreateNestedOneWithoutPlacementInput;
    offers?: OfferCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementUncheckedCreateWithoutYearInput = {
    id?: string;
    studentId: string;
    offers?: OfferUncheckedCreateNestedManyWithoutPlacementsInput;
  };

  export type PlacementCreateOrConnectWithoutYearInput = {
    where: PlacementWhereUniqueInput;
    create: XOR<
      PlacementCreateWithoutYearInput,
      PlacementUncheckedCreateWithoutYearInput
    >;
  };

  export type PlacementCreateManyYearInputEnvelope = {
    data: PlacementCreateManyYearInput | PlacementCreateManyYearInput[];
    skipDuplicates?: boolean;
  };

  export type PlacementUpsertWithWhereUniqueWithoutYearInput = {
    where: PlacementWhereUniqueInput;
    update: XOR<
      PlacementUpdateWithoutYearInput,
      PlacementUncheckedUpdateWithoutYearInput
    >;
    create: XOR<
      PlacementCreateWithoutYearInput,
      PlacementUncheckedCreateWithoutYearInput
    >;
  };

  export type PlacementUpdateWithWhereUniqueWithoutYearInput = {
    where: PlacementWhereUniqueInput;
    data: XOR<
      PlacementUpdateWithoutYearInput,
      PlacementUncheckedUpdateWithoutYearInput
    >;
  };

  export type PlacementUpdateManyWithWhereWithoutYearInput = {
    where: PlacementScalarWhereInput;
    data: XOR<
      PlacementUpdateManyMutationInput,
      PlacementUncheckedUpdateManyWithoutYearInput
    >;
  };

  export type FacultyCreateWithoutPatentsInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    publications?: PublicationCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyUncheckedCreateWithoutPatentsInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    publications?: PublicationUncheckedCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyCreateOrConnectWithoutPatentsInput = {
    where: FacultyWhereUniqueInput;
    create: XOR<
      FacultyCreateWithoutPatentsInput,
      FacultyUncheckedCreateWithoutPatentsInput
    >;
  };

  export type StudentCreateWithoutPatentsInput = {
    id?: string;
    image: string;
    placement?: PlacementCreateNestedOneWithoutStudentInput;
    user: UserCreateNestedOneWithoutStudentInput;
  };

  export type StudentUncheckedCreateWithoutPatentsInput = {
    id?: string;
    image: string;
    userId: string;
    placement?: PlacementUncheckedCreateNestedOneWithoutStudentInput;
  };

  export type StudentCreateOrConnectWithoutPatentsInput = {
    where: StudentWhereUniqueInput;
    create: XOR<
      StudentCreateWithoutPatentsInput,
      StudentUncheckedCreateWithoutPatentsInput
    >;
  };

  export type FacultyUpsertWithWhereUniqueWithoutPatentsInput = {
    where: FacultyWhereUniqueInput;
    update: XOR<
      FacultyUpdateWithoutPatentsInput,
      FacultyUncheckedUpdateWithoutPatentsInput
    >;
    create: XOR<
      FacultyCreateWithoutPatentsInput,
      FacultyUncheckedCreateWithoutPatentsInput
    >;
  };

  export type FacultyUpdateWithWhereUniqueWithoutPatentsInput = {
    where: FacultyWhereUniqueInput;
    data: XOR<
      FacultyUpdateWithoutPatentsInput,
      FacultyUncheckedUpdateWithoutPatentsInput
    >;
  };

  export type FacultyUpdateManyWithWhereWithoutPatentsInput = {
    where: FacultyScalarWhereInput;
    data: XOR<
      FacultyUpdateManyMutationInput,
      FacultyUncheckedUpdateManyWithoutPatentsInput
    >;
  };

  export type FacultyScalarWhereInput = {
    AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
    OR?: FacultyScalarWhereInput[];
    NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
    id?: StringFilter<"Faculty"> | string;
    name?: StringFilter<"Faculty"> | string;
    email?: StringFilter<"Faculty"> | string;
    designation?: StringFilter<"Faculty"> | string;
    image?: StringFilter<"Faculty"> | string;
    about?: StringNullableListFilter<"Faculty">;
    order?: IntFilter<"Faculty"> | number;
    published?: BoolFilter<"Faculty"> | boolean;
    designation2?: StringNullableFilter<"Faculty"> | string | null;
  };

  export type StudentUpsertWithWhereUniqueWithoutPatentsInput = {
    where: StudentWhereUniqueInput;
    update: XOR<
      StudentUpdateWithoutPatentsInput,
      StudentUncheckedUpdateWithoutPatentsInput
    >;
    create: XOR<
      StudentCreateWithoutPatentsInput,
      StudentUncheckedCreateWithoutPatentsInput
    >;
  };

  export type StudentUpdateWithWhereUniqueWithoutPatentsInput = {
    where: StudentWhereUniqueInput;
    data: XOR<
      StudentUpdateWithoutPatentsInput,
      StudentUncheckedUpdateWithoutPatentsInput
    >;
  };

  export type StudentUpdateManyWithWhereWithoutPatentsInput = {
    where: StudentScalarWhereInput;
    data: XOR<
      StudentUpdateManyMutationInput,
      StudentUncheckedUpdateManyWithoutPatentsInput
    >;
  };

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[];
    OR?: StudentScalarWhereInput[];
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[];
    id?: StringFilter<"Student"> | string;
    image?: StringFilter<"Student"> | string;
    userId?: StringFilter<"Student"> | string;
  };

  export type FacultyCreateWithoutPublicationsInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    patents?: PatentsCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyUncheckedCreateWithoutPublicationsInput = {
    id?: string;
    name: string;
    email: string;
    designation: string;
    image: string;
    about?: FacultyCreateaboutInput | string[];
    order: number;
    published?: boolean;
    designation2?: string | null;
    patents?: PatentsUncheckedCreateNestedManyWithoutFacultyInput;
  };

  export type FacultyCreateOrConnectWithoutPublicationsInput = {
    where: FacultyWhereUniqueInput;
    create: XOR<
      FacultyCreateWithoutPublicationsInput,
      FacultyUncheckedCreateWithoutPublicationsInput
    >;
  };

  export type FacultyUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: FacultyWhereUniqueInput;
    update: XOR<
      FacultyUpdateWithoutPublicationsInput,
      FacultyUncheckedUpdateWithoutPublicationsInput
    >;
    create: XOR<
      FacultyCreateWithoutPublicationsInput,
      FacultyUncheckedCreateWithoutPublicationsInput
    >;
  };

  export type FacultyUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: FacultyWhereUniqueInput;
    data: XOR<
      FacultyUpdateWithoutPublicationsInput,
      FacultyUncheckedUpdateWithoutPublicationsInput
    >;
  };

  export type FacultyUpdateManyWithWhereWithoutPublicationsInput = {
    where: FacultyScalarWhereInput;
    data: XOR<
      FacultyUpdateManyMutationInput,
      FacultyUncheckedUpdateManyWithoutPublicationsInput
    >;
  };

  export type AccountCreateManyUserInput = {
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CoreCreateManyUserInput = {
    id?: string;
    year: string;
    image: string;
    order: number;
    post: string;
    quote?: string | null;
  };

  export type SessionCreateManyUserInput = {
    sessionToken: string;
    expires: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    order?: IntFieldUpdateOperationsInput | number;
    post?: StringFieldUpdateOperationsInput | string;
    quote?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUpdateManyWithoutEventNestedInput;
    winners?: WinnersUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
    participants?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    winners?: WinnersUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateManyWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    time?: NullableStringFieldUpdateOperationsInput | string | null;
    reportLink?: NullableStringFieldUpdateOperationsInput | string | null;
    venue?: NullableStringFieldUpdateOperationsInput | string | null;
    guests?: EventUpdateguestsInput | string[];
    published?: BoolFieldUpdateOperationsInput | boolean;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    category?:
      | EnumEventCategoryFieldUpdateOperationsInput
      | $Enums.EventCategory;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    minTeamSize?: IntFieldUpdateOperationsInput | number;
    brief?: NullableStringFieldUpdateOperationsInput | string | null;
    entryFee?: NullableStringFieldUpdateOperationsInput | string | null;
    qr?: NullableStringFieldUpdateOperationsInput | string | null;
    registrationsAvailable?: BoolFieldUpdateOperationsInput | boolean;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null;
    notification?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TeamUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput;
    winner?: WinnersUpdateOneWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    winner?: WinnersUncheckedUpdateOneWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PatentsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    faculty?: FacultyUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    faculty?: FacultyUncheckedUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PatentsUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    student?: StudentUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
    student?: StudentUncheckedUpdateManyWithoutPatentsNestedInput;
  };

  export type PatentsUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    patentId?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    authors?: PatentsUpdateauthorsInput | string[];
    inventorsName?: PatentsUpdateinventorsNameInput | string[];
    inventorsAddress?: PatentsUpdateinventorsAddressInput | string[];
    certificate?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PublicationUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
  };

  export type PublicationUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
  };

  export type PublicationUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authors?: PublicationUpdateauthorsInput | string[];
    title?: StringFieldUpdateOperationsInput | string;
    publish_date?: StringFieldUpdateOperationsInput | string;
    publisher?: NullableStringFieldUpdateOperationsInput | string | null;
    journal?: NullableStringFieldUpdateOperationsInput | string | null;
    conference?: NullableStringFieldUpdateOperationsInput | string | null;
    link?: StringFieldUpdateOperationsInput | string;
    ranking?: NullableStringFieldUpdateOperationsInput | string | null;
    impact_factor?: NullableStringFieldUpdateOperationsInput | string | null;
    indexed?: StringFieldUpdateOperationsInput | string;
    publisher_conference?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    year?: IntFieldUpdateOperationsInput | number;
  };

  export type TeamCreateManyEventInput = {
    id?: string;
    attended?: boolean;
    name?: string | null;
    leaderId?: string | null;
    transactionId?: string | null;
    isConfirmed?: boolean;
  };

  export type WinnersCreateManyEventInput = {
    id?: string;
    teamId: string;
    position: $Enums.WinnerType;
  };

  export type TeamUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    winner?: WinnersUpdateOneWithoutTeamNestedInput;
    user?: UserUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
    winner?: WinnersUncheckedUpdateOneWithoutTeamNestedInput;
    user?: UserUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    attended?: BoolFieldUpdateOperationsInput | boolean;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type WinnersUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
    team?: TeamUpdateOneRequiredWithoutWinnerNestedInput;
  };

  export type WinnersUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type WinnersUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    position?: EnumWinnerTypeFieldUpdateOperationsInput | $Enums.WinnerType;
  };

  export type UserUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    Team?: TeamUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    Team?: TeamUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutOrganizersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type UserUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    Core?: CoreUpdateManyWithoutUserNestedInput;
    links?: LinksUpdateOneWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    Student?: StudentUpdateOneWithoutUserNestedInput;
    organizers?: EventUpdateManyWithoutOrganizersNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Core?: CoreUncheckedUpdateManyWithoutUserNestedInput;
    links?: LinksUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    Student?: StudentUncheckedUpdateOneWithoutUserNestedInput;
    organizers?: EventUncheckedUpdateManyWithoutOrganizersNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    usn?: NullableStringFieldUpdateOperationsInput | string | null;
    lightTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    darkTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    college?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type OfferUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
    company?: CompanyUpdateOneRequiredWithoutOffersNestedInput;
  };

  export type OfferUncheckedUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyId?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
  };

  export type OfferUncheckedUpdateManyWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyId?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
  };

  export type OfferCreateManyCompanyInput = {
    id?: string;
    package: string;
  };

  export type OfferUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
    placements?: PlacementUpdateManyWithoutOffersNestedInput;
  };

  export type OfferUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
    placements?: PlacementUncheckedUpdateManyWithoutOffersNestedInput;
  };

  export type OfferUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    package?: StringFieldUpdateOperationsInput | string;
  };

  export type PlacementUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    student?: StudentUpdateOneRequiredWithoutPlacementNestedInput;
    year?: YearUpdateOneRequiredWithoutPlacementsNestedInput;
  };

  export type PlacementUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearId?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
  };

  export type PlacementUncheckedUpdateManyWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearId?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
  };

  export type PlacementCreateManyYearInput = {
    id?: string;
    studentId: string;
  };

  export type PlacementUpdateWithoutYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    student?: StudentUpdateOneRequiredWithoutPlacementNestedInput;
    offers?: OfferUpdateManyWithoutPlacementsNestedInput;
  };

  export type PlacementUncheckedUpdateWithoutYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
    offers?: OfferUncheckedUpdateManyWithoutPlacementsNestedInput;
  };

  export type PlacementUncheckedUpdateManyWithoutYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId?: StringFieldUpdateOperationsInput | string;
  };

  export type FacultyUpdateWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    publications?: PublicationUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyUncheckedUpdateWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    publications?: PublicationUncheckedUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyUncheckedUpdateManyWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudentUpdateWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUpdateOneWithoutStudentNestedInput;
    user?: UserUpdateOneRequiredWithoutStudentNestedInput;
  };

  export type StudentUncheckedUpdateWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    placement?: PlacementUncheckedUpdateOneWithoutStudentNestedInput;
  };

  export type StudentUncheckedUpdateManyWithoutPatentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type FacultyUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    patents?: PatentsUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
    patents?: PatentsUncheckedUpdateManyWithoutFacultyNestedInput;
  };

  export type FacultyUncheckedUpdateManyWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    designation?: StringFieldUpdateOperationsInput | string;
    image?: StringFieldUpdateOperationsInput | string;
    about?: FacultyUpdateaboutInput | string[];
    order?: IntFieldUpdateOperationsInput | number;
    published?: BoolFieldUpdateOperationsInput | boolean;
    designation2?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
